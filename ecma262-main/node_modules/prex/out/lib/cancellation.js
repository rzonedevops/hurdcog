"use strict";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Licensed under the Apache License, Version 2.0.

See LICENSE file in the project root for details.
***************************************************************************** */
Object.defineProperty(exports, "__esModule", { value: true });
const cancelable_1 = require("@esfx/cancelable");
const disposable_1 = require("@esfx/disposable");
const list_1 = require("./list");
const utils_1 = require("./utils");
/**
 * Signals a CancellationToken that it should be canceled.
 */
class CancellationTokenSource {
    /**
     * Initializes a new instance of a CancellationTokenSource.
     *
     * @param linkedTokens An optional iterable of tokens to which to link this source.
     */
    constructor(linkedTokens) {
        this._state = "open";
        this._token = undefined;
        this._registrations = undefined;
        this._linkingRegistrations = undefined;
        if (!utils_1.isIterable(linkedTokens, /*optional*/ true))
            throw new TypeError("Object not iterable: linkedTokens.");
        if (linkedTokens) {
            for (const linkedToken of linkedTokens) {
                if (!cancelable_1.Cancelable.hasInstance(linkedToken)) {
                    throw new TypeError("CancellationToken expected.");
                }
                const token = CancellationToken.from(linkedToken);
                if (token.cancellationRequested) {
                    this._state = "cancellationRequested";
                    this._unlink();
                    break;
                }
                else if (token.canBeCanceled) {
                    if (this._linkingRegistrations === undefined) {
                        this._linkingRegistrations = [];
                    }
                    this._linkingRegistrations.push(token.register(() => this.cancel()));
                }
            }
        }
    }
    /**
     * Gets a CancellationToken linked to this source.
     */
    get token() {
        if (this._token === undefined) {
            this._token = new CancellationToken(this);
        }
        return this._token;
    }
    /*@internal*/ get _currentState() {
        if (this._state === "open" && this._linkingRegistrations && this._linkingRegistrations.length > 0) {
            for (const registration of this._linkingRegistrations) {
                if (registration._cancellationSource &&
                    registration._cancellationSource._currentState === "cancellationRequested") {
                    return "cancellationRequested";
                }
            }
        }
        return this._state;
    }
    /**
     * Gets a value indicating whether cancellation has been requested.
     */
    /*@internal*/ get _cancellationRequested() {
        return this._currentState === "cancellationRequested";
    }
    /**
     * Gets a value indicating whether the source can be canceled.
     */
    /*@internal*/ get _canBeCanceled() {
        return this._currentState !== "closed";
    }
    /**
     * Cancels the source, evaluating any registered callbacks. If any callback raises an exception,
     * the exception is propagated to a host specific unhanedle exception mechanism.
     */
    cancel() {
        if (this._state !== "open") {
            return;
        }
        this._state = "cancellationRequested";
        this._unlink();
        const registrations = this._registrations;
        this._registrations = undefined;
        if (registrations && registrations.size > 0) {
            for (const registration of registrations) {
                if (registration._cancellationTarget) {
                    this._executeCallback(registration._cancellationTarget);
                }
            }
        }
    }
    /**
     * Closes the source, preventing the possibility of future cancellation.
     */
    close() {
        if (this._state !== "open") {
            return;
        }
        this._state = "closed";
        this._unlink();
        const callbacks = this._registrations;
        this._registrations = undefined;
        if (callbacks !== undefined) {
            // The registration for each callback holds onto the node, the node holds onto the
            // list, and the list holds all other nodes and callbacks. By clearing the list, the
            // GC can collect any otherwise unreachable nodes.
            callbacks.clear();
        }
    }
    /**
     * Registers a callback to execute when cancellation has been requested. If cancellation has
     * already been requested, the callback is executed immediately.
     *
     * @param callback The callback to register.
     */
    /*@internal*/ _register(callback) {
        if (!utils_1.isFunction(callback))
            throw new TypeError("Function expected: callback.");
        if (this._state === "cancellationRequested") {
            this._executeCallback(callback);
            return emptyRegistration;
        }
        if (this._state === "closed") {
            return emptyRegistration;
        }
        if (this._registrations === undefined) {
            this._registrations = new list_1.LinkedList();
        }
        function unregister() {
            if (this._cancellationSource === undefined)
                return;
            if (this._cancellationSource._registrations) {
                this._cancellationSource._registrations.deleteNode(node);
            }
            this._cancellationSource = undefined;
            this._cancellationTarget = undefined;
        }
        const node = this._registrations.push({
            _cancellationSource: this,
            _cancellationTarget: callback,
            unregister,
            [disposable_1.Disposable.dispose]: unregister,
        });
        return node.value;
    }
    /**
     * Executes the provided callback.
     *
     * @param callback The callback to execute.
     */
    _executeCallback(callback) {
        try {
            callback();
        }
        catch (e) {
            // HostReportError(e)
            setTimeout(() => { throw e; }, 0);
        }
    }
    /**
     * Unlinks the source from any linked tokens.
     */
    _unlink() {
        const linkingRegistrations = this._linkingRegistrations;
        this._linkingRegistrations = undefined;
        if (linkingRegistrations !== undefined) {
            for (const linkingRegistration of linkingRegistrations) {
                linkingRegistration.unregister();
            }
        }
    }
    // #region Cancelable
    [cancelable_1.Cancelable.cancelSignal]() { return this.token[cancelable_1.Cancelable.cancelSignal](); }
    // #endregion Cancelable
    // #region CancelableSource
    [cancelable_1.CancelableSource.cancel]() { this.cancel(); }
}
exports.CancellationTokenSource = CancellationTokenSource;
// A source that cannot be canceled.
const closedSource = new CancellationTokenSource();
closedSource.close();
// A source that is already canceled.
const canceledSource = new CancellationTokenSource();
canceledSource.cancel();
const weakCancelableToToken = typeof WeakMap === "function" ? new WeakMap() : undefined;
const weakTokenToCancelable = typeof WeakMap === "function" ? new WeakMap() : undefined;
/**
 * Propagates notifications that operations should be canceled.
 */
class CancellationToken {
    constructor(source) {
        if (utils_1.isMissing(source)) {
            this._source = closedSource;
        }
        else if (utils_1.isBoolean(source)) {
            this._source = source ? canceledSource : closedSource;
        }
        else {
            if (!utils_1.isInstance(source, CancellationTokenSource))
                throw new TypeError("CancellationTokenSource expected: source.");
            this._source = source;
        }
        Object.freeze(this);
    }
    /**
     * Gets a value indicating whether cancellation has been requested.
     */
    get cancellationRequested() {
        return this._source._cancellationRequested;
    }
    /**
     * Gets a value indicating whether the underlying source can be canceled.
     */
    get canBeCanceled() {
        return this._source._canBeCanceled;
    }
    /**
     * Adapts a CancellationToken-like primitive from a different library.
     */
    static from(cancelable) {
        if (cancelable instanceof CancellationToken) {
            return cancelable;
        }
        if (cancelable_1.Cancelable.hasInstance(cancelable)) {
            const signal = cancelable[cancelable_1.Cancelable.cancelSignal]();
            if (signal.signaled)
                return CancellationToken.canceled;
            let token = weakCancelableToToken && weakCancelableToToken.get(cancelable);
            if (!token) {
                const source = new CancellationTokenSource();
                signal.subscribe(() => source.cancel());
                token = source.token;
                if (weakCancelableToToken)
                    weakCancelableToToken.set(cancelable, token);
            }
            return token;
        }
        if (isVSCodeCancellationTokenLike(cancelable)) {
            if (cancelable.isCancellationRequested)
                return CancellationToken.canceled;
            const source = new CancellationTokenSource();
            cancelable.onCancellationRequested(() => source.cancel());
            return source.token;
        }
        if (isAbortSignalLike(cancelable)) {
            if (cancelable.aborted)
                return CancellationToken.canceled;
            const source = new CancellationTokenSource();
            cancelable.addEventListener("abort", () => source.cancel());
            return source.token;
        }
        throw new TypeError("Invalid token.");
    }
    /**
     * Returns a CancellationToken that becomes canceled when **any** of the provided tokens are canceled.
     * @param tokens An iterable of CancellationToken objects.
     */
    static race(tokens) {
        if (!utils_1.isIterable(tokens))
            throw new TypeError("Object not iterable: iterable.");
        const tokensArray = Array.isArray(tokens) ? tokens : [...tokens];
        return tokensArray.length > 0 ? new CancellationTokenSource(tokensArray).token : CancellationToken.none;
    }
    /**
     * Returns a CancellationToken that becomes canceled when **all** of the provided tokens are canceled.
     * @param tokens An iterable of CancellationToken objects.
     */
    static all(tokens) {
        if (!utils_1.isIterable(tokens))
            throw new TypeError("Object not iterable: iterable.");
        const tokensArray = Array.isArray(tokens) ? tokens : [...tokens];
        return tokensArray.length > 0 ? new CancellationTokenCountdown(tokensArray).token : CancellationToken.none;
    }
    /**
     * Throws a CancelError if cancellation has been requested.
     */
    throwIfCancellationRequested() {
        if (this.cancellationRequested) {
            throw new CancelError();
        }
    }
    /**
     * Registers a callback to execute when cancellation is requested.
     *
     * @param callback The callback to register.
     */
    register(callback) {
        return this._source._register(callback);
    }
    // #region Cancelable
    [cancelable_1.Cancelable.cancelSignal]() {
        let signal = weakTokenToCancelable === null || weakTokenToCancelable === void 0 ? void 0 : weakTokenToCancelable.get(this);
        if (!signal) {
            const token = this;
            signal = {
                get signaled() { return token.cancellationRequested; },
                subscribe(onCancellationRequested) {
                    const registration = token.register(onCancellationRequested);
                    return {
                        unsubscribe() { registration.unregister(); },
                        [disposable_1.Disposable.dispose]() { this.unsubscribe(); }
                    };
                },
                [cancelable_1.Cancelable.cancelSignal]() {
                    return this;
                }
            };
            weakTokenToCancelable === null || weakTokenToCancelable === void 0 ? void 0 : weakTokenToCancelable.set(this, signal);
        }
        return signal;
    }
}
exports.CancellationToken = CancellationToken;
/**
 * A token which will never be canceled.
 */
CancellationToken.none = new CancellationToken(/*canceled*/ false);
/**
 * A token that is already canceled.
 */
CancellationToken.canceled = new CancellationToken(/*canceled*/ true);
/**
 * An error thrown when an operation is canceled.
 */
class CancelError extends Error {
    constructor(message) {
        super(message || "Operation was canceled");
    }
}
exports.CancelError = CancelError;
CancelError.prototype.name = "CancelError";
const emptyRegistration = Object.create({ unregister() { } });
function isVSCodeCancellationTokenLike(token) {
    return typeof token === "object"
        && token !== null
        && utils_1.isBoolean(token.isCancellationRequested)
        && utils_1.isFunction(token.onCancellationRequested);
}
function isAbortSignalLike(token) {
    return typeof token === "object"
        && token !== null
        && utils_1.isBoolean(token.aborted)
        && utils_1.isFunction(token.addEventListener);
}
/**
 * An object that provides a CancellationToken that becomes cancelled when **all** of its
 * containing tokens are canceled. This is similar to `CancellationToken.all`, except that you are
 * able to add additional tokens.
 */
class CancellationTokenCountdown {
    constructor(iterable) {
        this._addedCount = 0;
        this._signaledCount = 0;
        this._canBeSignaled = false;
        this._source = new CancellationTokenSource();
        this._registrations = [];
        if (!utils_1.isIterable(iterable, /*optional*/ true))
            throw new TypeError("Object not iterable: iterable.");
        if (iterable) {
            for (const token of iterable) {
                this.add(token);
            }
        }
        this._canBeSignaled = true;
        this._checkSignalState();
    }
    /**
     * Gets the number of tokens added to the countdown.
     */
    get addedCount() { return this._addedCount; }
    /**
     * Gets the number of tokens that have not yet been canceled.
     */
    get remainingCount() { return this._addedCount - this._signaledCount; }
    /**
     * Gets the CancellationToken for the countdown.
     */
    get token() { return this._source.token; }
    /**
     * Adds a CancellationToken to the countdown.
     */
    add(token) {
        if (!cancelable_1.Cancelable.hasInstance(token))
            throw new TypeError("CancellationToken or Cancelable expected.");
        const ct = CancellationToken.from(token);
        if (this._source._currentState !== "open")
            return this;
        if (ct.cancellationRequested) {
            this._addedCount++;
            this._signaledCount++;
            this._checkSignalState();
        }
        else if (ct.canBeCanceled) {
            this._addedCount++;
            this._registrations.push(ct.register(() => {
                this._signaledCount++;
                this._checkSignalState();
            }));
        }
        return this;
    }
    _checkSignalState() {
        if (!this._canBeSignaled || this._signaledCount < this._addedCount)
            return;
        this._canBeSignaled = false;
        if (this._addedCount > 0) {
            try {
                for (const registration of this._registrations) {
                    registration.unregister();
                }
            }
            finally {
                this._registrations.length = 0;
                this._source.cancel();
            }
        }
    }
}
exports.CancellationTokenCountdown = CancellationTokenCountdown;
