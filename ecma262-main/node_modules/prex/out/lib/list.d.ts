/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Licensed under the Apache License, Version 2.0.

See LICENSE file in the project root for details.
***************************************************************************** */
export declare class LinkedListNode<T> {
    value: T | undefined;
    constructor(value?: T);
    get list(): LinkedList<T> | undefined;
    get previous(): LinkedListNode<T> | undefined;
    get next(): LinkedListNode<T> | undefined;
}
export declare class LinkedList<T> {
    private _head;
    private _size;
    constructor(iterable?: Iterable<T>);
    get first(): LinkedListNode<T> | undefined;
    get last(): LinkedListNode<T> | undefined;
    get size(): number;
    values(): Generator<T | undefined, void, unknown>;
    nodes(): Generator<LinkedListNode<T>, void, unknown>;
    drain(): Generator<T | undefined, void, unknown>;
    find(value: T): LinkedListNode<T> | undefined;
    findLast(value: T): LinkedListNode<T> | undefined;
    has(value: T): boolean;
    insertBefore(node: LinkedListNode<T>, value: T): LinkedListNode<T>;
    insertNodeBefore(node: LinkedListNode<T>, newNode: LinkedListNode<T>): void;
    insertAfter(node: LinkedListNode<T>, value: T): LinkedListNode<T>;
    insertNodeAfter(node: LinkedListNode<T>, newNode: LinkedListNode<T>): void;
    push(value?: T): LinkedListNode<T>;
    pushNode(newNode: LinkedListNode<T>): void;
    pop(): T | undefined;
    popNode(): LinkedListNode<T> | undefined;
    shift(): T | undefined;
    shiftNode(): LinkedListNode<T> | undefined;
    unshift(value?: T): LinkedListNode<T>;
    unshiftNode(newNode: LinkedListNode<T>): void;
    delete(value: T): boolean;
    deleteNode(node: LinkedListNode<T> | undefined): boolean;
    deleteAll(predicate: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): number;
    clear(): void;
    forEach(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => void, thisArg?: any): void;
    private _deleteNode;
    private _insertNode;
}
export interface LinkedList<T> {
    [Symbol.iterator](): Iterator<T>;
}
