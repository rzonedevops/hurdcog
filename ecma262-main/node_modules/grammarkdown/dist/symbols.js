"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SymbolTable = exports.Symbol = exports.SymbolKind = void 0;
let nextSymbolId = 0;
/** {@docCategory Bind} */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["SourceFile"] = 0] = "SourceFile";
    SymbolKind[SymbolKind["Production"] = 1] = "Production";
    SymbolKind[SymbolKind["Parameter"] = 2] = "Parameter";
})(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
/** {@docCategory Bind} */
class Symbol {
    constructor(kind, name) {
        this.id = ++nextSymbolId;
        this.kind = kind;
        this.name = name;
    }
}
exports.Symbol = Symbol;
/** {@docCategory Bind} */
class SymbolTable {
    get isEmpty() { return !this.nameMap; }
    resolveSymbol(name, kind) {
        var _a;
        if (name) {
            return (_a = this.getSymbols(kind, /*create*/ false)) === null || _a === void 0 ? void 0 : _a.get(name);
        }
        return undefined;
    }
    *symbolsOfKind(kind) {
        var _a;
        const symbols = (_a = this.nameMap) === null || _a === void 0 ? void 0 : _a.get(kind);
        if (symbols) {
            yield* symbols.values();
        }
    }
    /* @internal */
    copyFrom(other) {
        var _a;
        if (other === this || !other.nameMap)
            return;
        for (const [kind, otherSymbols] of other.nameMap) {
            (_a = this.nameMap) !== null && _a !== void 0 ? _a : (this.nameMap = new Map());
            let symbols = this.nameMap.get(kind);
            if (!symbols)
                this.nameMap.set(kind, symbols = new Map());
            for (const [name, symbol] of otherSymbols) {
                symbols.set(name, symbol);
            }
        }
    }
    /* @internal */
    declareSymbol(name, kind, parent) {
        let symbol;
        if (name) {
            const symbols = this.getSymbols(kind, /*create*/ true);
            symbol = symbols.get(name);
            if (!symbol) {
                symbol = new Symbol(kind, name);
                symbols.set(name, symbol);
            }
        }
        else {
            symbol = new Symbol(kind, "*missing*");
        }
        symbol.parent = parent;
        return symbol;
    }
    getSymbols(kind, create) {
        var _a, _b;
        let symbols = (_a = this.nameMap) === null || _a === void 0 ? void 0 : _a.get(kind);
        if (!symbols && create)
            ((_b = this.nameMap) !== null && _b !== void 0 ? _b : (this.nameMap = new Map())).set(kind, symbols = new Map());
        return symbols;
    }
}
exports.SymbolTable = SymbolTable;
//# sourceMappingURL=symbols.js.map