/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
import { Cancelable } from "@esfx/cancelable";
import { Range } from "./types";
import { SourceFile } from "./nodes";
/** {@docCategory Other} */
export interface TextChange {
    range: Range;
    text: string;
}
/** {@docCategory Other} */
export declare namespace TextChange {
    function create(text: string, range: Range): {
        text: string;
        range: Range;
    };
    function clone(change: TextChange): {
        text: string;
        range: Range;
    };
    function isUnchanged(change: TextChange): boolean;
    function applyChange(originalText: string, change: TextChange): string;
}
/** {@docCategory Parse} */
export declare class Parser {
    private scanner;
    private imports;
    private diagnostics;
    private parsingContext;
    private cancelToken?;
    private trivia;
    parseSourceFile(filename: string, text: string, cancelable?: Cancelable): SourceFile;
    private parse;
    private nextToken;
    private lookahead;
    private speculate;
    private isEOF;
    private skipUntil;
    private readTokenValue;
    private readTokenText;
    private finishNode;
    private parseToken;
    private parseAnyToken;
    private parseOptional;
    private isStartOfListElement;
    private parseElement;
    private recover;
    private reportDiagnostics;
    private tryStopParsingList;
    private tryMoveToNextElement;
    private parseList;
    private canBeIdentifier;
    private parseIdentifier;
    private parseUnicodeCharacterLiteral;
    private parseProse;
    private isStartOfParameter;
    private parseParameter;
    private parseParameterListTail;
    private tryParseParameterList;
    private parseOneOfList;
    private parseSymbolSetTail;
    private parseSymbolSpanRestOrSymbolSet;
    private parseEmptyAssertionTail;
    private parseLookaheadAssertionTail;
    private parseNoSymbolHereAssertionTail;
    private parseLexicalGoalAssertionTail;
    private parseInvalidAssertionTail;
    private parseAssertion;
    private parseProseAssertion;
    private parseProseFragments;
    private parseProseFragmentLiteral;
    private parseTerminalLiteral;
    private parseTerminal;
    private isStartOfArgument;
    private parseArgument;
    private parseArgumentListTail;
    private tryParseArgumentList;
    private isStartOfArgumentList;
    private nextTokenIsArgument;
    private isStartOfConstraint;
    private parseConstraint;
    private parseNonterminal;
    private parseOneOfSymbol;
    private parsePlaceholderSymbol;
    private parseInvalidSymbol;
    private parseUnicodeCharacterRangeOrHigher;
    private parseUnicodeCharacterRangeTail;
    private parsePrimarySymbol;
    private parseUnarySymbol;
    private parseButNotSymbolTail;
    private parseSymbol;
    private tryParseSymbolSpan;
    private parseSymbolSpanRest;
    private parseSymbolSpan;
    private isStartOfSymbolSpanOnSameLine;
    private isStartOfSymbolSpan;
    private isStartOfRightHandSide;
    private parseLinkReference;
    private nextTokenIsConstraintOperatorToken;
    private tryParseConstraints;
    private parseRightHandSide;
    private parseRightHandSideList;
    private parseBody;
    private parseProduction;
    private parseStringLiteral;
    private parseNumberLiteral;
    private parseMetaElement;
    private parseImport;
    private parseDefine;
    private parseLine;
    private isStartOfSourceElement;
    private parseSourceElement;
    private parseSourceElementList;
}
