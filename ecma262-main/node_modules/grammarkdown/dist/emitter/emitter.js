"use strict";
/*!
* Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
*
* This file is licensed to you under the terms of the MIT License, found in the LICENSE file
* in the root of this repository or package.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Emitter = void 0;
const path = require("path");
const performance = require("../performance");
const diagnostics_1 = require("../diagnostics");
const options_1 = require("../options");
const stringwriter_1 = require("../stringwriter");
const tokens_1 = require("../tokens");
const core_1 = require("../core");
/** {@docCategory Emit} */
class Emitter {
    constructor(options) {
        this.options = options;
    }
    get sourceFile() {
        return this._sourceFile;
    }
    emit(node, resolver, diagnostics, writeFile, cancelable) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        const file = this.getOutputFilename(node);
        const text = this.emitString(node, resolver, diagnostics, cancelToken);
        return Promise.resolve(writeFile(file, text, cancelToken));
    }
    emitString(sourceFile, resolver, diagnostics, cancelable, node = sourceFile) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        performance.mark("beforeEmit");
        const saveWriter = this.writer;
        const saveResolver = this.resolver;
        const saveDiagnostics = this._diagnostics;
        const saveSourceFile = this._sourceFile;
        const saveTriviaPos = this._triviaPos;
        const saveCancellationToken = this._cancelToken;
        let text;
        try {
            this._cancelToken = cancelToken;
            this.resolver = resolver;
            this._diagnostics = new diagnostics_1.DiagnosticMessages();
            this.writer = this.createWriter(this.options);
            this._sourceFile = sourceFile;
            this._triviaPos = 0;
            this.emitNode(node);
            text = this.writer.toString();
            diagnostics.copyFrom(this._diagnostics);
        }
        finally {
            this.writer = saveWriter;
            this.resolver = saveResolver;
            this._diagnostics = saveDiagnostics;
            this._sourceFile = saveSourceFile;
            this._triviaPos = saveTriviaPos;
            this._cancelToken = saveCancellationToken;
        }
        performance.mark("afterEmit");
        performance.measure("emit", "beforeEmit", "afterEmit");
        return text;
    }
    getOutputFilename(node) {
        const extension = this.extension || ".out";
        if (this.options.out) {
            return this.options.out;
        }
        else {
            const dirname = path.dirname(node.filename);
            const basename = path.basename(node.filename, ".grammar");
            return path.join(dirname, basename + extension);
        }
    }
    createWriter(options) {
        return new stringwriter_1.StringWriter(options.newLine === options_1.NewLineKind.LineFeed ? "\n" :
            options.newLine === options_1.NewLineKind.CarriageReturnLineFeed ? "\r\n" :
                undefined);
    }
    beforeEmitNode(node) {
        this.emitDetachedTriviaOfNode(node);
        this.emitLeadingTriviaOfNode(node);
    }
    afterEmitNode(node) {
        this.emitTrailingTriviaOfNode(node);
    }
    emitNode(node) {
        if (!node) {
            return;
        }
        this.beforeEmitNode(node);
        this.emitNodeCore(node);
        this.afterEmitNode(node);
    }
    emitNodeCore(node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.SourceFile:
                this.emitSourceFile(node);
                break;
            case tokens_1.SyntaxKind.TerminalLiteral:
                this.emitTerminalLiteral(node);
                break;
            case tokens_1.SyntaxKind.StringLiteral:
                this.emitStringLiteral(node);
                break;
            case tokens_1.SyntaxKind.NumberLiteral:
                this.emitNumberLiteral(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.emitUnicodeCharacterLiteral(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.emitUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.Prose:
                this.emitProse(node);
                break;
            case tokens_1.SyntaxKind.Identifier:
                this.emitIdentifier(node);
                break;
            case tokens_1.SyntaxKind.Parameter:
                this.emitParameter(node);
                break;
            case tokens_1.SyntaxKind.ParameterList:
                this.emitParameterList(node);
                break;
            case tokens_1.SyntaxKind.Argument:
                this.emitArgument(node);
                break;
            case tokens_1.SyntaxKind.ArgumentList:
                this.emitArgumentList(node);
                break;
            case tokens_1.SyntaxKind.Production:
                this.emitProduction(node);
                break;
            case tokens_1.SyntaxKind.Import:
                this.emitImport(node);
                break;
            case tokens_1.SyntaxKind.Define:
                this.emitDefine(node);
                break;
            case tokens_1.SyntaxKind.Line:
                this.emitLine(node);
                break;
            case tokens_1.SyntaxKind.OneOfList:
                this.emitOneOfList(node);
                break;
            case tokens_1.SyntaxKind.RightHandSideList:
                this.emitRightHandSideList(node);
                break;
            case tokens_1.SyntaxKind.RightHandSide:
                this.emitRightHandSide(node);
                break;
            case tokens_1.SyntaxKind.LinkReference:
                this.emitLinkReference(node);
                break;
            case tokens_1.SyntaxKind.Constraints:
                this.emitConstraints(node);
                break;
            case tokens_1.SyntaxKind.SymbolSpan:
                this.emitSymbolSpan(node);
                break;
            case tokens_1.SyntaxKind.ThroughKeyword:
                this.emitKeyword(node);
                break;
            case tokens_1.SyntaxKind.ButNotSymbol:
                this.emitButNotSymbol(node);
                break;
            case tokens_1.SyntaxKind.OneOfSymbol:
                this.emitOneOfSymbol(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.emitNonterminal(node);
                break;
            case tokens_1.SyntaxKind.Terminal:
                this.emitTerminal(node);
                break;
            case tokens_1.SyntaxKind.SymbolSet:
                this.emitSymbolSet(node);
                break;
            case tokens_1.SyntaxKind.PlaceholderSymbol:
                this.emitPlaceholder(node);
                break;
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.emitEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.emitLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.emitLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.emitNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseAssertion:
                this.emitProseAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseFull:
                this.emitProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseHead:
                this.emitProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseMiddle:
                this.emitProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseTail:
                this.emitProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.HtmlOpenTagTrivia:
            case tokens_1.SyntaxKind.HtmlCloseTagTrivia:
            case tokens_1.SyntaxKind.HtmlCommentTrivia:
            case tokens_1.SyntaxKind.SingleLineCommentTrivia:
            case tokens_1.SyntaxKind.MultiLineCommentTrivia:
                return this.emitTrivia(node);
            default:
                if ((0, tokens_1.isTokenKind)(node.kind)) {
                    this.emitToken(node);
                }
                break;
        }
    }
    emitChildren(node) {
        this.emitNodes(node.children());
    }
    emitNodes(nodes) {
        for (const node of nodes) {
            this.emitNode(node);
        }
    }
    emitSourceFile(node) {
        this.emitChildren(node);
    }
    emitKeyword(node) {
        this.emitToken(node);
    }
    emitToken(node) {
        if (node) {
            this.emitTokenKind(node.kind);
        }
    }
    emitTokenKind(kind) {
        this.writer.write((0, tokens_1.tokenToString)(kind));
    }
    emitStringLiteral(node) {
    }
    emitNumberLiteral(node) {
    }
    emitPlaceholder(node) {
        this.emitToken(node.placeholderToken);
    }
    emitTerminalLiteral(node) {
        this.emitTextContent(node);
    }
    emitUnicodeCharacterLiteral(node) {
        this.emitTextContent(node);
    }
    emitTextContent(node) {
        this.writer.write(node.text);
    }
    emitProse(node) {
        this.emitChildren(node);
    }
    emitIdentifier(node) {
        this.emitTextContent(node);
    }
    emitParameter(node) {
        this.emitChildren(node);
    }
    emitParameterList(node) {
        this.emitChildren(node);
    }
    emitArgument(node) {
        this.emitChildren(node);
    }
    emitArgumentList(node) {
        this.emitChildren(node);
    }
    emitProduction(node) {
        this.emitChildren(node);
    }
    emitImport(node) {
    }
    emitDefine(node) {
    }
    emitLine(node) {
    }
    emitOneOfList(node) {
        this.emitChildren(node);
    }
    emitRightHandSideList(node) {
        this.emitChildren(node);
    }
    emitRightHandSide(node) {
        this.emitChildren(node);
    }
    emitLinkReference(node) {
    }
    emitSymbolSpan(node) {
        this.emitChildren(node);
    }
    emitUnicodeCharacterRange(node) {
        this.emitChildren(node);
    }
    emitButNotSymbol(node) {
        this.emitChildren(node);
    }
    emitOneOfSymbol(node) {
        this.emitChildren(node);
    }
    emitNonterminal(node) {
        this.emitChildren(node);
    }
    emitTerminal(node) {
        this.emitNode(node.literal);
        this.emitNode(node.questionToken);
    }
    emitSymbolSet(node) {
        this.emitChildren(node);
    }
    emitEmptyAssertion(node) {
    }
    emitLookaheadAssertion(node) {
        this.emitChildren(node);
    }
    emitLexicalGoalAssertion(node) {
        this.emitChildren(node);
    }
    emitNoSymbolHereAssertion(node) {
        this.emitChildren(node);
    }
    emitConstraints(node) {
        this.emitChildren(node);
    }
    emitProseAssertion(node) {
        this.emitChildren(node);
    }
    emitProseFragmentLiteral(node) {
        this.emitTextContent(node);
    }
    encode(text) {
        return text.replace(/&(?!(?:#(?:[xX][a-fA-F\d]+|\d+)|[a-zA-Z\d]+);)|[<>'"]/g, ch => {
            switch (ch) {
                case "&": return "&amp;";
                case "<": return "&lt;";
                case ">": return "&gt;";
                case "'": return "&apos;";
                case '"': return "&quot;";
                default: return ch;
            }
        });
    }
    emitDetachedTriviaOfNode(node) {
        this.emitTriviaNodes(node.detachedTrivia);
    }
    emitLeadingTriviaOfNode(node) {
        this.emitTriviaNodes(node.leadingTrivia);
    }
    emitTrailingTriviaOfNode(node) {
        this.emitTriviaNodes(node.trailingTrivia);
    }
    emitTriviaNodes(nodes) {
        if (nodes) {
            for (const node of nodes) {
                this.emitTrivia(node);
            }
        }
    }
    emitTrivia(node) {
        this.beforeEmitTrivia(node);
        this.emitTriviaCore(node);
        this.afterEmitTrivia(node);
    }
    beforeEmitTrivia(node) { }
    afterEmitTrivia(node) { }
    emitTriviaCore(node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.HtmlOpenTagTrivia:
                this.emitHtmlOpenTagTrivia(node);
                break;
            case tokens_1.SyntaxKind.HtmlCloseTagTrivia:
                this.emitHtmlCloseTagTrivia(node);
                break;
            case tokens_1.SyntaxKind.HtmlCommentTrivia:
                this.emitHtmlCommentTrivia(node);
                break;
            case tokens_1.SyntaxKind.SingleLineCommentTrivia:
                this.emitSingleLineCommentTrivia(node);
                break;
            case tokens_1.SyntaxKind.MultiLineCommentTrivia:
                this.emitMultiLineCommentTrivia(node);
                break;
        }
    }
    emitHtmlOpenTagTrivia(node) {
        this.emitTextRange(node);
    }
    emitHtmlCloseTagTrivia(node) {
        this.emitTextRange(node);
    }
    emitHtmlCommentTrivia(node) {
        this.emitTextRange(node);
    }
    emitSingleLineCommentTrivia(node) {
    }
    emitMultiLineCommentTrivia(node) {
    }
    emitTextRange(range) {
        this.writer.write(this._sourceFile.text.substring(range.pos, range.end));
    }
}
exports.Emitter = Emitter;
//# sourceMappingURL=emitter.js.map