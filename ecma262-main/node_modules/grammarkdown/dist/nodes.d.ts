/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
import { LineMap } from "./diagnostics";
import { ArgumentOperatorKind, AssertionKind, BooleanKind, CommentTriviaKind, HtmlTagTriviaKind, HtmlTriviaKind, LexicalSymbolKind, LookaheadOperatorKind, MetaElementKind, OptionalSymbolKind, PrimarySymbolKind, ProductionBodyKind, ProductionSeperatorKind, ProseFragmentLiteralKind, SourceElementKind, SyntaxKind, TokenKind, TriviaKind } from "./tokens";
import { TextRange } from "./types";
import { NodeVisitor } from "./visitor";
/** {@docCategory Nodes} */
export interface TextContent {
    readonly text: string | undefined;
}
/** {@docCategory Nodes} */
export declare abstract class Node<TKind extends SyntaxKind = SyntaxKind> implements TextRange {
    readonly kind: TKind;
    private _pos;
    private _end;
    private _leadingTrivia;
    private _trailingTrivia;
    private _detachedTrivia;
    private _leadingHtmlTrivia;
    private _trailingHtmlTrivia;
    constructor(kind: TKind);
    get pos(): number;
    get end(): number;
    /**
     * Leading trivia is trivia that belongs to the beginning of the node:
     * - An HTML close tag trivia, or any trivia preceding an HTML close tag trivia, is not leading trivia of the node.
     * - An HTML open tag trivia, and any trivia following an HTML open tag trivia, is leading trivia of the node.
     * - If the node has a preceding line break, then
     *   - Any other non-HTML tag trivia on the same line as the node that precedes the node is leading trivia of the node.
     *   - Any other non-HTML tag trivia on a line that precedes the node, but not preceding a blank line, is leading trivia of the node.
     * - Otherwise,
     *   - Any other non-HTML tag trivia on the same line as the node that precedes the node is leading trivia, if there is no whitespace between
     *     that trivia and the node.
     */
    get leadingTrivia(): readonly Trivia[] | undefined;
    /**
     * Trailing trivia is trivia that belongs to the end of the node:
     * - An HTML open tag trivia, or any trivia following an HTML open tag trivia, is not trailing trivia of the node.
     * - An HTML close tag trivia, and any trivia preceding an HTML close tag trivia, is trailing trivia of the node.
     * - If the node has a trailing line break, then
     *   - Any other non-HTML tag trivia on the same line as the node that follows the node is trailing trivia of the node.
     *   - Any other non-HTML tag trivia on a line that follows the node, but not following a blank line, is trailing trivia of the node.
     * - Otherwise,
     *   - Any other non-HTML tag trivia on the same line as the node that follows the node is trailing trivia, if there is no whitespace between
     *     that trivia and the node.
     */
    get trailingTrivia(): readonly Trivia[] | undefined;
    /**
     * Detached trivia is any trivia that occurs prior to the node that is not the leading or trailing trivia of this
     * or any other node.
     */
    get detachedTrivia(): readonly Trivia[] | undefined;
    /** @deprecated Use {@link leadingTrivia} or {@link detachedTrivia} instead. */
    get leadingHtmlTrivia(): readonly HtmlTrivia[] | undefined;
    /** @deprecated Use {@link trailingTrivia} instead. */
    get trailingHtmlTrivia(): readonly HtmlTrivia[] | undefined;
    getStart(sourceFile?: SourceFile): number;
    getEnd(): number;
    getWidth(sourceFile?: SourceFile): number;
    getFullStart(): number;
    getFullWidth(): number;
    getText(sourceFile: SourceFile): string;
    getFullText(sourceFile: SourceFile): string;
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Node;
}
/** {@docCategory Nodes} */
export declare abstract class TriviaBase<TKind extends TriviaKind> extends Node<TKind> {
    private _hasPrecedingLineTerminator;
    private _hasPrecedingBlankLine;
    private _hasPrecedingWhiteSpace;
    private _hasFollowingLineTerminator;
    private _hasFollowingBlankLine;
    private _hasFollowingWhiteSpace;
    get hasPrecedingLineTerminator(): boolean;
    get hasPrecedingBlankLine(): boolean;
    get hasPrecedingWhiteSpace(): boolean;
    get hasFollowingLineTerminator(): boolean;
    get hasFollowingBlankLine(): boolean;
    get hasFollowingWhiteSpace(): boolean;
}
/** {@docCategory Nodes} */
export declare type Trivia = CommentTrivia | HtmlTrivia;
/** {@docCategory Nodes} */
export declare abstract class CommentTriviaBase<TKind extends CommentTriviaKind> extends TriviaBase<TKind> {
}
/** {@docCategory Nodes} */
export declare type CommentTrivia = SingleLineCommentTrivia | MultiLineCommentTrivia;
/**
 * Represent a single-line comment trivia token.
 * ```grammarkdown
 * // comment
 * ```
 * {@docCategory Nodes}
 */
export declare class SingleLineCommentTrivia extends CommentTriviaBase<SyntaxKind.SingleLineCommentTrivia> {
    constructor();
}
/**
 * Represents a multi-line comment trivia token.
 * {@docCategory Nodes}
 */
export declare class MultiLineCommentTrivia extends CommentTriviaBase<SyntaxKind.MultiLineCommentTrivia> {
    constructor();
}
/** {@docCategory Nodes} */
export declare abstract class HtmlTriviaBase<TKind extends HtmlTriviaKind> extends TriviaBase<TKind> {
}
/** {@docCategory Nodes} */
export declare type HtmlTrivia = HtmlCommentTrivia | HtmlOpenTagTrivia | HtmlCloseTagTrivia;
/**
 * Represents an HTML comment trivia token:
 * ```grammarkdown
 * Production ::
 *   <!--before-->Nonterminal
 * ```
 * {@docCategory Nodes}
 */
export declare class HtmlCommentTrivia extends HtmlTriviaBase<SyntaxKind.HtmlCommentTrivia> {
    constructor();
}
/** {@docCategory Nodes} */
export declare abstract class HtmlTagTriviaBase<TKind extends HtmlTagTriviaKind> extends HtmlTriviaBase<TKind> {
    readonly tagName: string;
    constructor(kind: TKind, tagName: string);
}
/**
 * Represents an HTML open-tag trivia token:
 * ```grammarkdown
 * Production ::
 *   <ins>Inserted</ins>
 *   <del>Deleted</del>
 * ```
 * {@docCategory Nodes}
 */
export declare class HtmlOpenTagTrivia extends HtmlTagTriviaBase<SyntaxKind.HtmlOpenTagTrivia> {
    constructor(tagName: string);
}
/**
 * Represents an HTML close-tag trivia token:
 * ```grammarkdown
 * Production ::
 *   <ins>Inserted</ins>
 *   <del>Deleted</del>
 * ```
 * {@docCategory Nodes}
 */
export declare class HtmlCloseTagTrivia extends HtmlTagTriviaBase<SyntaxKind.HtmlCloseTagTrivia> {
    constructor(tagName: string);
}
/**
 * Represents a token such as a keyword or operator.
 * {@docCategory Nodes}
 */
export declare class Token<TKind extends TokenKind = TokenKind> extends Node<TKind> {
    protected accept(visitor: NodeVisitor): Token<TKind>;
}
/**
 * Represents a single- or double-quoted string literal (used by `@import` and `@line`)
 * ```grammarkdown
 * @import "file"
 * ```
 * {@docCategory Nodes}
 */
export declare class StringLiteral extends Node<SyntaxKind.StringLiteral> implements TextContent {
    readonly text: string | undefined;
    constructor(text: string | undefined);
    protected accept(visitor: NodeVisitor): StringLiteral;
}
/**
 * Represents a number literal (used by `@line`)
 * ```grammarkdown
 * @line 500
 * Production :: Nonterminal
 * ```
 * {@docCategory Nodes}
 */
export declare class NumberLiteral extends Node<SyntaxKind.NumberLiteral> implements TextContent {
    readonly text: string | undefined;
    constructor(text: string | undefined);
    protected accept(visitor: NodeVisitor): NumberLiteral;
}
/**
 * Represents a Unicode character literal in one of two forms:
 * ```grammarkdown
 * <TAB>
 * U+0000
 * ```
 * {@docCategory Nodes}
 */
export declare class UnicodeCharacterLiteral extends Node<SyntaxKind.UnicodeCharacterLiteral> implements TextContent {
    readonly text: string | undefined;
    constructor(text: string | undefined);
    protected accept(visitor: NodeVisitor): UnicodeCharacterLiteral;
}
/**
 * Represents a terminal token in the grammar.
 * ```grammarkdown
 * `yield`
 * ```
 * {@docCategory Nodes}
 */
export declare class TerminalLiteral extends Node<SyntaxKind.TerminalLiteral> implements TextContent {
    readonly text: string | undefined;
    constructor(text: string | undefined);
    protected accept(visitor: NodeVisitor): TerminalLiteral;
}
/**
 * Represents an identifier such as a Production or Parameter.
 * {@docCategory Nodes}
 */
export declare class Identifier extends Node<SyntaxKind.Identifier> implements TextContent {
    readonly text: string | undefined;
    constructor(text: string | undefined);
    protected accept(visitor: NodeVisitor): Identifier;
}
/** {@docCategory Nodes} */
export declare type TextContentNode = StringLiteral | NumberLiteral | Identifier | UnicodeCharacterLiteral | TerminalLiteral | ProseFragmentLiteral<ProseFragmentLiteralKind>;
/**
 * Represents a set of symbols in a `lookahead` assertion.
 * ```grammarkdown
 * [lookahead ∈ { `a`, `b` }]
 * ```
 * {@docCategory Nodes}
 */
export declare class SymbolSet extends Node<SyntaxKind.SymbolSet> {
    readonly openBraceToken: Token<SyntaxKind.OpenBraceToken>;
    readonly elements: ReadonlyArray<SymbolSpan> | undefined;
    readonly closeBraceToken: Token<SyntaxKind.CloseBraceToken> | undefined;
    constructor(openBraceToken: Token<SyntaxKind.OpenBraceToken>, elements: ReadonlyArray<SymbolSpan> | undefined, closeBraceToken: Token<SyntaxKind.CloseBraceToken> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(elements: ReadonlyArray<SymbolSpan> | undefined): SymbolSet;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): SymbolSet;
}
/**
 * Represents a set of constraints for a right-hand-side of a Production.
 * ```grammarkdown
 * Production[A] ::
 *   [+A] A
 *   [~A] B
 * ```
 * {@docCategory Nodes}
 */
export declare class Constraints extends Node<SyntaxKind.Constraints> {
    readonly openBracketToken: Token<SyntaxKind.OpenBracketToken>;
    readonly elements: ReadonlyArray<Argument> | undefined;
    readonly closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined;
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, elements: ReadonlyArray<Argument> | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(elements: ReadonlyArray<Argument> | undefined): Constraints;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Constraints;
}
/** {@docCategory Nodes} */
export declare abstract class LexicalSymbolBase<TKind extends LexicalSymbolKind> extends Node<TKind> {
}
/**
 * Represents a placeholder symbol (`@`) used in some grammars.
 * {@docCategory Nodes}
 */
export declare class PlaceholderSymbol extends LexicalSymbolBase<SyntaxKind.PlaceholderSymbol> {
    readonly placeholderToken: Token<SyntaxKind.AtToken>;
    constructor(placeholderToken: Token<SyntaxKind.AtToken>);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): PlaceholderSymbol;
}
/**
 * Represents a range of unicode characters.
 * ```grammarkdown
 * U+0000 through U+001F
 * ```
 * {@docCategory Nodes}
 */
export declare class UnicodeCharacterRange extends LexicalSymbolBase<SyntaxKind.UnicodeCharacterRange> {
    readonly left: UnicodeCharacterLiteral;
    readonly throughKeyword: Token<SyntaxKind.ThroughKeyword>;
    readonly right: UnicodeCharacterLiteral;
    constructor(left: UnicodeCharacterLiteral, throughKeyword: Token<SyntaxKind.ThroughKeyword>, right: UnicodeCharacterLiteral);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(left: UnicodeCharacterLiteral, right: UnicodeCharacterLiteral): UnicodeCharacterRange;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): UnicodeCharacterRange;
}
/**
 * The \`but not\` operator allows you to reference a *Nonterminal* on the left, excluding some part of that production.
 * ```grammarkdown
 * A but not B
 * ```
 * {@docCategory Nodes}
 */
export declare class ButNotSymbol extends LexicalSymbolBase<SyntaxKind.ButNotSymbol> {
    readonly left: LexicalSymbol;
    readonly butKeyword: Token<SyntaxKind.ButKeyword> | undefined;
    readonly notKeyword: Token<SyntaxKind.NotKeyword> | undefined;
    readonly right: LexicalSymbol | undefined;
    constructor(left: LexicalSymbol, butKeyword: Token<SyntaxKind.ButKeyword> | undefined, notKeyword: Token<SyntaxKind.NotKeyword> | undefined, right: LexicalSymbol | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(left: LexicalSymbol, right: LexicalSymbol | undefined): ButNotSymbol;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): ButNotSymbol;
}
/**
 * Represents a section of Prose, which indicates handling of syntax outside the scope of the Grammarkdown parser.
 * ```grammarkdown
 * > This is a section of Prose with |Nonterminals| and `terminals`
 * ```
 * {@docCategory Nodes}
 */
export declare class Prose extends LexicalSymbolBase<SyntaxKind.Prose> {
    readonly greaterThanToken: Token<SyntaxKind.GreaterThanToken>;
    readonly fragments: ReadonlyArray<ProseFragment> | undefined;
    constructor(greaterThanToken: Token<SyntaxKind.GreaterThanToken>, fragments: ReadonlyArray<ProseFragment> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(fragments: ReadonlyArray<ProseFragment> | undefined): Prose;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Prose;
}
/**
 * Represents a set of symbols used to restrict a `but not` operator.
 * ```grammarkdown
 * A but not one of `a` or `b`
 * ```
 * {@docCategory Nodes}
 */
export declare class OneOfSymbol extends LexicalSymbolBase<SyntaxKind.OneOfSymbol> {
    readonly oneKeyword: Token<SyntaxKind.OneKeyword>;
    readonly ofKeyword: Token<SyntaxKind.OfKeyword> | undefined;
    readonly symbols: ReadonlyArray<LexicalSymbol> | undefined;
    constructor(oneKeyword: Token<SyntaxKind.OneKeyword>, ofKeyword: Token<SyntaxKind.OfKeyword> | undefined, symbols: ReadonlyArray<LexicalSymbol> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(symbols: ReadonlyArray<LexicalSymbol> | undefined): OneOfSymbol;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): OneOfSymbol;
}
/** {@docCategory Nodes} */
export declare class InvalidSymbol extends LexicalSymbolBase<SyntaxKind.InvalidSymbol> {
    constructor();
    protected accept(visitor: NodeVisitor): InvalidSymbol;
}
/** {@docCategory Nodes} */
export declare type LexicalSymbol = PrimarySymbol | Assertion | PlaceholderSymbol | UnicodeCharacterRange | ButNotSymbol | Prose | OneOfSymbol | InvalidSymbol;
/** {@docCategory Nodes} */
export declare abstract class PrimarySymbolBase<TKind extends PrimarySymbolKind> extends LexicalSymbolBase<TKind> {
}
/** {@docCategory Nodes} */
export declare abstract class OptionalSymbolBase<TKind extends OptionalSymbolKind> extends PrimarySymbolBase<TKind> {
    readonly questionToken: Token<SyntaxKind.QuestionToken> | undefined;
    constructor(kind: TKind, questionToken: Token<SyntaxKind.QuestionToken> | undefined);
}
/**
 * Represents a terminal token in the grammar.
 * ```grammarkdown
 * `yield` `*`?
 * ```
 * {@docCategory Nodes}
 */
export declare class Terminal extends OptionalSymbolBase<SyntaxKind.Terminal> {
    readonly literal: UnicodeCharacterLiteral | TerminalLiteral;
    constructor(literal: UnicodeCharacterLiteral | TerminalLiteral, questionToken: Token<SyntaxKind.QuestionToken> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(literal: UnicodeCharacterLiteral | TerminalLiteral, questionToken: Token<SyntaxKind.QuestionToken> | undefined): Terminal;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Terminal;
}
/**
 * Represents a non-terminal reference to another Production.
 * ```grammarkdown
 * IdentifierReference[~Yield, ~Await]
 * ```
 * {@docCategory Nodes}
 */
export declare class Nonterminal extends OptionalSymbolBase<SyntaxKind.Nonterminal> {
    readonly name: Identifier;
    readonly argumentList: ArgumentList | undefined;
    constructor(name: Identifier, argumentList: ArgumentList | undefined, questionToken: Token<SyntaxKind.QuestionToken> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(name: Identifier, argumentList: ArgumentList | undefined): Nonterminal;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Nonterminal;
}
/** {@docCategory Nodes} */
export declare type OptionalSymbol = Terminal | Nonterminal;
/** {@docCategory Nodes} */
export declare type PrimarySymbol = OptionalSymbol;
/** {@docCategory Nodes} */
export declare abstract class AssertionBase<TKind extends AssertionKind, TBracket extends SyntaxKind.OpenBracketToken | SyntaxKind.OpenBracketGreaterThanToken> extends LexicalSymbolBase<TKind> {
    readonly openBracketToken: Token<TBracket>;
    readonly closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined;
    constructor(kind: TKind, openBracketToken: Token<TBracket>, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get firstChild(): Node | undefined;
    abstract get lastChild(): Node | undefined;
}
/**
 * Represents the `empty` assertion, which matches exactly zero tokens.
 * ```grammarkdown
 * [empty]
 * ```
 * {@docCategory Nodes}
 */
export declare class EmptyAssertion extends AssertionBase<SyntaxKind.EmptyAssertion, SyntaxKind.OpenBracketToken> {
    readonly emptyKeyword: Token<SyntaxKind.EmptyKeyword>;
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, emptyKeyword: Token<SyntaxKind.EmptyKeyword>, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): EmptyAssertion;
}
/**
 * Represents a `lookahead` assertion, which is a zero-width assertion that only matches if the next token is in the requested set.
 * ```grammarkdown
 * [lookahead ∉ { `class`, `let` }]
 * ```
 * {@docCategory Nodes}
 */
export declare class LookaheadAssertion extends AssertionBase<SyntaxKind.LookaheadAssertion, SyntaxKind.OpenBracketToken> {
    readonly lookaheadKeyword: Token<SyntaxKind.LookaheadKeyword>;
    readonly operatorToken: Token<LookaheadOperatorKind> | undefined;
    readonly lookahead: SymbolSpan | SymbolSet | undefined;
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, lookaheadKeyword: Token<SyntaxKind.LookaheadKeyword>, operatorToken: Token<LookaheadOperatorKind> | undefined, lookahead: SymbolSpan | SymbolSet | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(lookahead: SymbolSpan | SymbolSet | undefined): LookaheadAssertion;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): LookaheadAssertion;
}
/**
 * Represens a `lexical-goal` assertion which verifies that current lexical goal is the supplied *Nonterminal*.
 * ```grammarkdown
 * [lexical goal Module]
 * ```
 * {@docCategory Nodes}
 */
export declare class LexicalGoalAssertion extends AssertionBase<SyntaxKind.LexicalGoalAssertion, SyntaxKind.OpenBracketToken> {
    readonly lexicalKeyword: Token<SyntaxKind.LexicalKeyword>;
    readonly goalKeyword: Token<SyntaxKind.GoalKeyword> | undefined;
    readonly symbol: Identifier | undefined;
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, lexicalKeyword: Token<SyntaxKind.LexicalKeyword>, goalKeyword: Token<SyntaxKind.GoalKeyword> | undefined, symbol: Identifier | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(symbol: Identifier | undefined): LexicalGoalAssertion;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): LexicalGoalAssertion;
}
/**
 * Represents a `no Symbol here` assertion, which disallows the provided symbol.
 * ```grammarkdown
 * [no LineTerminator here]
 * ```
 * {@docCategory Nodes}
 */
export declare class NoSymbolHereAssertion extends AssertionBase<SyntaxKind.NoSymbolHereAssertion, SyntaxKind.OpenBracketToken> {
    readonly noKeyword: Token<SyntaxKind.NoKeyword>;
    readonly symbols: ReadonlyArray<PrimarySymbol> | undefined;
    readonly hereKeyword: Token<SyntaxKind.HereKeyword> | undefined;
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, noKeyword: Token<SyntaxKind.NoKeyword>, symbols: ReadonlyArray<PrimarySymbol> | undefined, hereKeyword: Token<SyntaxKind.HereKeyword> | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(symbols: ReadonlyArray<PrimarySymbol> | undefined): NoSymbolHereAssertion;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): NoSymbolHereAssertion;
}
/**
 * Represents an assertion containing Prose, which indicates handling of syntax outside the scope of the Grammarkdown parser.
 * ```grammarkdown
 * HexDigits [> but only if MV of |HexDigits| > 0x10FFFF]
 * ```
 * {@docCategory Nodes}
 */
export declare class ProseAssertion extends AssertionBase<SyntaxKind.ProseAssertion, SyntaxKind.OpenBracketGreaterThanToken> {
    readonly fragments: ReadonlyArray<ProseFragment> | undefined;
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketGreaterThanToken>, fragments: ReadonlyArray<ProseFragment> | undefined, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(fragments: ReadonlyArray<ProseFragment> | undefined): ProseAssertion;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): ProseAssertion;
}
/** {@docCategory Nodes} */
export declare class InvalidAssertion extends AssertionBase<SyntaxKind.InvalidAssertion, SyntaxKind.OpenBracketToken> {
    constructor(openBracketToken: Token<SyntaxKind.OpenBracketToken>, closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): InvalidAssertion;
}
/** {@docCategory Nodes} */
export declare type Assertion = EmptyAssertion | LookaheadAssertion | LexicalGoalAssertion | NoSymbolHereAssertion | ProseAssertion | InvalidAssertion;
/** {@docCategory Nodes} */
export declare class ProseFragmentLiteral<TKind extends ProseFragmentLiteralKind = ProseFragmentLiteralKind> extends Node<SyntaxKind> implements TextContent {
    readonly text: string | undefined;
    constructor(kind: SyntaxKind, text: string | undefined);
    protected get edgeCount(): number;
    protected edgeName(_offset: number): string | undefined;
    protected edgeValue(_offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): ProseFragmentLiteral<TKind>;
}
/** {@docCategory Nodes} */
export declare type ProseFragment = ProseFragmentLiteral<ProseFragmentLiteralKind> | Terminal | Nonterminal;
/** {@docCategory Nodes} */
export declare class Argument extends Node<SyntaxKind.Argument> {
    readonly operatorToken: Token<ArgumentOperatorKind> | undefined;
    readonly name: Identifier | undefined;
    constructor(operatorToken: Token<ArgumentOperatorKind> | undefined, name: Identifier | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(name: Identifier | undefined): Argument;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Argument;
}
/** {@docCategory Nodes} */
export declare class ArgumentList extends Node<SyntaxKind.ArgumentList> {
    readonly openBracketToken: Token<SyntaxKind.OpenBracketToken>;
    readonly elements: ReadonlyArray<Argument> | undefined;
    readonly closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined;
    constructor(openParenToken: Token<SyntaxKind.OpenBracketToken>, elements: ReadonlyArray<Argument> | undefined, closeParenToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(elements: ReadonlyArray<Argument> | undefined): ArgumentList;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): ArgumentList;
}
/** {@docCategory Nodes} */
export declare class SymbolSpan extends Node<SyntaxKind.SymbolSpan> {
    readonly symbol: LexicalSymbol;
    readonly next: SymbolSpan | undefined;
    constructor(symbol: LexicalSymbol, next: SymbolSpan | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(symbol: LexicalSymbol, next: SymbolSpan | undefined): SymbolSpan;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): SymbolSpan;
}
/** {@docCategory Nodes} */
export declare class LinkReference extends Node<SyntaxKind.LinkReference> {
    readonly text: string | undefined;
    constructor(text: string | undefined);
    forEachChild<T>(_cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(_offset: number): undefined;
    protected edgeValue(_offset: number): undefined;
    protected accept(visitor: NodeVisitor): LinkReference;
}
/** {@docCategory Nodes} */
export declare abstract class ProductionBodyBase<TKind extends ProductionBodyKind> extends Node<TKind> {
}
/** {@docCategory Nodes} */
export declare class RightHandSide extends ProductionBodyBase<SyntaxKind.RightHandSide> {
    readonly constraints: Constraints | undefined;
    readonly head: SymbolSpan | undefined;
    readonly reference: LinkReference | undefined;
    constructor(constraints: Constraints | undefined, head: SymbolSpan | undefined, reference: LinkReference | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(constraints: Constraints | undefined, head: SymbolSpan | undefined, reference: LinkReference | undefined): RightHandSide;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): RightHandSide;
}
/** {@docCategory Nodes} */
export declare class RightHandSideList extends ProductionBodyBase<SyntaxKind.RightHandSideList> {
    readonly elements: ReadonlyArray<RightHandSide> | undefined;
    constructor(elements: ReadonlyArray<RightHandSide> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(elements: ReadonlyArray<RightHandSide> | undefined): RightHandSideList;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): RightHandSideList;
}
/** {@docCategory Nodes} */
export declare class OneOfList extends ProductionBodyBase<SyntaxKind.OneOfList> {
    readonly oneKeyword: Token<SyntaxKind.OneKeyword>;
    readonly ofKeyword: Token<SyntaxKind.OfKeyword> | undefined;
    readonly indented: boolean;
    readonly terminals: ReadonlyArray<TerminalLiteral> | undefined;
    constructor(oneKeyword: Token<SyntaxKind.OneKeyword>, ofKeyword: Token<SyntaxKind.OfKeyword> | undefined, indented: boolean, terminals: ReadonlyArray<TerminalLiteral> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(terminals: ReadonlyArray<TerminalLiteral> | undefined): OneOfList;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): OneOfList;
}
/** {@docCategory Nodes} */
export declare type ProductionBody = OneOfList | RightHandSide | RightHandSideList;
/** {@docCategory Nodes} */
export declare class Parameter extends Node<SyntaxKind.Parameter> {
    readonly name: Identifier;
    constructor(name: Identifier);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(name: Identifier): Parameter;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Parameter;
}
/** {@docCategory Nodes} */
export declare class ParameterList extends Node<SyntaxKind.ParameterList> {
    readonly openBracketToken: Token<SyntaxKind.OpenBracketToken>;
    readonly elements: ReadonlyArray<Parameter> | undefined;
    readonly closeBracketToken: Token<SyntaxKind.CloseBracketToken> | undefined;
    constructor(openParenToken: Token<SyntaxKind.OpenBracketToken>, elements: ReadonlyArray<Parameter> | undefined, closeParenToken: Token<SyntaxKind.CloseBracketToken> | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(elements: ReadonlyArray<Parameter> | undefined): ParameterList;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): ParameterList;
}
/** {@docCategory Nodes} */
export declare abstract class SourceElementBase<TKind extends SourceElementKind> extends Node<TKind> {
}
/** {@docCategory Nodes} */
export declare class Production extends SourceElementBase<SyntaxKind.Production> {
    readonly name: Identifier;
    readonly parameterList: ParameterList | undefined;
    readonly colonToken: Token<ProductionSeperatorKind> | undefined;
    readonly body: ProductionBody | undefined;
    constructor(name: Identifier, parameterList: ParameterList | undefined, colonToken: Token<ProductionSeperatorKind> | undefined, body: ProductionBody | undefined);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(name: Identifier, parameterList: ParameterList | undefined, body: ProductionBody | undefined): Production;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Production;
}
/** {@docCategory Nodes} */
export declare abstract class MetaElementBase<TKind extends MetaElementKind> extends SourceElementBase<TKind> {
    readonly atToken: Token<SyntaxKind.AtToken>;
    constructor(kind: TKind, atToken: Token<SyntaxKind.AtToken>);
    get firstChild(): Node | undefined;
}
/** {@docCategory Nodes} */
export declare class Import extends MetaElementBase<SyntaxKind.Import> {
    readonly importKeyword: Token<SyntaxKind.ImportKeyword>;
    readonly path: StringLiteral | undefined;
    constructor(atToken: Token<SyntaxKind.AtToken>, importKeyword: Token<SyntaxKind.ImportKeyword>, path: StringLiteral | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Import;
}
/** {@docCategory Nodes} */
export declare class Define extends MetaElementBase<SyntaxKind.Define> {
    readonly defineKeyword: Token<SyntaxKind.DefineKeyword>;
    readonly key: Identifier;
    readonly valueToken: Token<BooleanKind> | Token<SyntaxKind.DefaultKeyword> | undefined;
    constructor(atToken: Token<SyntaxKind.AtToken>, defineKeyword: Token<SyntaxKind.DefineKeyword>, key: Identifier, valueToken: Token<BooleanKind> | Token<SyntaxKind.DefaultKeyword> | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Define;
}
/** {@docCategory Nodes} */
export declare class Line extends MetaElementBase<SyntaxKind.Line> {
    readonly lineKeyword: Token<SyntaxKind.LineKeyword>;
    readonly number: NumberLiteral | Token<SyntaxKind.DefaultKeyword> | undefined;
    readonly path: StringLiteral | undefined;
    constructor(atToken: Token<SyntaxKind.AtToken>, lineKeyword: Token<SyntaxKind.LineKeyword>, number: NumberLiteral | Token<SyntaxKind.DefaultKeyword> | undefined, path: StringLiteral | undefined);
    get lastChild(): Node | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): Line;
}
/** {@docCategory Nodes} */
export declare type MetaElement = Import | Define | Line;
/** {@docCategory Nodes} */
export declare type SourceElement = Production | MetaElement;
/** {@docCategory Nodes} */
export declare class SourceFile extends Node<SyntaxKind.SourceFile> {
    readonly elements: ReadonlyArray<SourceElement>;
    readonly filename: string;
    readonly text: string;
    readonly lineMap: LineMap;
    private _imports;
    private _parseDiagnostics;
    constructor(filename: string, text: string, elements: ReadonlyArray<SourceElement>);
    get firstChild(): Node | undefined;
    get lastChild(): Node | undefined;
    get imports(): readonly string[] | undefined;
    forEachChild<T>(cbNode: (node: Node) => T | undefined): T | undefined;
    children(): IterableIterator<Node>;
    update(elements: ReadonlyArray<SourceElement>): SourceFile;
    protected get edgeCount(): number;
    protected edgeName(offset: number): string | undefined;
    protected edgeValue(offset: number): Node | ReadonlyArray<Node> | undefined;
    protected accept(visitor: NodeVisitor): SourceFile;
}
/** {@docCategory Nodes} */
export declare type Declaration = SourceFile | Production | Parameter;
export declare function forEachChild<T>(node: Node | undefined, cbNode: (node: Node) => T | undefined): T | undefined;
