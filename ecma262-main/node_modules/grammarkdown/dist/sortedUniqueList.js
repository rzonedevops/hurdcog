"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortedUniqueList = void 0;
const core_1 = require("./core");
/* @internal */
class SortedUniqueList {
    constructor(relationalComparer, equalityComparer) {
        this.sortedAndUnique = true;
        this.copyOnWrite = false;
        this.unsafeArray = [];
        this.unsafeLast = undefined;
        this.relationalComparer = relationalComparer;
        this.equalityComparer = equalityComparer;
    }
    get size() {
        return this.unsafeArray.length;
    }
    get last() {
        var _a;
        this.ensureSortedAndUnique();
        return this.unsafeLast === undefined
            ? this.unsafeLast = (((_a = this.unsafeArray) === null || _a === void 0 ? void 0 : _a.length) ? this.unsafeArray[this.unsafeArray.length - 1] : undefined)
            : this.unsafeLast;
    }
    clone() {
        const copy = new SortedUniqueList(this.relationalComparer, this.equalityComparer);
        copy.sortedAndUnique = this.sortedAndUnique;
        copy.copyOnWrite = false;
        copy.unsafeArray = this.unsafeArray.slice();
        copy.unsafeLast = this.unsafeLast;
        return copy;
    }
    valueAt(index) {
        this.ensureSortedAndUnique();
        return this.unsafeArray[index];
    }
    push(...values) {
        for (const value of values) {
            if (this.sortedAndUnique) {
                const last = this.last;
                if (last === undefined || this.relationalComparer(value, last) > 0) {
                    this.unsafeAdd(value, /*sortedAndUnique*/ true);
                    continue;
                }
                if (this.equalityComparer(value, last)) {
                    continue;
                }
            }
            this.unsafeAdd(value, /*sortedAndUnique*/ false);
        }
    }
    mutate(cb) {
        if (this.copyOnWrite) {
            this.unsafeArray = this.unsafeArray.slice();
        }
        this.copyOnWrite = true;
        cb(this.unsafeArray);
        this.sortedAndUnique = false;
        this.unsafeLast = undefined;
    }
    toArray() {
        this.ensureSortedAndUnique();
        this.copyOnWrite = true;
        return this.unsafeArray;
    }
    unsafeAdd(value, sortedAndUnique) {
        if (this.copyOnWrite) {
            this.unsafeArray = this.unsafeArray.slice();
            this.copyOnWrite = false;
        }
        this.unsafeArray.push(value);
        this.unsafeLast = sortedAndUnique ? value : undefined;
        this.sortedAndUnique = sortedAndUnique;
    }
    ensureSortedAndUnique() {
        if (!this.sortedAndUnique) {
            this.unsafeArray = (0, core_1.deduplicateSorted)((0, core_1.stableSort)(this.unsafeArray, this.relationalComparer), this.equalityComparer);
            this.unsafeLast = undefined;
            this.sortedAndUnique = true;
        }
    }
}
exports.SortedUniqueList = SortedUniqueList;
//# sourceMappingURL=sortedUniqueList.js.map