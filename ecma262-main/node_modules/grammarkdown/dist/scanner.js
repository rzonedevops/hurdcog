"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeHtmlEntities = exports.scanHtmlTrivia = exports.skipTrivia = exports.isIdentifierPart = exports.isIdentifierStart = exports.isHexDigit = exports.isWhiteSpace = exports.Scanner = void 0;
const core_1 = require("./core");
const diagnostics_1 = require("./diagnostics");
const nodeInternal_1 = require("./nodeInternal");
const nodes_1 = require("./nodes");
const tokens_1 = require("./tokens");
/** {@docCategory Parse} */
class Scanner {
    constructor(filename, text, diagnostics, cancelable) {
        this.len = 0;
        this.pos = 0;
        this.startPos = 0;
        this.tokenPos = 0;
        this.token = tokens_1.SyntaxKind.Unknown;
        this.tokenValue = "";
        this.tokenFlags = 0 /* None */;
        this.insignificantIndentLength = 0;
        this.significantIndentLength = 0;
        this.currentIndentLength = 0;
        this.filename = filename;
        this.text = text;
        this.len = text.length;
        this.diagnostics = diagnostics;
        this.cancelToken = (0, core_1.toCancelToken)(cancelable);
    }
    getPos() {
        return this.pos;
    }
    getLen() {
        return this.len;
    }
    getStartPos() {
        return this.startPos;
    }
    getTokenPos() {
        return this.tokenPos;
    }
    getToken() {
        return this.token;
    }
    getTokenText() {
        return this.text.slice(this.tokenPos, this.pos);
    }
    getTokenValue() {
        return this.tokenValue;
    }
    getTokenIsUnterminated() {
        return (this.tokenFlags & 1 /* Unterminated */) === 1 /* Unterminated */;
    }
    getDiagnostics() {
        return this.diagnostics;
    }
    getTrivia() {
        return this.trivia;
    }
    /** @deprecated */
    getHtmlTrivia() {
        var _a;
        return (_a = this.trivia) === null || _a === void 0 ? void 0 : _a.filter(trivia => (0, tokens_1.isHtmlTriviaKind)(trivia.kind));
    }
    isIndented() {
        return this.significantIndentLength > 0;
    }
    isLineContinuation() {
        return (this.tokenFlags & 2 /* LineContinuation */) === 2 /* LineContinuation */;
    }
    hasPrecedingIndent() {
        return (this.tokenFlags & 48 /* AnyPrecedingIndent */) === 16 /* PrecedingIndent */;
    }
    hasPrecedingDedent() {
        return (this.tokenFlags & 48 /* AnyPrecedingIndent */) === 32 /* PrecedingDedent */;
    }
    hasPrecedingNewLine() {
        return this.hasPrecedingLineTerminator() && !this.isLineContinuation();
    }
    hasPrecedingLineTerminator() {
        return (this.tokenFlags & 4 /* PrecedingLineTerminator */) === 4 /* PrecedingLineTerminator */;
    }
    hasPrecedingBlankLine() {
        return (this.tokenFlags & 8 /* PrecedingBlankLine */) === 8 /* PrecedingBlankLine */;
    }
    hasPrecedingNonWhiteSpaceTrivia() {
        return (this.tokenFlags & 64 /* PrecedingNonWhiteSpaceTrivia */) === 64 /* PrecedingNonWhiteSpaceTrivia */;
    }
    triviaHasPrecedingLineTerminator() {
        return (this.tokenFlags & 128 /* TriviaPrecedingLineTerminator */) === 128 /* TriviaPrecedingLineTerminator */;
    }
    triviaHasPrecedingBlankLine() {
        return (this.tokenFlags & 256 /* TriviaPrecedingBlankLine */) === 256 /* TriviaPrecedingBlankLine */;
    }
    triviaHasPrecedingWhiteSpaceTrivia() {
        return (this.tokenFlags & 512 /* TriviaPrecedingWhiteSpaceTrivia */) === 512 /* TriviaPrecedingWhiteSpaceTrivia */;
    }
    isStartOfFile() {
        return this.startPos === 0;
    }
    setTokenAsUnterminated() {
        this.tokenFlags |= 1 /* Unterminated */;
    }
    setHasPrecedingLineTerminator() {
        this.tokenFlags |= 4 /* PrecedingLineTerminator */ | 128 /* TriviaPrecedingLineTerminator */;
        this.currentIndentLength = 0;
    }
    setHasPrecedingBlankLine() {
        this.tokenFlags |= 8 /* PrecedingBlankLine */ | 256 /* TriviaPrecedingBlankLine */;
        if (this.significantIndentLength > 0) {
            this.setHasPrecedingDedent();
        }
        this.insignificantIndentLength = 0;
        this.significantIndentLength = 0;
        this.currentIndentLength = 0;
    }
    setHasPrecedingIndent() {
        this.tokenFlags = this.tokenFlags & ~32 /* PrecedingDedent */ | 16 /* PrecedingIndent */;
    }
    setHasPrecedingDedent() {
        this.tokenFlags = this.tokenFlags & ~16 /* PrecedingIndent */ | 32 /* PrecedingDedent */;
    }
    setIsLineContinuation() {
        this.tokenFlags |= 2 /* LineContinuation */;
    }
    setHasPrecedingNonWhiteSpaceTrivia() {
        this.tokenFlags |= 64 /* PrecedingNonWhiteSpaceTrivia */;
    }
    resetHasPrecedingNonWhiteSpaceTrivia() {
        this.tokenFlags &= ~64 /* PrecedingNonWhiteSpaceTrivia */;
    }
    setTriviaHasPrecedingBlankLine() {
        this.tokenFlags |= 256 /* TriviaPrecedingBlankLine */;
    }
    setTriviaHasPrecedingWhiteSpaceTrivia() {
        this.tokenFlags |= 512 /* TriviaPrecedingWhiteSpaceTrivia */;
    }
    resetTriviaHasPrecedingWhiteSpaceTrivia() {
        this.tokenFlags &= ~512 /* TriviaPrecedingWhiteSpaceTrivia */;
    }
    resetTriviaFlags() {
        this.tokenFlags &= ~896 /* TriviaFlags */;
    }
    resetIndent() {
        this.insignificantIndentLength = this.currentIndentLength;
        this.significantIndentLength = 0;
        this.tokenFlags &= ~(16 /* PrecedingIndent */ | 32 /* PrecedingDedent */ | 2 /* LineContinuation */);
    }
    speculate(callback, isLookahead) {
        const savedPos = this.pos;
        const savedStartPos = this.startPos;
        const savedTokenPos = this.tokenPos;
        const savedToken = this.token;
        const savedTokenValue = this.tokenValue;
        const savedTokenFlags = this.tokenFlags;
        const savedTrivia = this.trivia;
        const savedLastTrivia = this.lastTrivia;
        const savedDiagnostics = this.diagnostics;
        const savedInitialIndentLength = this.insignificantIndentLength;
        const savedSignificantIndentLength = this.significantIndentLength;
        const savedCurrentIndentLength = this.currentIndentLength;
        this.diagnostics = diagnostics_1.NullDiagnosticMessages.instance;
        const result = callback();
        this.diagnostics = savedDiagnostics;
        if (!result || isLookahead) {
            this.pos = savedPos;
            this.startPos = savedStartPos;
            this.tokenPos = savedTokenPos;
            this.token = savedToken;
            this.tokenValue = savedTokenValue;
            this.tokenFlags = savedTokenFlags;
            this.trivia = savedTrivia;
            this.lastTrivia = savedLastTrivia;
            this.insignificantIndentLength = savedInitialIndentLength;
            this.significantIndentLength = savedSignificantIndentLength;
            this.currentIndentLength = savedCurrentIndentLength;
        }
        return result;
    }
    scan() {
        var _a;
        (_a = this.cancelToken) === null || _a === void 0 ? void 0 : _a.throwIfSignaled();
        this.startPos = this.pos;
        this.tokenValue = "";
        this.tokenFlags = 0;
        this.trivia = undefined;
        while (true) {
            this.tokenPos = this.pos;
            if (this.pos >= this.len) {
                if (this.significantIndentLength > 0) {
                    this.setHasPrecedingDedent();
                }
                this.insignificantIndentLength = 0;
                this.significantIndentLength = 0;
                this.currentIndentLength = 0;
                return this.token = tokens_1.SyntaxKind.EndOfFileToken;
            }
            if (this.proseStartToken) {
                return this.token = this.scanProse();
            }
            let ch = this.text.charCodeAt(this.pos++);
            // scan trivia
            switch (ch) {
                // newline trivia
                case 13 /* CarriageReturn */:
                    if (this.pos < this.len && this.text.charCodeAt(this.pos) === 10 /* LineFeed */) {
                        this.pos++;
                    }
                // falls through
                case 10 /* LineFeed */:
                    if (this.hasPrecedingLineTerminator() && !this.hasPrecedingNonWhiteSpaceTrivia() && !this.hasPrecedingBlankLine()) {
                        this.setHasPrecedingBlankLine();
                    }
                    if (this.triviaHasPrecedingLineTerminator() && !this.triviaHasPrecedingBlankLine()) {
                        this.setTriviaHasPrecedingBlankLine();
                    }
                    this.resetHasPrecedingNonWhiteSpaceTrivia();
                    this.resetTriviaHasPrecedingWhiteSpaceTrivia();
                    this.setHasPrecedingLineTerminator();
                    continue;
                case 32 /* Space */:
                case 9 /* Tab */:
                    // significant whitespace trivia
                    if (this.hasPrecedingLineTerminator())
                        this.currentIndentLength++;
                // falls through
                case 11 /* VerticalTab */:
                case 12 /* FormFeed */:
                    // whitespace trivia
                    this.setTriviaHasPrecedingWhiteSpaceTrivia();
                    continue;
                case 60 /* LessThan */: {
                    // html trivia
                    const ch = this.peekChar(0);
                    if (ch === 47 /* Slash */ ||
                        ch === 62 /* GreaterThan */ ||
                        (ch === 117 /* LowerU */ ? this.peekChar(1) !== 43 /* Plus */ : isHtmlTagNameStart(ch))) {
                        this.scanHtmlTrivia();
                        this.setHasPrecedingNonWhiteSpaceTrivia();
                        continue;
                    }
                    // `<!--`
                    if (ch === 33 /* Exclamation */ &&
                        this.peekChar(1) === 45 /* Minus */ &&
                        this.peekChar(2) === 45 /* Minus */) {
                        this.scanHtmlComment();
                        this.setHasPrecedingNonWhiteSpaceTrivia();
                        continue;
                    }
                    break;
                }
                case 47 /* Slash */:
                    // comment trivia
                    if (this.pos < this.len) {
                        switch (this.text.charCodeAt(this.pos)) {
                            case 47 /* Slash */:
                                // single-line comment
                                this.scanSingleLineCommentTrivia();
                                this.setHasPrecedingNonWhiteSpaceTrivia();
                                continue;
                            case 42 /* Asterisk */:
                                // multi-line comment
                                this.scanMultiLineCommentTrivia();
                                this.setHasPrecedingNonWhiteSpaceTrivia();
                                continue;
                        }
                    }
                    break;
            }
            // check for changes in indentation
            if (this.isStartOfFile() || this.hasPrecedingLineTerminator()) {
                if (this.isStartOfFile() || this.hasPrecedingBlankLine()) {
                    // Reset indentation at the start of a file or following a blank line.
                    // Any whitespace here will be considered insignificant and won't count
                    // towards indentation.
                    this.insignificantIndentLength = this.currentIndentLength;
                    this.significantIndentLength = 0;
                }
                else if (this.currentIndentLength <= this.insignificantIndentLength) {
                    // The current indentation is equal to or less than the insignificant indentation.
                    if (this.significantIndentLength > 0) {
                        // If we have a significant indent, reset the significant indentation and mark this
                        // as a dedent.
                        this.significantIndentLength = 0;
                        this.setHasPrecedingDedent();
                    }
                }
                else {
                    // The current indentation is greater than the insignificant indentation length we
                    // recorded at the start of the file or since the last blank line.
                    if (this.significantIndentLength === 0) {
                        // If we have no significant indentation, record this as the new significant
                        // indentation length and mark that we saw an indent.
                        this.significantIndentLength = this.currentIndentLength;
                        this.setHasPrecedingIndent();
                    }
                    else if (this.currentIndentLength > this.significantIndentLength) {
                        // If the new indentation is greater than the significant indentation length,
                        // then this is a line continuation.
                        this.setIsLineContinuation();
                    }
                }
            }
            this.finishLastTrivia();
            if (ch === 38 /* Ampersand */) {
                ch = this.scanCharacterEntity();
            }
            // scan token
            switch (ch) {
                case 64 /* At */:
                    return this.token = tokens_1.SyntaxKind.AtToken;
                case 35 /* NumberSign */:
                    return this.tokenValue = this.scanLine(), this.token = tokens_1.SyntaxKind.LinkReference;
                case 34 /* DoubleQuote */:
                case 39 /* SingleQuote */:
                    return this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.StringLiteral), this.token;
                case 96 /* Backtick */:
                    return this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.TerminalLiteral), this.token;
                case 124 /* Bar */:
                    return this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.Identifier), this.token;
                case 60 /* LessThan */:
                    if (this.expectCharacter(/*decodeEntity*/ true, 33 /* Exclamation */)) {
                        return this.token = tokens_1.SyntaxKind.LessThanExclamationToken;
                    }
                    else if (this.expectCharacter(/*decodeEntity*/ true, 45 /* Minus */)) {
                        return this.token = tokens_1.SyntaxKind.LessThanMinusToken;
                    }
                    else {
                        return this.tokenValue = this.scanString(62 /* GreaterThan */, this.token = tokens_1.SyntaxKind.UnicodeCharacterLiteral), this.token;
                    }
                case 8800 /* NotEqualTo */:
                    return this.token = tokens_1.SyntaxKind.NotEqualToToken;
                case 8712 /* ElementOf */:
                    return this.token = tokens_1.SyntaxKind.ElementOfToken;
                case 8713 /* NotAnElementOf */:
                    return this.token = tokens_1.SyntaxKind.NotAnElementOfToken;
                case 62 /* GreaterThan */:
                    return this.skipWhiteSpace(), this.proseStartToken = this.token = tokens_1.SyntaxKind.GreaterThanToken;
                case 40 /* OpenParen */:
                    return this.token = tokens_1.SyntaxKind.OpenParenToken;
                case 41 /* CloseParen */:
                    return this.token = tokens_1.SyntaxKind.CloseParenToken;
                case 91 /* OpenBracket */:
                    if (this.expectCharacter(/*decodeEntity*/ true, 62 /* GreaterThan */)) {
                        return this.skipWhiteSpace(), this.proseStartToken = this.token = tokens_1.SyntaxKind.OpenBracketGreaterThanToken;
                    }
                    return this.token = tokens_1.SyntaxKind.OpenBracketToken;
                case 93 /* CloseBracket */:
                    return this.token = tokens_1.SyntaxKind.CloseBracketToken;
                case 123 /* OpenBrace */:
                    return this.token = tokens_1.SyntaxKind.OpenBraceToken;
                case 125 /* CloseBrace */:
                    return this.token = tokens_1.SyntaxKind.CloseBraceToken;
                case 43 /* Plus */:
                    return this.token = tokens_1.SyntaxKind.PlusToken;
                case 126 /* Tilde */:
                    return this.token = tokens_1.SyntaxKind.TildeToken;
                case 44 /* Comma */:
                    return this.token = tokens_1.SyntaxKind.CommaToken;
                case 58 /* Colon */:
                    if (this.expectCharacter(/*decodeEntity*/ true, 58 /* Colon */)) {
                        if (this.expectCharacter(/*decodeEntity*/ true, 58 /* Colon */)) {
                            return this.token = tokens_1.SyntaxKind.ColonColonColonToken;
                        }
                        return this.token = tokens_1.SyntaxKind.ColonColonToken;
                    }
                    return this.token = tokens_1.SyntaxKind.ColonToken;
                case 63 /* Question */:
                    return this.token = tokens_1.SyntaxKind.QuestionToken;
                case 61 /* Equals */:
                    if (this.expectCharacter(/*decodeEntity*/ true, 61 /* Equals */)) {
                        return this.token = tokens_1.SyntaxKind.EqualsEqualsToken;
                    }
                    return this.token = tokens_1.SyntaxKind.EqualsToken;
                case 33 /* Exclamation */:
                    if (this.expectCharacter(/*decodeEntity*/ true, 61 /* Equals */)) {
                        return this.token = tokens_1.SyntaxKind.ExclamationEqualsToken;
                    }
                    return this.token = tokens_1.SyntaxKind.Unknown;
                case 48 /* Number0 */:
                case 49 /* Number1 */:
                case 50 /* Number2 */:
                case 51 /* Number3 */:
                case 52 /* Number4 */:
                case 53 /* Number5 */:
                case 54 /* Number6 */:
                case 55 /* Number7 */:
                case 56 /* Number8 */:
                case 57 /* Number9 */:
                    return this.tokenValue = this.scanNumber(ch, /*decodeEntities*/ true), this.token = tokens_1.SyntaxKind.NumberLiteral;
                case 85 /* UpperU */:
                case 117 /* LowerU */: {
                    const savedPos = this.pos;
                    const savedTokenFlags = this.tokenFlags;
                    if (this.pos < this.len && this.expectCharacter(/*decodeEntity*/ true, 43 /* Plus */)) {
                        if (this.scanHexDigits(/*decodeEntities*/ true, 1, 6, /*forbidExcessDigits*/ true) !== -1) {
                            // NOTE: code points are validated in checker
                            return this.token = tokens_1.SyntaxKind.UnicodeCharacterLiteral;
                        }
                        this.pos = savedPos;
                        this.tokenFlags = savedTokenFlags;
                    }
                }
                // fall-through
                default:
                    if (isIdentifierStart(ch)) {
                        let startPos = this.tokenPos;
                        if (this.tokenFlags & 1024 /* DecodedEntity */) {
                            this.tokenValue = String.fromCharCode(ch);
                            startPos = this.pos;
                        }
                        else {
                            this.tokenValue = "";
                        }
                        while (this.pos < this.len) {
                            const lastPos = this.pos;
                            const ch = this.scanCharacter(/*decodeEntity*/ true);
                            if (!isIdentifierPart(ch)) {
                                this.pos = lastPos;
                                break;
                            }
                            if (this.tokenFlags & 1024 /* DecodedEntity */) {
                                this.tokenValue += this.text.slice(startPos, lastPos);
                                this.tokenValue += String.fromCharCode(ch);
                                startPos = this.pos;
                            }
                        }
                        this.tokenValue += this.text.slice(startPos, this.pos);
                        return this.token = this.getIdentifierToken();
                    }
                    this.getDiagnostics().report(this.pos, diagnostics_1.Diagnostics.Invalid_character);
                    return this.token = tokens_1.SyntaxKind.Unknown;
            }
        }
    }
    scanRange(pos, cb) {
        if (pos < 0)
            throw new RangeError();
        pos = Math.min(pos, this.len);
        return this.speculate(() => {
            // if pos - 1 is whitespace, walk back the whitespace to rescan indentation
            if (pos > 0 && pos < this.len) {
                let start = pos - 1;
                while (isWhiteSpace(this.text.charCodeAt(start))) {
                    start--;
                }
                if (isLineTerminator(this.text.charCodeAt(start))) {
                    pos = start + 1;
                }
            }
            this.pos = pos;
            this.startPos = pos;
            this.tokenPos = pos;
            this.tokenValue = "";
            this.tokenFlags = 0;
            this.trivia = undefined;
            this.insignificantIndentLength = 0;
            this.significantIndentLength = 0;
            this.currentIndentLength = 0;
            return cb();
        }, /*isLookahead*/ true);
    }
    peekChar(offset) {
        return this.pos + offset < this.text.length ?
            this.text.charCodeAt(this.pos + offset) :
            -1;
    }
    scanLine() {
        const start = this.pos;
        while (this.pos < this.len) {
            const ch = this.text.charCodeAt(this.pos);
            if (isLineTerminator(ch)) {
                break;
            }
            this.pos++;
        }
        return this.text.substring(start, this.pos);
    }
    skipLineTerminator() {
        const ch = this.text.charCodeAt(this.pos);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && this.text.charCodeAt(this.pos + 1) === 10 /* LineFeed */) {
                this.pos += 2;
            }
            else {
                this.pos++;
            }
        }
    }
    skipWhiteSpace() {
        while (true) {
            const ch = this.text.charCodeAt(this.pos);
            switch (ch) {
                case 32 /* Space */:
                case 9 /* Tab */:
                case 11 /* VerticalTab */:
                case 12 /* FormFeed */:
                    this.pos++;
                    continue;
                default:
                    return;
            }
        }
    }
    scanProse() {
        const previousToken = this.token;
        const isMultiLine = this.proseStartToken === tokens_1.SyntaxKind.GreaterThanToken;
        const atStartOfProse = previousToken === this.proseStartToken;
        const previousTokenWasFragment = (0, tokens_1.isProseFragmentLiteralKind)(previousToken);
        let start = this.pos;
        let tokenValue = "";
        while (true) {
            if (this.pos >= this.len) {
                tokenValue += this.text.substring(start, this.pos);
                this.tokenValue = tokenValue;
                this.proseStartToken = undefined;
                if (!isMultiLine) {
                    this.setTokenAsUnterminated();
                    this.getDiagnostics().report(this.pos, diagnostics_1.Diagnostics._0_expected, "]");
                }
                return atStartOfProse ? tokens_1.SyntaxKind.ProseFull : tokens_1.SyntaxKind.ProseTail;
            }
            const ch = this.text.charCodeAt(this.pos);
            if (previousTokenWasFragment) {
                if (ch === 96 /* Backtick */) {
                    return this.pos++, this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.TerminalLiteral), this.token;
                }
                else if (ch === 124 /* Bar */) {
                    return this.pos++, this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.Identifier), this.token;
                }
            }
            if (isMultiLine) {
                if (isLineTerminator(ch)) {
                    tokenValue += this.text.substring(start, this.pos);
                    if (this.nextLineIsProse()) {
                        tokenValue += "\n";
                        continue;
                    }
                    this.tokenValue = tokenValue;
                    this.proseStartToken = undefined;
                    return atStartOfProse ? tokens_1.SyntaxKind.ProseFull : tokens_1.SyntaxKind.ProseTail;
                }
            }
            else {
                if (ch === 93 /* CloseBracket */) {
                    tokenValue += this.text.substring(start, this.pos);
                    this.tokenValue = tokenValue;
                    this.proseStartToken = undefined;
                    return atStartOfProse ? tokens_1.SyntaxKind.ProseFull : tokens_1.SyntaxKind.ProseTail;
                }
            }
            if (ch === 96 /* Backtick */ || ch === 124 /* Bar */) {
                tokenValue += this.text.substring(start, this.pos);
                this.tokenValue = tokenValue;
                return atStartOfProse ? tokens_1.SyntaxKind.ProseHead : tokens_1.SyntaxKind.ProseMiddle;
            }
            if (ch === 38 /* Ampersand */) {
                tokenValue += this.text.substring(start, this.pos);
                this.pos++;
                tokenValue += String.fromCharCode(this.scanCharacterEntity());
                start = this.pos;
                continue;
            }
            this.pos++;
        }
    }
    nextLineIsProse() {
        return this.speculate(() => {
            this.skipLineTerminator();
            this.skipWhiteSpace();
            if (this.pos < this.len) {
                if (this.expectCharacter(/*decodeEntity*/ true, 62 /* GreaterThan */)) {
                    this.skipWhiteSpace();
                    return true;
                }
            }
            return false;
        }, /*isLookahead*/ false);
    }
    finishLastTrivia() {
        if (this.lastTrivia) {
            (0, nodeInternal_1.getTriviaAccessor)().setFollowingFields(this.lastTrivia, this.triviaHasPrecedingLineTerminator(), this.triviaHasPrecedingBlankLine(), this.triviaHasPrecedingWhiteSpaceTrivia());
            this.lastTrivia = undefined;
        }
    }
    recordTrivia(trivia) {
        this.finishLastTrivia();
        (0, nodeInternal_1.getTriviaAccessor)().setPrecedingFields(trivia, this.triviaHasPrecedingLineTerminator(), this.triviaHasPrecedingBlankLine(), this.triviaHasPrecedingWhiteSpaceTrivia());
        (0, nodeInternal_1.getNodeAccessor)().setTextRange(trivia, this.tokenPos, this.pos);
        this.trivia || (this.trivia = []);
        this.trivia.push(trivia);
        this.lastTrivia = trivia;
        this.resetTriviaFlags();
    }
    scanSingleLineCommentTrivia() {
        // //comment
        //  ^
        //  current pos
        const end = findSingleLineCommentTriviaEnd(this.text, this.pos + 1, this.len);
        this.pos = end;
        this.recordTrivia(new nodes_1.SingleLineCommentTrivia());
    }
    scanMultiLineCommentTrivia() {
        // /*comment*/
        //  ^
        //  current pos
        const { closed, end } = findMultiLineCommentTriviaEnd(this.text, this.pos + 1, this.len);
        this.pos = end;
        if (!closed) {
            this.getDiagnostics().report(this.pos, diagnostics_1.Diagnostics._0_expected, "*/");
        }
        this.recordTrivia(new nodes_1.MultiLineCommentTrivia());
    }
    scanHtmlTrivia() {
        // <tag>
        //  ^
        //  current pos
        const isClosingTag = this.text.charCodeAt(this.pos) === 47 /* Slash */;
        const end = findHtmlTriviaEnd(this.text, this.pos, this.len);
        const tagNamePos = isClosingTag ? this.pos + 1 : this.pos;
        const tagNameEnd = findHtmlTagNameEnd(this.text, tagNamePos, end);
        this.pos = end;
        const tagName = this.text.slice(tagNamePos, tagNameEnd === -1 ? end : tagNameEnd);
        this.recordTrivia(isClosingTag ? new nodes_1.HtmlCloseTagTrivia(tagName) : new nodes_1.HtmlOpenTagTrivia(tagName));
    }
    scanHtmlComment() {
        // <!--
        //  ^
        //  current pos
        const end = findHtmlCommentEnd(this.text, this.pos + 3, this.len);
        this.pos = end;
        this.recordTrivia(new nodes_1.HtmlCommentTrivia());
    }
    expectCharacter(decodeEntity, ch) {
        const savedPos = this.pos;
        const savedTokenFlags = this.tokenFlags;
        if (this.scanCharacter(decodeEntity) !== ch) {
            this.pos = savedPos;
            this.tokenFlags = savedTokenFlags;
            return false;
        }
        return true;
    }
    matchCharacter(decodeEntity, cb) {
        const savedPos = this.pos;
        const savedTokenFlags = this.tokenFlags;
        const ch = this.scanCharacter(decodeEntity);
        if (!cb(ch)) {
            this.pos = savedPos;
            this.tokenFlags = savedTokenFlags;
            return -1;
        }
        return ch;
    }
    scanCharacter(decodeEntity) {
        const ch = this.text.charCodeAt(this.pos++);
        if (decodeEntity && ch === 38 /* Ampersand */) {
            return this.scanCharacterEntity();
        }
        this.tokenFlags &= ~1024 /* DecodedEntity */;
        return ch;
    }
    scanCharacterEntity() {
        let value = 0;
        let start;
        let pos;
        if (this.text.charCodeAt(this.pos) === 35 /* Hash */) {
            const hex = this.text.charCodeAt(this.pos + 1) === 120 /* LowerX */ ||
                this.text.charCodeAt(this.pos + 1) === 88 /* UpperX */;
            start = this.pos + (hex ? 2 : 1);
            pos = start;
            while (pos < this.len) {
                const ch = this.text.charCodeAt(pos);
                const digit = hex ? charToHexDigit(ch) : charToDecimalDigit(ch);
                if (digit === -1)
                    break;
                value = value * (hex ? 16 : 10) + digit;
                pos++;
            }
        }
        else {
            start = pos = this.pos;
            while (pos < this.len) {
                if (!isAlphaNum(this.text.charCodeAt(pos)))
                    break;
                pos++;
            }
            const entity = this.text.slice(start, pos);
            if (htmlCharacterEntities.hasOwnProperty(entity)) {
                value = htmlCharacterEntities[entity];
            }
        }
        if (pos > start && this.text.charCodeAt(pos) === 59 /* Semicolon */) {
            this.pos = pos + 1;
            this.tokenFlags |= 1024 /* DecodedEntity */;
            return value;
        }
        this.tokenFlags &= ~1024 /* DecodedEntity */;
        return 38 /* Ampersand */;
    }
    scanString(quote, kind) {
        const diagnostic = kind === tokens_1.SyntaxKind.Identifier ? diagnostics_1.Diagnostics.Unterminated_identifier_literal : diagnostics_1.Diagnostics.Unterminated_string_literal;
        const decodeEscapeSequences = kind !== tokens_1.SyntaxKind.TerminalLiteral;
        let result = "";
        let start = this.pos;
        while (true) {
            if (this.pos >= this.len) {
                result += this.text.slice(start, this.pos);
                this.setTokenAsUnterminated();
                this.getDiagnostics().reportRange(this.tokenPos, this.pos, diagnostic || diagnostics_1.Diagnostics.Unterminated_string_literal);
                break;
            }
            const lastPos = this.pos;
            let ch = this.scanCharacter(decodeEscapeSequences);
            if (this.tokenFlags & 1024 /* DecodedEntity */) {
                // Reference-decoded characters span multiple indexes, breaking naive assumptions.
                // Read in everything preceding the reference, and set the new position to the
                // index following it.
                result += this.text.slice(start, lastPos);
                start = this.pos;
            }
            if (ch === quote) {
                // If this is a terminal consisting solely of one backtick character (e.g. ```),
                // we capture the backtick.
                if (quote === 96 /* Backtick */ && result === "" && this.pos < this.len) {
                    const peekPos = this.pos;
                    ch = this.scanCharacter(decodeEscapeSequences);
                    if (ch === 96 /* Backtick */) {
                        result = "`";
                        break;
                    }
                    this.pos = peekPos;
                }
                result += this.text.slice(start, this.pos - 1);
                break;
            }
            else if (quote === 62 /* GreaterThan */ && ch === 60 /* LessThan */) {
                this.pos = lastPos;
                result += this.text.slice(start, lastPos);
                this.setTokenAsUnterminated();
                this.getDiagnostics().reportRange(this.tokenPos, lastPos, diagnostic || diagnostics_1.Diagnostics.Unterminated_string_literal);
                break;
            }
            else if (decodeEscapeSequences && ch === 92 /* Backslash */) {
                // terminals cannot have escape sequences
                result += this.text.slice(start, this.pos - 1);
                result += this.scanEscapeSequence(lastPos);
                start = this.pos;
                continue;
            }
            else if (isLineTerminator(ch)) {
                this.pos--;
                result += this.text.slice(start, this.pos);
                this.setTokenAsUnterminated();
                this.getDiagnostics().reportRange(this.tokenPos, this.pos, diagnostic || diagnostics_1.Diagnostics.Unterminated_string_literal);
                break;
            }
        }
        return result;
    }
    scanEscapeSequence(start) {
        if (this.pos >= this.len) {
            this.getDiagnostics().reportRange(start, this.pos, diagnostics_1.Diagnostics.Invalid_escape_sequence);
            return "";
        }
        let ch = this.text.charCodeAt(this.pos++);
        switch (ch) {
            case 48 /* Number0 */:
                return "\0";
            case 98 /* LowerB */:
                return "\b";
            case 116 /* LowerT */:
                return "\t";
            case 110 /* LowerN */:
                return "\n";
            case 118 /* LowerV */:
                return "\v";
            case 102 /* LowerF */:
                return "\f";
            case 114 /* LowerR */:
                return "\r";
            case 39 /* SingleQuote */:
                return "\'";
            case 34 /* DoubleQuote */:
                return "\"";
            case 120 /* LowerX */:
            case 117 /* LowerU */:
                ch = this.scanHexDigits(/*decodeEntities*/ false, ch === 120 /* LowerX */ ? 2 : 4);
                if (ch >= 0) {
                    return String.fromCharCode(ch);
                }
                else {
                    this.getDiagnostics().reportRange(start, this.pos, diagnostics_1.Diagnostics.Invalid_escape_sequence);
                    return "";
                }
            // when encountering a LineContinuation (i.e. a backslash and a line terminator sequence),
            // the line terminator is interpreted to be "the empty code unit sequence".
            case 13 /* CarriageReturn */:
                if (this.pos < this.len && this.text.charCodeAt(this.pos) === 10 /* LineFeed */) {
                    this.pos++;
                }
            // fall through
            case 10 /* LineFeed */:
            case 8232 /* LineSeparator */:
            case 8233 /* ParagraphSeparator */:
                return "";
            default:
                return String.fromCharCode(ch);
        }
    }
    scanHexDigit(decodeEntity) {
        const initialPos = this.pos;
        const ch = this.scanCharacter(decodeEntity);
        const value = charToHexDigit(ch);
        if (value === -1) {
            this.pos = initialPos;
        }
        return value;
    }
    scanHexDigits(decodeEntities, minCount, maxCount = minCount, forbidExcessDigits) {
        const start = this.pos;
        let digits = 0;
        let value = 0;
        while (digits < maxCount) {
            const digit = this.scanHexDigit(decodeEntities);
            if (digit === -1)
                break;
            value = value * 16 + digit;
            digits++;
        }
        if (digits < minCount || digits === maxCount && forbidExcessDigits && this.scanHexDigit(/*decodeEntity*/ true) !== -1) {
            this.pos = start;
            return -1;
        }
        return value;
    }
    scanNumber(ch, decodeEntities) {
        let text = "";
        let startPos = this.tokenPos;
        let lastPos = this.pos;
        if (this.tokenFlags & 1024 /* DecodedEntity */) {
            text += this.text.slice(startPos, lastPos);
            text += String.fromCharCode(ch);
            startPos = this.pos;
        }
        while (this.pos < this.len) {
            ch = this.matchCharacter(decodeEntities, isDecimalDigit);
            if (ch < 0)
                break;
            if (this.tokenFlags & 1024 /* DecodedEntity */) {
                text += this.text.slice(startPos, lastPos);
                text += String.fromCharCode(ch);
                startPos = this.pos;
            }
            lastPos = this.pos;
        }
        if (this.pos < this.len && this.expectCharacter(decodeEntities, 46 /* Dot */)) {
            if (this.tokenFlags & 1024 /* DecodedEntity */) {
                text += this.text.slice(startPos, lastPos);
                text += ".";
                startPos = this.pos;
            }
            lastPos = this.pos;
            while (this.pos < this.len) {
                const ch = this.matchCharacter(decodeEntities, isDecimalDigit);
                if (ch < 0)
                    break;
                if (this.tokenFlags & 1024 /* DecodedEntity */) {
                    text += this.text.slice(startPos, lastPos);
                    text += String.fromCharCode(ch);
                    startPos = this.pos;
                }
                lastPos = this.pos;
            }
        }
        if (this.pos < this.len) {
            ch = this.matchCharacter(decodeEntities, isUpperOrLowerE);
            if (ch >= 0) {
                if (this.tokenFlags & 1024 /* DecodedEntity */) {
                    text += this.text.slice(startPos, lastPos);
                    text += String.fromCharCode(ch);
                    startPos = this.pos;
                }
                lastPos = this.pos;
                if (this.pos < this.len) {
                    ch = this.matchCharacter(decodeEntities, isPlusOrMinus);
                    if (ch >= 0) {
                        if (this.tokenFlags & 1024 /* DecodedEntity */) {
                            text += this.text.slice(startPos, lastPos);
                            text += String.fromCharCode(ch);
                            startPos = this.pos;
                        }
                    }
                    lastPos = this.pos;
                }
                if (this.pos < this.len) {
                    ch = this.matchCharacter(decodeEntities, isDecimalDigit);
                    if (ch >= 0) {
                        if (this.tokenFlags & 1024 /* DecodedEntity */) {
                            text += this.text.slice(startPos, lastPos);
                            text += String.fromCharCode(ch);
                            startPos = this.pos;
                        }
                        lastPos = this.pos;
                        while (this.pos < this.len) {
                            ch = this.matchCharacter(decodeEntities, isDecimalDigit);
                            if (ch < 0)
                                break;
                            if (this.tokenFlags & 1024 /* DecodedEntity */) {
                                text += this.text.slice(startPos, lastPos);
                                text += String.fromCharCode(ch);
                                startPos = this.pos;
                            }
                            lastPos = this.pos;
                        }
                    }
                    else {
                        this.getDiagnostics().report(this.pos, diagnostics_1.Diagnostics.Digit_expected);
                    }
                }
                else {
                    this.getDiagnostics().report(this.pos, diagnostics_1.Diagnostics.Digit_expected);
                }
            }
        }
        text += this.text.slice(startPos, this.pos);
        return +text + "";
    }
    getIdentifierToken() {
        const len = this.tokenValue.length;
        if (len >= 2 && len <= 9) {
            const ch = this.tokenValue.charCodeAt(0);
            if (ch >= 97 /* LowerA */ && ch <= 116 /* LowerT */) {
                const token = (0, tokens_1.stringToToken)(this.tokenValue);
                if (token !== undefined) {
                    return this.token = token;
                }
            }
        }
        return this.token = tokens_1.SyntaxKind.Identifier;
    }
}
exports.Scanner = Scanner;
function isLineTerminator(ch) {
    return ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */;
}
function isSignificantWhiteSpace(ch) {
    switch (ch) {
        case 32 /* Space */:
        case 9 /* Tab */:
            return true;
    }
    return false;
}
function isInsignificantWhiteSpace(ch) {
    switch (ch) {
        case 11 /* VerticalTab */:
        case 12 /* FormFeed */:
            return true;
    }
    return false;
}
/** @internal */
function isWhiteSpace(ch) {
    return isSignificantWhiteSpace(ch) || isInsignificantWhiteSpace(ch);
}
exports.isWhiteSpace = isWhiteSpace;
function isUpperAlpha(ch) {
    return ch >= 65 /* UpperA */ && ch <= 90 /* UpperZ */;
}
function isLowerAlpha(ch) {
    return ch >= 97 /* LowerA */ && ch <= 122 /* LowerZ */;
}
function isAlpha(ch) {
    return isUpperAlpha(ch) || isLowerAlpha(ch);
}
function isDecimalDigit(ch) {
    return ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */;
}
function isAlphaNum(ch) {
    return isAlpha(ch) || isDecimalDigit(ch);
}
function isUpperOrLowerE(ch) {
    return ch === 69 /* UpperE */ || ch === 101 /* LowerE */;
}
function isPlusOrMinus(ch) {
    return ch === 43 /* Plus */ || ch === 45 /* Minus */;
}
function charToHexDigit(ch) {
    if (ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */) {
        return ch - 48 /* Number0 */;
    }
    else if (ch >= 65 /* UpperA */ && ch <= 70 /* UpperF */) {
        return ch - 65 /* UpperA */ + 10;
    }
    else if (ch >= 97 /* LowerA */ && ch <= 102 /* LowerF */) {
        return ch - 97 /* LowerA */ + 10;
    }
    return -1;
}
function charToDecimalDigit(ch) {
    if (ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */) {
        return ch - 48 /* Number0 */;
    }
    return -1;
}
/** @internal */
function isHexDigit(ch) {
    return ch >= 65 /* UpperA */ && ch <= 70 /* UpperF */
        || ch >= 97 /* LowerA */ && ch <= 102 /* LowerF */
        || ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */;
}
exports.isHexDigit = isHexDigit;
/** @internal */
function isIdentifierStart(ch) {
    return isAlpha(ch)
        || ch === 95 /* Underscore */;
}
exports.isIdentifierStart = isIdentifierStart;
/** @internal */
function isIdentifierPart(ch) {
    return isAlphaNum(ch)
        || ch === 95 /* Underscore */;
}
exports.isIdentifierPart = isIdentifierPart;
function isHtmlTagNameStart(ch) {
    return isLowerAlpha(ch);
}
function isHtmlTagNamePart(ch) {
    return isIdentifierPart(ch)
        || ch === 45 /* Minus */;
}
function findHtmlCommentEnd(text, pos, end) {
    while (pos + 2 < end) {
        if (text.charCodeAt(pos) === 45 /* Minus */ &&
            text.charCodeAt(pos + 1) === 45 /* Minus */ &&
            text.charCodeAt(pos + 2) === 62 /* GreaterThan */) {
            return pos + 3;
        }
        pos++;
    }
    return end;
}
function findHtmlTriviaEnd(text, pos, end) {
    while (pos < end) {
        const ch = text.charCodeAt(pos++);
        if (ch === 62 /* GreaterThan */) {
            return pos;
        }
    }
    return end;
}
function findHtmlTagNameEnd(text, pos, end) {
    if (pos < end && isHtmlTagNameStart(text.charCodeAt(pos))) {
        pos++;
        while (pos < end && isHtmlTagNamePart(text.charCodeAt(pos))) {
            pos++;
        }
        return pos;
    }
    return -1;
}
function skipTrivia(text, pos, end, htmlTrivia, commentTrivia) {
    scan: while (pos < end) {
        const ch = text.charCodeAt(pos);
        switch (ch) {
            case 13 /* CarriageReturn */:
            case 10 /* LineFeed */:
            case 32 /* Space */:
            case 9 /* Tab */:
            case 11 /* VerticalTab */:
            case 12 /* FormFeed */:
                pos++;
                continue;
            case 47 /* Slash */:
                if (pos + 1 < end) {
                    switch (text.charCodeAt(pos + 1)) {
                        case 47 /* Slash */: {
                            const commentEnd = findSingleLineCommentTriviaEnd(text, pos + 2, end);
                            if (commentTrivia) {
                                const comment = new nodes_1.SingleLineCommentTrivia();
                                (0, nodeInternal_1.getNodeAccessor)().setTextRange(comment, pos, commentEnd);
                                commentTrivia.push(comment);
                            }
                            pos = commentEnd;
                            continue;
                        }
                        case 42 /* Asterisk */: {
                            const { end: commentEnd } = findMultiLineCommentTriviaEnd(text, pos + 2, end);
                            if (commentTrivia) {
                                const comment = new nodes_1.MultiLineCommentTrivia();
                                (0, nodeInternal_1.getNodeAccessor)().setTextRange(comment, pos, commentEnd);
                                commentTrivia.push(comment);
                            }
                            pos = commentEnd;
                            continue;
                        }
                    }
                }
                break scan;
            case 60 /* LessThan */:
                if (pos + 1 < end) {
                    const ch = text.charCodeAt(pos + 1);
                    if (ch === 47 /* Slash */ ||
                        (ch === 117 /* LowerU */ ? !(pos + 2 < end && text.charCodeAt(pos + 2) === 43 /* Plus */) :
                            (ch >= 97 /* LowerA */ && ch <= 122 /* LowerZ */))) {
                        const triviaEnd = findHtmlTriviaEnd(text, pos + 1, end);
                        if (htmlTrivia) {
                            const tagNamePos = ch === 47 /* Slash */ ? pos + 2 : pos + 1;
                            const tagNameEnd = findHtmlTagNameEnd(text, tagNamePos, triviaEnd);
                            if (tagNameEnd !== -1) {
                                const tagName = text.slice(tagNamePos, tagNameEnd);
                                const tag = ch === 47 /* Slash */ ? new nodes_1.HtmlCloseTagTrivia(tagName) : new nodes_1.HtmlOpenTagTrivia(tagName);
                                (0, nodeInternal_1.getNodeAccessor)().setTextRange(tag, pos, triviaEnd);
                                htmlTrivia.push(tag);
                            }
                        }
                        pos = triviaEnd;
                        continue;
                    }
                    if (pos + 3 < end &&
                        ch === 33 /* Exclamation */ &&
                        text.charCodeAt(pos + 2) === 45 /* Minus */ &&
                        text.charCodeAt(pos + 3) === 45 /* Minus */) {
                        const triviaEnd = findHtmlCommentEnd(text, pos + 3, end);
                        if (htmlTrivia) {
                            const trivia = new nodes_1.HtmlCommentTrivia();
                            (0, nodeInternal_1.getNodeAccessor)().setTextRange(trivia, pos, triviaEnd);
                            htmlTrivia.push(trivia);
                        }
                        pos = triviaEnd;
                        continue;
                    }
                }
                break scan;
            default:
                break scan;
        }
    }
    return pos;
}
exports.skipTrivia = skipTrivia;
function scanHtmlTrivia(text, pos, end) {
    const trivia = [];
    skipTrivia(text, pos, end, trivia);
    return trivia.length > 0 ? trivia : undefined;
}
exports.scanHtmlTrivia = scanHtmlTrivia;
function findMultiLineCommentTriviaEnd(text, pos, end) {
    while (pos < end) {
        const ch = text.charCodeAt(pos);
        if (ch === 42 /* Asterisk */ && pos + 1 < end && text.charCodeAt(pos + 1) === 47 /* Slash */) {
            return { closed: true, end: pos + 2 };
        }
        pos++;
    }
    return { closed: false, end };
}
function findSingleLineCommentTriviaEnd(text, pos, end) {
    while (pos < end) {
        const ch = text.charCodeAt(pos);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            return pos;
        }
        pos++;
    }
    return end;
}
function decodeHtmlEntities(text) {
    let ch;
    let pos = 0;
    let startPos = pos;
    let entityPos;
    let entityStart;
    let result;
    while (pos < text.length) {
        const lastPos = pos;
        ch = text.charCodeAt(pos++);
        if (ch === 38 /* Ampersand */) {
            if (text.charCodeAt(pos) === 35 /* Hash */) {
                const hex = text.charCodeAt(pos + 1) === 120 /* LowerX */ ||
                    text.charCodeAt(pos + 1) === 88 /* UpperX */;
                entityStart = pos + (hex ? 2 : 1);
                entityPos = entityStart;
                ch = 0;
                while (entityPos < text.length) {
                    const digit = hex ?
                        charToHexDigit(text.charCodeAt(entityPos)) :
                        charToDecimalDigit(text.charCodeAt(entityPos));
                    if (digit === -1)
                        break;
                    ch = ch * (hex ? 16 : 10) + digit;
                    entityPos++;
                }
            }
            else {
                entityStart = entityPos = pos;
                while (entityPos < text.length) {
                    if (!isAlphaNum(text.charCodeAt(entityPos)))
                        break;
                    entityPos++;
                }
                const entity = text.slice(entityStart, entityPos);
                if (htmlCharacterEntities.hasOwnProperty(entity)) {
                    ch = htmlCharacterEntities[entity];
                }
            }
            if (entityPos > entityStart && text.charCodeAt(entityPos) === 59 /* Semicolon */) {
                result !== null && result !== void 0 ? result : (result = "");
                result += text.slice(startPos, lastPos);
                result += String.fromCharCode(ch);
                pos = entityPos + 1;
                startPos = pos;
            }
        }
    }
    if (result !== undefined) {
        return result + text.slice(startPos);
    }
    return text;
}
exports.decodeHtmlEntities = decodeHtmlEntities;
const htmlCharacterEntities = {
    quot: 0x0022,
    amp: 0x0026,
    apos: 0x0027,
    lt: 0x003C,
    gt: 0x003E,
    nbsp: 0x00A0,
    iexcl: 0x00A1,
    cent: 0x00A2,
    pound: 0x00A3,
    curren: 0x00A4,
    yen: 0x00A5,
    brvbar: 0x00A6,
    sect: 0x00A7,
    uml: 0x00A8,
    copy: 0x00A9,
    ordf: 0x00AA,
    laquo: 0x00AB,
    not: 0x00AC,
    shy: 0x00AD,
    reg: 0x00AE,
    macr: 0x00AF,
    deg: 0x00B0,
    plusmn: 0x00B1,
    sup2: 0x00B2,
    sup3: 0x00B3,
    acute: 0x00B4,
    micro: 0x00B5,
    para: 0x00B6,
    middot: 0x00B7,
    cedil: 0x00B8,
    sup1: 0x00B9,
    ordm: 0x00BA,
    raquo: 0x00BB,
    frac14: 0x00BC,
    frac12: 0x00BD,
    frac34: 0x00BE,
    iquest: 0x00BF,
    Agrave: 0x00C0,
    Aacute: 0x00C1,
    Acirc: 0x00C2,
    Atilde: 0x00C3,
    Auml: 0x00C4,
    Aring: 0x00C5,
    AElig: 0x00C6,
    Ccedil: 0x00C7,
    Egrave: 0x00C8,
    Eacute: 0x00C9,
    Ecirc: 0x00CA,
    Euml: 0x00CB,
    Igrave: 0x00CC,
    Iacute: 0x00CD,
    Icirc: 0x00CE,
    Iuml: 0x00CF,
    ETH: 0x00D0,
    Ntilde: 0x00D1,
    Ograve: 0x00D2,
    Oacute: 0x00D3,
    Ocirc: 0x00D4,
    Otilde: 0x00D5,
    Ouml: 0x00D6,
    times: 0x00D7,
    Oslash: 0x00D8,
    Ugrave: 0x00D9,
    Uacute: 0x00DA,
    Ucirc: 0x00DB,
    Uuml: 0x00DC,
    Yacute: 0x00DD,
    THORN: 0x00DE,
    szlig: 0x00DF,
    agrave: 0x00E0,
    aacute: 0x00E1,
    acirc: 0x00E2,
    atilde: 0x00E3,
    auml: 0x00E4,
    aring: 0x00E5,
    aelig: 0x00E6,
    ccedil: 0x00E7,
    egrave: 0x00E8,
    eacute: 0x00E9,
    ecirc: 0x00EA,
    euml: 0x00EB,
    igrave: 0x00EC,
    iacute: 0x00ED,
    icirc: 0x00EE,
    iuml: 0x00EF,
    eth: 0x00F0,
    ntilde: 0x00F1,
    ograve: 0x00F2,
    oacute: 0x00F3,
    ocirc: 0x00F4,
    otilde: 0x00F5,
    ouml: 0x00F6,
    divide: 0x00F7,
    oslash: 0x00F8,
    ugrave: 0x00F9,
    uacute: 0x00FA,
    ucirc: 0x00FB,
    uuml: 0x00FC,
    yacute: 0x00FD,
    thorn: 0x00FE,
    yuml: 0x00FF,
    OElig: 0x0152,
    oelig: 0x0153,
    Scaron: 0x0160,
    scaron: 0x0161,
    Yuml: 0x0178,
    fnof: 0x0192,
    circ: 0x02C6,
    tilde: 0x02DC,
    Alpha: 0x0391,
    Beta: 0x0392,
    Gamma: 0x0393,
    Delta: 0x0394,
    Epsilon: 0x0395,
    Zeta: 0x0396,
    Eta: 0x0397,
    Theta: 0x0398,
    Iota: 0x0399,
    Kappa: 0x039A,
    Lambda: 0x039B,
    Mu: 0x039C,
    Nu: 0x039D,
    Xi: 0x039E,
    Omicron: 0x039F,
    Pi: 0x03A0,
    Rho: 0x03A1,
    Sigma: 0x03A3,
    Tau: 0x03A4,
    Upsilon: 0x03A5,
    Phi: 0x03A6,
    Chi: 0x03A7,
    Psi: 0x03A8,
    Omega: 0x03A9,
    alpha: 0x03B1,
    beta: 0x03B2,
    gamma: 0x03B3,
    delta: 0x03B4,
    epsilon: 0x03B5,
    zeta: 0x03B6,
    eta: 0x03B7,
    theta: 0x03B8,
    iota: 0x03B9,
    kappa: 0x03BA,
    lambda: 0x03BB,
    mu: 0x03BC,
    nu: 0x03BD,
    xi: 0x03BE,
    omicron: 0x03BF,
    pi: 0x03C0,
    rho: 0x03C1,
    sigmaf: 0x03C2,
    sigma: 0x03C3,
    tau: 0x03C4,
    upsilon: 0x03C5,
    phi: 0x03C6,
    chi: 0x03C7,
    psi: 0x03C8,
    omega: 0x03C9,
    thetasym: 0x03D1,
    upsih: 0x03D2,
    piv: 0x03D6,
    ensp: 0x2002,
    emsp: 0x2003,
    thinsp: 0x2009,
    zwnj: 0x200C,
    zwj: 0x200D,
    lrm: 0x200E,
    rlm: 0x200F,
    ndash: 0x2013,
    mdash: 0x2014,
    lsquo: 0x2018,
    rsquo: 0x2019,
    sbquo: 0x201A,
    ldquo: 0x201C,
    rdquo: 0x201D,
    bdquo: 0x201E,
    dagger: 0x2020,
    Dagger: 0x2021,
    bull: 0x2022,
    hellip: 0x2026,
    permil: 0x2030,
    prime: 0x2032,
    Prime: 0x2033,
    lsaquo: 0x2039,
    rsaquo: 0x203A,
    oline: 0x203E,
    frasl: 0x2044,
    euro: 0x20AC,
    image: 0x2111,
    weierp: 0x2118,
    real: 0x211C,
    trade: 0x2122,
    alefsym: 0x2135,
    larr: 0x2190,
    uarr: 0x2191,
    rarr: 0x2192,
    darr: 0x2193,
    harr: 0x2194,
    crarr: 0x21B5,
    lArr: 0x21D0,
    uArr: 0x21D1,
    rArr: 0x21D2,
    dArr: 0x21D3,
    hArr: 0x21D4,
    forall: 0x2200,
    part: 0x2202,
    exist: 0x2203,
    empty: 0x2205,
    nabla: 0x2207,
    isin: 0x2208,
    notin: 0x2209,
    ni: 0x220B,
    prod: 0x220F,
    sum: 0x2211,
    minus: 0x2212,
    lowast: 0x2217,
    radic: 0x221A,
    prop: 0x221D,
    infin: 0x221E,
    ang: 0x2220,
    and: 0x2227,
    or: 0x2228,
    cap: 0x2229,
    cup: 0x222A,
    int: 0x222B,
    there4: 0x2234,
    sim: 0x223C,
    cong: 0x2245,
    asymp: 0x2248,
    ne: 0x2260,
    equiv: 0x2261,
    le: 0x2264,
    ge: 0x2265,
    sub: 0x2282,
    sup: 0x2283,
    nsub: 0x2284,
    sube: 0x2286,
    supe: 0x2287,
    oplus: 0x2295,
    otimes: 0x2297,
    perp: 0x22A5,
    sdot: 0x22C5,
    lceil: 0x2308,
    rceil: 0x2309,
    lfloor: 0x230A,
    rfloor: 0x230B,
    lang: 0x2329,
    rang: 0x232A,
    loz: 0x25CA,
    spades: 0x2660,
    clubs: 0x2663,
    hearts: 0x2665,
    diams: 0x2666
};
//# sourceMappingURL=scanner.js.map