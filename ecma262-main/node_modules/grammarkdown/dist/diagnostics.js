"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatList = exports.formatString = exports.LineMap = exports.NullDiagnosticMessages = exports.DiagnosticMessages = exports.Diagnostics = void 0;
const core_1 = require("./core");
const types_1 = require("./types");
const tokens_1 = require("./tokens");
const lineOffsetMap_1 = require("./lineOffsetMap");
const diagnostics_generated_1 = require("./diagnostics.generated");
var diagnostics_generated_2 = require("./diagnostics.generated");
Object.defineProperty(exports, "Diagnostics", { enumerable: true, get: function () { return diagnostics_generated_2.Diagnostics; } });
/** {@docCategory Check} */
class DiagnosticMessages {
    constructor(lineOffsetMap) {
        this.lineOffsetMap = lineOffsetMap;
    }
    get size() {
        var _a, _b;
        return (_b = (_a = this.diagnostics) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    copyFrom(other) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (other === this || !(other.diagnostics || other.sourceFiles)) {
            return;
        }
        if (!this.diagnostics && !this.sourceFiles && !this.lineOffsetMap) {
            this.diagnostics = (_a = other.diagnostics) === null || _a === void 0 ? void 0 : _a.slice();
            this.diagnosticsArguments = (_b = other.diagnosticsArguments) === null || _b === void 0 ? void 0 : _b.slice();
            this.diagnosticsPos = (_c = other.diagnosticsPos) === null || _c === void 0 ? void 0 : _c.slice();
            this.diagnosticsLength = (_d = other.diagnosticsLength) === null || _d === void 0 ? void 0 : _d.slice();
            this.diagnosticsNode = (_e = other.diagnosticsNode) === null || _e === void 0 ? void 0 : _e.slice();
            this.sourceFiles = (_f = other.sourceFiles) === null || _f === void 0 ? void 0 : _f.slice();
            this.sourceFilesDiagnosticOffset = (_g = other.sourceFilesDiagnosticOffset) === null || _g === void 0 ? void 0 : _g.slice();
            if (other.lineOffsetMap) {
                this.lineOffsetMap = new lineOffsetMap_1.LineOffsetMap();
                this.lineOffsetMap.copyFrom(other.lineOffsetMap);
            }
            this.sortedAndDeduplicatedDiagnosticIndices = (_h = other.sortedAndDeduplicatedDiagnosticIndices) === null || _h === void 0 ? void 0 : _h.slice();
            this.detailedDiagnosticMessages = other.detailedDiagnosticMessages && new Map(other.detailedDiagnosticMessages);
            this.simpleDiagnosticMessages = other.simpleDiagnosticMessages && new Map(other.simpleDiagnosticMessages);
            return;
        }
        // copy source files
        if (other.sourceFiles && other.sourceFilesDiagnosticOffset) {
            (_j = this.sourceFiles) !== null && _j !== void 0 ? _j : (this.sourceFiles = []);
            (_k = this.sourceFilesDiagnosticOffset) !== null && _k !== void 0 ? _k : (this.sourceFilesDiagnosticOffset = []);
            const diagnosticOffset = this.size;
            const sourceFileOffset = this.sourceFiles.length;
            const continueFromExistingFile = sourceFileOffset > 0
                && other.sourceFiles[0] === this.sourceFiles[sourceFileOffset - 1];
            for (let i = continueFromExistingFile ? 1 : 0; i < other.sourceFiles.length; i++) {
                this.sourceFiles[sourceFileOffset + i] = other.sourceFiles[i];
                this.sourceFilesDiagnosticOffset[sourceFileOffset + i] = other.sourceFilesDiagnosticOffset[i] + diagnosticOffset;
            }
        }
        // copy line offsets
        if (other.lineOffsetMap) {
            (_l = this.lineOffsetMap) !== null && _l !== void 0 ? _l : (this.lineOffsetMap = new lineOffsetMap_1.LineOffsetMap());
            this.lineOffsetMap.copyFrom(other.lineOffsetMap);
        }
        // copy diagnostics
        if (other.diagnostics) {
            for (let i = 0; i < other.diagnostics.length; i++) {
                this.reportDiagnostic(other.diagnostics[i], other.diagnosticsArguments && other.diagnosticsArguments[i], other.diagnosticsPos && other.diagnosticsPos[i], other.diagnosticsLength && other.diagnosticsLength[i], other.diagnosticsNode && other.diagnosticsNode[i]);
            }
        }
    }
    setSourceFile(sourceFile) {
        var _a, _b;
        (_a = this.sourceFiles) !== null && _a !== void 0 ? _a : (this.sourceFiles = []);
        (_b = this.sourceFilesDiagnosticOffset) !== null && _b !== void 0 ? _b : (this.sourceFilesDiagnosticOffset = []);
        const sourceFileIndex = this.sourceFiles.length;
        if (sourceFileIndex > 0 && this.sourceFiles[sourceFileIndex - 1] === sourceFile) {
            return;
        }
        const diagnosticOffset = this.size;
        this.sourceFiles[sourceFileIndex] = sourceFile;
        this.sourceFilesDiagnosticOffset[sourceFileIndex] = diagnosticOffset;
    }
    report(pos, message, ...args) {
        this.reportDiagnostic(message, args, pos);
    }
    reportRange(pos, end, message, ...args) {
        this.reportDiagnostic(message, args, pos, Math.max(0, end - pos));
    }
    reportNode(sourceFile, node, message, ...args) {
        let pos;
        let length;
        if (node) {
            pos = (0, tokens_1.isTriviaKind)(node.kind) ? node.getFullStart() : node.getStart(sourceFile);
            length = (0, tokens_1.isTriviaKind)(node.kind) ? node.getFullWidth() : node.getWidth(sourceFile);
        }
        this.reportDiagnostic(message, args, pos, length, node);
    }
    count() {
        var _a, _b;
        return (_b = (_a = this.diagnostics) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    getMessage(diagnosticIndex, options = { detailed: true }) {
        var _a, _b, _c, _d;
        const diagnostic = (_a = this.diagnostics) === null || _a === void 0 ? void 0 : _a[diagnosticIndex];
        if (diagnostic) {
            const { detailed = true } = options;
            const diagnosticMessages = detailed
                ? (_b = this.detailedDiagnosticMessages) !== null && _b !== void 0 ? _b : (this.detailedDiagnosticMessages = new Map()) : (_c = this.simpleDiagnosticMessages) !== null && _c !== void 0 ? _c : (this.simpleDiagnosticMessages = new Map());
            const diagnosticMessage = diagnosticMessages.get(diagnosticIndex);
            if (diagnosticMessage !== undefined) {
                return diagnosticMessage;
            }
            const diagnosticArguments = (_d = this.diagnosticsArguments) === null || _d === void 0 ? void 0 : _d[diagnosticIndex];
            let text = "";
            if (detailed) {
                const sourceFile = this.getDiagnosticSourceFile(diagnosticIndex);
                const filename = this.getDiagnosticFilename(diagnosticIndex, options.raw);
                const position = this.getDiagnosticPosition(diagnosticIndex, options.raw);
                text += filename !== null && filename !== void 0 ? filename : (sourceFile ? sourceFile.filename : "");
                if (position) {
                    text += `(${position.line + 1},${position.character + 1})`;
                }
                else if (this.diagnosticsPos && diagnosticIndex in this.diagnosticsPos) {
                    const diagnosticPos = this.diagnosticsPos[diagnosticIndex];
                    if (sourceFile && sourceFile.lineMap) {
                        text += `(${sourceFile.lineMap.formatOffset(diagnosticPos)})`;
                    }
                    else {
                        text += `(${diagnosticPos})`;
                    }
                }
                text += ": ";
                text += diagnostic.warning ? "warning" : "error";
                text += " GM" + String(diagnostic.code) + ": ";
            }
            let message = diagnostic.message;
            if (diagnosticArguments) {
                message = formatString(message, diagnosticArguments);
            }
            text += message;
            diagnosticMessages.set(diagnosticIndex, text);
            return text;
        }
        return "";
    }
    getDiagnostic(diagnosticIndex) {
        var _a;
        return (_a = this.diagnostics) === null || _a === void 0 ? void 0 : _a[diagnosticIndex];
    }
    getDiagnosticInfos(options) {
        const result = [];
        if (this.diagnostics) {
            for (const diagnosticIndex of this.getSortedAndDeduplicatedDiagnosticIndices()) {
                const diagnosticInfo = this.getDiagnosticInfo(diagnosticIndex, options);
                if (diagnosticInfo) {
                    result.push(diagnosticInfo);
                }
            }
        }
        return result;
    }
    getDiagnosticInfosForSourceFile(sourceFile, options) {
        const result = [];
        if (this.diagnostics) {
            for (const diagnosticIndex of this.getSortedAndDeduplicatedDiagnosticIndices()) {
                if (this.getDiagnosticSourceFile(diagnosticIndex) === sourceFile) {
                    const diagnosticInfo = this.getDiagnosticInfo(diagnosticIndex, options);
                    if (diagnosticInfo) {
                        result.push(diagnosticInfo);
                    }
                }
            }
        }
        return result;
    }
    getDiagnosticInfo(diagnosticIndex, options = {}) {
        const diagnostic = this.getDiagnostic(diagnosticIndex);
        if (diagnostic) {
            const info = {
                diagnosticIndex,
                code: diagnostic.code,
                warning: diagnostic.warning || false,
                message: diagnostic.message,
                messageArguments: this.getDiagnosticArguments(diagnosticIndex),
                range: this.getDiagnosticRange(diagnosticIndex, options.raw),
                sourceFile: this.getDiagnosticSourceFile(diagnosticIndex),
                filename: this.getDiagnosticFilename(diagnosticIndex, options.raw),
                node: this.getDiagnosticNode(diagnosticIndex),
                pos: this.getDiagnosticPos(diagnosticIndex)
            };
            if (options.formatMessage) {
                info.formattedMessage = this.getMessage(diagnosticIndex, { detailed: options.detailedMessage });
            }
            return info;
        }
        return undefined;
    }
    getDiagnosticArguments(diagnosticIndex) {
        var _a;
        return (_a = this.diagnosticsArguments) === null || _a === void 0 ? void 0 : _a[diagnosticIndex];
    }
    getDiagnosticRange(diagnosticIndex, raw) {
        const diagnostic = this.getDiagnostic(diagnosticIndex);
        if (diagnostic) {
            const node = this.getDiagnosticNode(diagnosticIndex);
            const pos = this.getDiagnosticPos(diagnosticIndex);
            if (node || pos > -1) {
                const length = this.getDiagnosticLength(diagnosticIndex);
                const sourceFile = this.getDiagnosticSourceFile(diagnosticIndex);
                const range = getDiagnosticRange(node, pos, length, sourceFile);
                if (!raw && sourceFile && this.lineOffsetMap) {
                    return this.lineOffsetMap.getEffectiveRange(sourceFile, range);
                }
                return range;
            }
        }
        return undefined;
    }
    getDiagnosticPosition(diagnosticIndex, raw) {
        const diagnostic = this.getDiagnostic(diagnosticIndex);
        const sourceFile = this.getDiagnosticSourceFile(diagnosticIndex);
        const node = this.getDiagnosticNode(diagnosticIndex);
        const pos = this.getDiagnosticPos(diagnosticIndex);
        if (diagnostic && node || pos > -1) {
            const position = positionOfStart(node, pos, sourceFile);
            if (!raw && sourceFile && this.lineOffsetMap) {
                return this.lineOffsetMap.getEffectivePosition(sourceFile, position);
            }
            return position;
        }
        return undefined;
    }
    getDiagnosticNode(diagnosticIndex) {
        var _a;
        return (_a = this.diagnosticsNode) === null || _a === void 0 ? void 0 : _a[diagnosticIndex];
    }
    getDiagnosticSourceFile(diagnosticIndex) {
        if (this.sourceFiles && this.sourceFilesDiagnosticOffset) {
            let offset = (0, core_1.binarySearch)(this.sourceFilesDiagnosticOffset, diagnosticIndex);
            if (offset < 0) {
                offset = (~offset) - 1;
            }
            while (offset + 1 < this.sourceFiles.length && this.sourceFilesDiagnosticOffset[offset + 1] === diagnosticIndex) {
                offset++;
            }
            return this.sourceFiles[offset];
        }
        return undefined;
    }
    getDiagnosticFilename(diagnosticIndex, raw) {
        const sourceFile = this.getDiagnosticSourceFile(diagnosticIndex);
        if (sourceFile) {
            if (!raw && this.lineOffsetMap) {
                const pos = this.getDiagnosticPos(diagnosticIndex);
                if (pos > -1) {
                    return this.lineOffsetMap.getEffectiveFilenameAtPosition(sourceFile, sourceFile.lineMap.positionAt(pos));
                }
            }
            return sourceFile.filename;
        }
        return undefined;
    }
    forEach(callback) {
        if (this.diagnostics) {
            for (const diagnosticIndex of this.getSortedAndDeduplicatedDiagnosticIndices()) {
                callback(this.getMessage(diagnosticIndex, { detailed: true }), diagnosticIndex);
            }
        }
    }
    *values() {
        for (let i = 0; i < this.size; i++) {
            yield this.getDiagnosticInfo(i);
        }
    }
    [Symbol.iterator]() {
        return this.values();
    }
    getSortedAndDeduplicatedDiagnosticIndices() {
        if (!this.sortedAndDeduplicatedDiagnosticIndices) {
            let indices = [];
            if (this.diagnostics) {
                for (let diagnosticIndex = 0, l = this.diagnostics.length; diagnosticIndex < l; diagnosticIndex++) {
                    indices[diagnosticIndex] = diagnosticIndex;
                }
            }
            indices = this.sortDiagnostics(indices);
            indices = this.deduplicateDiagnostics(indices);
            this.sortedAndDeduplicatedDiagnosticIndices = indices;
        }
        return this.sortedAndDeduplicatedDiagnosticIndices;
    }
    sortDiagnostics(indices) {
        return indices.sort((left, right) => this.compareDiagnostics(left, right));
    }
    compareDiagnostics(diagnosticIndex1, diagnosticIndex2) {
        const file1 = this.getDiagnosticSourceFile(diagnosticIndex1);
        const file2 = this.getDiagnosticSourceFile(diagnosticIndex2);
        return (0, core_1.compareStrings)(file1 && file1.filename, file2 && file2.filename)
            || (0, core_1.compare)(this.getDiagnosticPos(diagnosticIndex1), this.getDiagnosticPos(diagnosticIndex2))
            || (0, core_1.compare)(this.getDiagnosticLength(diagnosticIndex1), this.getDiagnosticLength(diagnosticIndex2))
            || (0, core_1.compare)(this.getDiagnosticErrorLevel(diagnosticIndex1), this.getDiagnosticErrorLevel(diagnosticIndex2))
            || (0, core_1.compare)(this.getDiagnosticCode(diagnosticIndex1), this.getDiagnosticCode(diagnosticIndex2))
            || (0, core_1.compareStrings)(this.getMessage(diagnosticIndex1), this.getMessage(diagnosticIndex2), /*ignoreCase*/ true);
    }
    deduplicateDiagnostics(indices) {
        if (indices.length <= 1) {
            return indices;
        }
        const firstDiagnosticIndex = indices[0];
        const newIndices = [firstDiagnosticIndex];
        let previousDiagnosticIndex = firstDiagnosticIndex;
        for (let i = 1; i < indices.length; i++) {
            const diagnosticIndex = indices[i];
            if (this.compareDiagnostics(previousDiagnosticIndex, diagnosticIndex)) {
                newIndices.push(diagnosticIndex);
                previousDiagnosticIndex = diagnosticIndex;
            }
        }
        return newIndices;
    }
    getDiagnosticPos(diagnosticIndex) {
        var _a, _b;
        return (_b = (_a = this.diagnosticsPos) === null || _a === void 0 ? void 0 : _a[diagnosticIndex]) !== null && _b !== void 0 ? _b : -1;
    }
    getDiagnosticLength(diagnosticIndex) {
        var _a, _b;
        return (_b = (_a = this.diagnosticsLength) === null || _a === void 0 ? void 0 : _a[diagnosticIndex]) !== null && _b !== void 0 ? _b : 0;
    }
    getDiagnosticCode(diagnosticIndex) {
        var _a, _b;
        return (_b = (_a = this.getDiagnostic(diagnosticIndex)) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : 0;
    }
    getDiagnosticErrorLevel(diagnosticIndex) {
        var _a;
        return ((_a = this.getDiagnostic(diagnosticIndex)) === null || _a === void 0 ? void 0 : _a.warning) ? 0 : 1;
    }
    reportDiagnostic(message, args, pos, length, node) {
        var _a, _b, _c, _d, _e;
        this.sortedAndDeduplicatedDiagnosticIndices = undefined;
        (_a = this.diagnostics) !== null && _a !== void 0 ? _a : (this.diagnostics = []);
        const diagnosticIndex = this.diagnostics.length;
        this.diagnostics[diagnosticIndex] = message;
        if (args && args.length > 0) {
            (_b = this.diagnosticsArguments) !== null && _b !== void 0 ? _b : (this.diagnosticsArguments = []);
            this.diagnosticsArguments[diagnosticIndex] = args;
        }
        if (pos !== undefined) {
            (_c = this.diagnosticsPos) !== null && _c !== void 0 ? _c : (this.diagnosticsPos = []);
            this.diagnosticsPos[diagnosticIndex] = pos;
        }
        if (length !== undefined) {
            (_d = this.diagnosticsLength) !== null && _d !== void 0 ? _d : (this.diagnosticsLength = []);
            this.diagnosticsLength[diagnosticIndex] = length;
        }
        if (node !== undefined) {
            (_e = this.diagnosticsNode) !== null && _e !== void 0 ? _e : (this.diagnosticsNode = []);
            this.diagnosticsNode[diagnosticIndex] = node;
        }
    }
}
exports.DiagnosticMessages = DiagnosticMessages;
/** {@docCategory Check} */
class NullDiagnosticMessages extends DiagnosticMessages {
    static get instance() {
        var _a;
        return (_a = this._instance) !== null && _a !== void 0 ? _a : (this._instance = new NullDiagnosticMessages());
    }
    get size() { return 0; }
    copyFrom(other) { }
    setSourceFile(sourceFile) { }
    report(pos, message, ...args) { }
    reportNode(sourceFile, node, message, ...args) { }
}
exports.NullDiagnosticMessages = NullDiagnosticMessages;
/** {@docCategory Check} */
class LineMap {
    constructor(text) {
        this.text = text;
    }
    get lineCount() {
        this.computeLineStarts();
        return this.lineStarts.length;
    }
    formatOffset(pos) {
        this.computeLineStarts();
        var lineNumber = (0, core_1.binarySearch)(this.lineStarts, pos);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the negative value of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2
            lineNumber = (~lineNumber) - 1;
        }
        return `${lineNumber + 1},${pos - this.lineStarts[lineNumber] + 1}`;
    }
    offsetAt(position) {
        this.computeLineStarts();
        if (position.line < 0)
            return 0;
        if (position.line >= this.lineStarts.length)
            return this.text.length;
        const linePos = this.lineStarts[position.line];
        const pos = linePos + position.character;
        const lineEnd = position.line + 1 < this.lineStarts.length
            ? this.lineStarts[position.line + 1]
            : this.text.length;
        return pos < linePos ? linePos : pos > lineEnd ? lineEnd : pos;
    }
    positionAt(offset) {
        this.computeLineStarts();
        let lineNumber = (0, core_1.binarySearch)(this.lineStarts, offset);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the negative value of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2
            lineNumber = (~lineNumber) - 1;
        }
        return { line: lineNumber, character: offset - this.lineStarts[lineNumber] };
    }
    getLine(line) {
        this.computeLineStarts();
        if (line < 0 || line >= this.lineStarts.length) {
            throw new RangeError("Argument out of range: line");
        }
        const pos = this.lineStarts[line];
        let end;
        let lineTerminatorLength = 0;
        if (line + 1 < this.lineStarts.length) {
            end = this.lineStarts[line + 1];
            if (end - 1 >= pos) {
                let ch = this.text.charCodeAt(end - 1);
                switch (ch) {
                    case 10 /* LineFeed */:
                        if (end - 2 >= pos && this.text.charCodeAt(end - 2) === 13 /* CarriageReturn */) {
                            lineTerminatorLength = 2;
                            break;
                        }
                    // fall through
                    case 13 /* CarriageReturn */:
                    case 8232 /* LineSeparator */:
                    case 8233 /* ParagraphSeparator */:
                    case 133 /* NextLine */:
                        lineTerminatorLength = 1;
                        break;
                }
            }
        }
        else {
            end = this.text.length;
        }
        const text = this.text.slice(pos, end - lineTerminatorLength);
        const range = types_1.Range.create(types_1.Position.create(line, 0), types_1.Position.create(line, end - pos - lineTerminatorLength));
        const rangeIncludingLineTerminator = types_1.Range.create(types_1.Position.create(line, 0), types_1.Position.create(line, end - pos));
        return { line, text, range, rangeIncludingLineTerminator };
    }
    computeLineStarts() {
        if (this.lineStarts) {
            return;
        }
        const lineStarts = [];
        let lineStart = 0;
        for (var pos = 0; pos < this.text.length;) {
            var ch = this.text.charCodeAt(pos++);
            switch (ch) {
                case 13 /* CarriageReturn */:
                    if (this.text.charCodeAt(pos) === 10 /* LineFeed */) {
                        pos++;
                    }
                // fall through
                case 10 /* LineFeed */:
                case 8232 /* LineSeparator */:
                case 8233 /* ParagraphSeparator */:
                case 133 /* NextLine */:
                    lineStarts.push(lineStart);
                    lineStart = pos;
                    break;
            }
        }
        lineStarts.push(lineStart);
        this.lineStarts = lineStarts;
    }
}
exports.LineMap = LineMap;
function getDiagnosticRange(diagnosticNode, diagnosticPos, diagnosticLength, sourceFile) {
    return {
        start: positionOfStart(diagnosticNode, diagnosticPos, sourceFile),
        end: positionOfEnd(diagnosticNode, diagnosticPos, diagnosticLength, sourceFile)
    };
}
function positionOfStart(diagnosticNode, diagnosticPos, sourceFile) {
    return positionAt(diagnosticNode ? (0, tokens_1.isHtmlTriviaKind)(diagnosticNode.kind) ? diagnosticNode.getFullStart() : diagnosticNode.getStart(sourceFile) : diagnosticPos, sourceFile);
}
function positionOfEnd(diagnosticNode, diagnosticPos, diagnosticLength, sourceFile) {
    return positionAt(diagnosticNode ? diagnosticNode.getEnd() : diagnosticPos + diagnosticLength, sourceFile);
}
function positionAt(diagnosticPos, sourceFile) {
    return (sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.lineMap)
        ? sourceFile.lineMap.positionAt(diagnosticPos)
        : { line: 0, character: diagnosticPos };
}
function formatString(format) {
    let args = Array.prototype.slice.call(arguments, 1);
    if (args.length === 1 && args[0] instanceof Array) {
        args = args[0];
    }
    return format.replace(/{(\d+)}/g, (_, index) => args[index]);
}
exports.formatString = formatString;
function formatList(tokens) {
    if (tokens.length <= 0) {
        return "";
    }
    else if (tokens.length === 1) {
        return (0, tokens_1.tokenToString)(tokens[0], /*quoted*/ true);
    }
    else if (tokens.length === 2) {
        return formatString(diagnostics_generated_1.Diagnostics._0_or_1_.message, (0, tokens_1.tokenToString)(tokens[0], /*quoted*/ true), (0, tokens_1.tokenToString)(tokens[1], /*quoted*/ true));
    }
    else {
        let text = "";
        for (var i = 0; i < tokens.length - 1; i++) {
            if (i > 0) {
                text += " ";
            }
            text += (0, tokens_1.tokenToString)(tokens[i], /*quoted*/ true);
            text += ",";
        }
        return formatString(diagnostics_generated_1.Diagnostics._0_or_1_.message, text, (0, tokens_1.tokenToString)(tokens[tokens.length - 1], /*quoted*/ true));
    }
}
exports.formatList = formatList;
//# sourceMappingURL=diagnostics.js.map