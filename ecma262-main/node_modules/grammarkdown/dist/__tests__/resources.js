"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGrammarFiles = exports.TestFileHost = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const node_1 = require("../hosts/node");
let grammarFiles;
class TestFileHost extends node_1.NodeAsyncHost {
    constructor(file, options) {
        super(options);
        this.file = file;
    }
    isTestFile(file) {
        return file === this.file.path || file === this.file.relative;
    }
    normalizeFile(file) {
        return this.isTestFile(file) ? file : super.normalizeFile(file);
    }
    resolveFile(file, referer) {
        if (referer === this.file.relative)
            referer = this.file.path;
        return this.isTestFile(file) ? file : super.resolveFile(file, referer);
    }
    async readFile(file, cancelable) {
        return this.isTestFile(file) ? this.file.content : super.readFile(file, cancelable);
    }
}
exports.TestFileHost = TestFileHost;
function getGrammarFiles() {
    if (!grammarFiles) {
        grammarFiles = [];
        collectFilesInPath("../../src/tests/resources", "", grammarFiles);
    }
    return grammarFiles;
}
exports.getGrammarFiles = getGrammarFiles;
const nonOptionLineRegExp = /(^|\r?\n)(?!\/\/\s*@)/;
function getOffsetToFirstNonOptionLine(text) {
    const match = nonOptionLineRegExp.exec(text);
    return match ? match.index + match[1].length : text.length;
}
const optionLineRegExp = /^\/\/\s*@\s*(\w+)\s*:\s*(.*?)\s*$/gm;
function parseTestFile(content) {
    const offset = getOffsetToFirstNonOptionLine(content);
    const optionContent = content.slice(0, offset);
    const options = {};
    for (let match = optionLineRegExp.exec(optionContent); match; match = optionLineRegExp.exec(optionContent)) {
        options[match[1]] = match[2];
    }
    const nonOptionContent = content.slice(offset);
    return { options, content: nonOptionContent };
}
function collectFilesInPath(path, relative, output) {
    path = (0, path_1.resolve)(__dirname, path);
    if ((0, fs_1.existsSync)(path)) {
        for (let file of (0, fs_1.readdirSync)(path)) {
            const filePath = (0, path_1.resolve)(path, file);
            const fileRelative = relative ? path_1.posix.join(relative, file) : file;
            const stats = (0, fs_1.statSync)(filePath);
            if (stats.isFile()) {
                if ((0, path_1.extname)(file) === ".grammar") {
                    const { options, content } = parseTestFile((0, fs_1.readFileSync)(filePath, "utf8"));
                    output.push({ basename: file, path: filePath, relative: fileRelative, content, options });
                }
            }
            else if (stats.isDirectory()) {
                collectFilesInPath(filePath, fileRelative, output);
            }
        }
    }
}
//# sourceMappingURL=resources.js.map