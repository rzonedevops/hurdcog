"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareBaseline = exports.compareBaselines = exports.writeBaseline = exports.writeOutput = exports.writeNodes = exports.writeDiagnostics = exports.writeTokens = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const tokens_1 = require("../tokens");
const diagnostics_1 = require("../diagnostics");
const nodes_1 = require("../nodes");
const stringwriter_1 = require("../stringwriter");
const types_1 = require("../types");
function writeTokens(test, scanner, lineMap, baselines) {
    let text = `/// ${test}:\r\n`;
    let token;
    do {
        token = scanner.scan();
        let message = `SyntaxKind[${(0, tokens_1.formatKind)(token)}](${lineMap.formatOffset(scanner.getTokenPos())}): `;
        switch (token) {
            case tokens_1.SyntaxKind.ProseFull:
            case tokens_1.SyntaxKind.ProseHead:
            case tokens_1.SyntaxKind.ProseMiddle:
            case tokens_1.SyntaxKind.ProseTail:
                message += scanner.getTokenValue();
                break;
            case tokens_1.SyntaxKind.Identifier:
                message += `${scanner.getTokenValue()}`;
                break;
            case tokens_1.SyntaxKind.TerminalLiteral:
                message += `\`${scanner.getTokenValue()}\``;
                break;
            case tokens_1.SyntaxKind.StringLiteral:
                message += `"${scanner.getTokenValue()}"`;
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                message += scanner.getTokenText();
                break;
            default:
                message += `${(0, tokens_1.tokenToString)(token)}`;
        }
        text += message + "\n";
    } while (token !== tokens_1.SyntaxKind.EndOfFileToken);
    return writeBaseline(test + ".tokens", text, baselines);
}
exports.writeTokens = writeTokens;
function writeDiagnostics(test, diagnostics, baselines) {
    class DiagnosticWriter {
        constructor() {
            this.writer = new stringwriter_1.StringWriter("\n");
            this.line = 0;
            this.count = 0;
        }
        writeSource(sourceFile, endLine = sourceFile.lineMap.lineCount) {
            while (this.line < endLine && this.line < sourceFile.lineMap.lineCount) {
                const { text } = sourceFile.lineMap.getLine(this.line);
                this.writer.writeln(`    ${text}`);
                this.line++;
            }
        }
        writeMarker(sourceFile, range) {
            const pos = range.start.character;
            const end = range.end.line === range.start.line ? range.end.character :
                sourceFile.lineMap.offsetAt(types_1.Position.create(range.start.line + 1, -1));
            const blanks = " ".repeat(pos);
            const markers = "~".repeat(Math.max(1, end - pos));
            const continuation = range.end.line > range.start.line ? ">" : "";
            this.writer.indent();
            this.writer.writeln(blanks + markers + continuation);
            this.writer.dedent();
        }
        writeDiagnostic(diagnostic) {
            if (diagnostic.sourceFile && diagnostic.range) {
                this.writeSource(diagnostic.sourceFile, diagnostic.range.start.line + 1);
                this.writeMarker(diagnostic.sourceFile, diagnostic.range);
            }
            const category = diagnostic.warning ? "warning" : "error";
            const code = `GM${diagnostic.code}`;
            const message = diagnostic.messageArguments ? (0, diagnostics_1.formatString)(diagnostic.message, diagnostic.messageArguments) : diagnostic.message;
            const text = `!!! ${category} ${code}: ${message}`;
            this.writer.writeln(text);
            this.count++;
        }
    }
    const writer = new stringwriter_1.StringWriter("\n");
    const fileDiagnostics = new Map();
    let globalDiagnostics;
    diagnostics.forEach((message, diagnosticIndex) => {
        if (!writer.size) {
            writer.writeln(`/// ${test}:`);
        }
        writer.writeln(message);
        const diagnostic = diagnostics.getDiagnosticInfo(diagnosticIndex, { raw: true });
        if (!diagnostic)
            return;
        let diagnosticWriter;
        if (!diagnostic.sourceFile) {
            globalDiagnostics !== null && globalDiagnostics !== void 0 ? globalDiagnostics : (globalDiagnostics = new DiagnosticWriter());
            diagnosticWriter = globalDiagnostics;
        }
        else {
            diagnosticWriter = fileDiagnostics.get(diagnostic.sourceFile);
            if (!diagnosticWriter)
                fileDiagnostics.set(diagnostic.sourceFile, diagnosticWriter = new DiagnosticWriter());
        }
        diagnosticWriter.writeDiagnostic(diagnostic);
    });
    if (globalDiagnostics) {
        writer.writeBlank();
        writer.writeln(`/// [global] ${globalDiagnostics.count} ${globalDiagnostics.count === 1 ? "error" : "errors"}`);
        writer.writeln(globalDiagnostics.writer.toString().trimEnd());
    }
    for (const [sourceFile, diagnosticWriter] of fileDiagnostics) {
        diagnosticWriter.writeSource(sourceFile);
        writer.writeBlank();
        writer.writeln(`/// [${sourceFile.filename}] ${diagnosticWriter.count} ${diagnosticWriter.count === 1 ? "error" : "errors"}`);
        writer.writeln(diagnosticWriter.writer.toString().trimEnd());
    }
    return writeBaseline(test + ".diagnostics", writer.size ? writer.toString() : undefined, baselines);
}
exports.writeDiagnostics = writeDiagnostics;
function writeNodes(test, sourceFile, baselines) {
    let text = `/// ${test}:\r\n`;
    let indents = ["", "  "];
    let indentDepth = 0;
    printNode(sourceFile);
    return writeBaseline(test + ".nodes", text, baselines);
    function getIndent(depth) {
        if (depth >= indents.length) {
            indents[depth] = getIndent(depth - 1) + indents[1];
        }
        return indents[depth];
    }
    function printNode(node) {
        var _a;
        text += getIndent(indentDepth) + formatNode(node, sourceFile) + "\n";
        indentDepth++;
        let hasHtmlTrivia = false;
        if (node.detachedTrivia) {
            for (const child of node.detachedTrivia) {
                if (child instanceof nodes_1.HtmlTriviaBase) {
                    if (!hasHtmlTrivia) {
                        hasHtmlTrivia = true;
                        text += getIndent(indentDepth) + "[detachedTrivia]\n";
                    }
                    indentDepth++;
                    printNode(child);
                    indentDepth--;
                }
            }
            hasHtmlTrivia = false;
        }
        if (node.leadingTrivia) {
            for (const child of node.leadingTrivia) {
                if (child instanceof nodes_1.HtmlTriviaBase) {
                    if (!hasHtmlTrivia) {
                        hasHtmlTrivia = true;
                        text += getIndent(indentDepth) + "[leadingTrivia]\n";
                    }
                    indentDepth++;
                    printNode(child);
                    indentDepth--;
                }
            }
            hasHtmlTrivia = false;
        }
        for (const child of node.children()) {
            printNode(child);
        }
        if ((_a = node.trailingTrivia) === null || _a === void 0 ? void 0 : _a.length) {
            for (const child of node.trailingTrivia) {
                if (child instanceof nodes_1.HtmlTriviaBase) {
                    if (!hasHtmlTrivia) {
                        hasHtmlTrivia = true;
                        text += getIndent(indentDepth) + "[trailingTrivia]\n";
                    }
                    indentDepth++;
                    printNode(child);
                    indentDepth--;
                }
            }
        }
        indentDepth--;
    }
}
exports.writeNodes = writeNodes;
function writeOutput(test, extname, text, baselines) {
    return writeBaseline(test + extname, text, baselines);
}
exports.writeOutput = writeOutput;
function writeBaseline(file, text, baselines) {
    if (baselines) {
        baselines.push(file);
    }
    let { localFile } = resolveBaseline(file);
    if (text === undefined) {
        if ((0, fs_1.existsSync)(localFile)) {
            (0, fs_1.unlinkSync)(localFile);
        }
    }
    else {
        (0, fs_1.writeFileSync)(localFile, text, { encoding: "utf8" });
    }
    return file;
}
exports.writeBaseline = writeBaseline;
function compareBaselines(baselines) {
    for (let file of baselines) {
        let { localFile, referenceFile } = resolveBaseline(file);
        let localText = (0, fs_1.existsSync)(localFile) ? (0, fs_1.readFileSync)(localFile, "utf8") : undefined;
        let referenceText = (0, fs_1.existsSync)(referenceFile) ? (0, fs_1.readFileSync)(referenceFile, "utf8") : undefined;
        if (localText !== referenceText) {
            throw new Error(`The baseline file '${file}' has changed.`);
        }
    }
}
exports.compareBaselines = compareBaselines;
function compareBaseline(file) {
    let { localFile, referenceFile } = resolveBaseline(file);
    let localText = (0, fs_1.existsSync)(localFile) ? (0, fs_1.readFileSync)(localFile, "utf8") : undefined;
    let referenceText = (0, fs_1.existsSync)(referenceFile) ? (0, fs_1.readFileSync)(referenceFile, "utf8") : undefined;
    if (localText !== referenceText) {
        throw new Error(`The baseline file '${file}' has changed.`);
    }
}
exports.compareBaseline = compareBaseline;
function resolveBaseline(file) {
    let baselinePath = (0, path_1.resolve)(__dirname, "../../baselines");
    let localPath = (0, path_1.resolve)(baselinePath, "local");
    let localFile = (0, path_1.resolve)(localPath, file);
    let referencePath = (0, path_1.resolve)(baselinePath, "reference");
    let referenceFile = (0, path_1.resolve)(referencePath, file);
    try {
        (0, fs_1.mkdirSync)((0, path_1.dirname)(localFile), { recursive: true });
    }
    catch (_a) { }
    try {
        (0, fs_1.mkdirSync)((0, path_1.dirname)(referenceFile), { recursive: true });
    }
    catch (_b) { }
    return { localFile, referenceFile };
}
function formatNode(node, sourceFile) {
    var text = `(${sourceFile.lineMap.formatOffset(node.getStart(sourceFile))})`;
    text += `SyntaxKind[${(0, tokens_1.formatKind)(node.kind)}]`;
    switch (node.kind) {
        case tokens_1.SyntaxKind.Identifier:
        case tokens_1.SyntaxKind.TerminalLiteral:
        case tokens_1.SyntaxKind.ProseFull:
        case tokens_1.SyntaxKind.ProseHead:
        case tokens_1.SyntaxKind.ProseMiddle:
        case tokens_1.SyntaxKind.ProseTail:
        case tokens_1.SyntaxKind.StringLiteral:
            text += `(text = "${node.text}")`;
            break;
        case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
            text += `(text = ${sourceFile.text.slice(node.getStart(sourceFile), node.end)})`;
            break;
        case tokens_1.SyntaxKind.SourceFile:
            text += `(filename = "${(0, path_1.basename)(node.filename)}")`;
            break;
        case tokens_1.SyntaxKind.HtmlOpenTagTrivia:
        case tokens_1.SyntaxKind.HtmlCloseTagTrivia:
            text += `(tagName = "${node.tagName}")`;
            break;
    }
    switch (node.kind) {
        case tokens_1.SyntaxKind.Terminal:
        case tokens_1.SyntaxKind.Nonterminal:
            if (node.questionToken) {
                text += "?";
            }
            break;
        case tokens_1.SyntaxKind.Argument:
            if (node.operatorToken) {
                switch (node.operatorToken.kind) {
                    case tokens_1.SyntaxKind.QuestionToken:
                        text += "?";
                        break;
                    case tokens_1.SyntaxKind.TildeToken:
                        text += "~";
                        break;
                    case tokens_1.SyntaxKind.PlusToken:
                        text += "+";
                        break;
                }
            }
            break;
    }
    return text;
}
//# sourceMappingURL=diff.js.map