"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
require("./matchers");
const parser_1 = require("../parser");
const navigator_1 = require("../navigator");
const tokens_1 = require("../tokens");
const navigatorUtils_1 = require("./navigatorUtils");
describe("Navigator", () => {
    const es6GrammarText = `
// A.1 - Lexical Grammar

SourceCharacter ::
	> any Unicode code point

InputElementDiv ::
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	DivPunctuator
	RightBracePunctuator

InputElementRegExp ::
	WhiteSpace
	LineTerminator
	Comment
	CommonToken
	RightBracePunctuator
	RegularExpressionLiteral

// ...

ExportSpecifier :
	IdentifierName
	IdentifierName \`as\` IdentifierName
`.trim();
    it("initial state", () => {
        const { sourceFile, navigator } = getNavigator();
        expect(navigator.getRoot()).toStrictEqual(sourceFile);
        expect(navigator.getNode()).toStrictEqual(sourceFile);
        expect(navigator.getParent()).toStrictEqual(undefined);
        expect(navigator.getKind()).toStrictEqual(tokens_1.SyntaxKind.SourceFile);
        expect(navigator.getDepth()).toStrictEqual(0);
        expect(navigator.getName()).toStrictEqual(undefined);
        expect(navigator.getOffset()).toStrictEqual(0);
        expect(navigator.getArray()).toStrictEqual(undefined);
        expect(navigator.isArray()).toStrictEqual(false);
        expect(navigator.hasChildren()).toStrictEqual(true);
    });
    it("moveToFirstChild", () => {
        const { sourceFile, navigator } = getNavigator();
        const moved = navigator.moveToFirstChild();
        expect(moved).toEqual(true);
        expect(navigator.getRoot()).toStrictEqual(sourceFile);
        expect(navigator.getNode()).toStrictEqual(sourceFile.elements[0]);
        expect(navigator.getParent()).toStrictEqual(sourceFile);
        expect(navigator.getKind()).toStrictEqual(tokens_1.SyntaxKind.Production);
        expect(navigator.getDepth()).toStrictEqual(1);
        expect(navigator.getName()).toStrictEqual("elements");
        expect(navigator.getOffset()).toStrictEqual(0);
        expect(navigator.getArray()).toBeDefined();
        expect(navigator.isArray()).toStrictEqual(true);
        expect(navigator.hasChildren()).toStrictEqual(true);
    });
    it("moveToLastChild", () => {
        const { sourceFile, navigator } = getNavigator();
        const moved = navigator.moveToLastChild();
        expect(moved).toEqual(true);
        expect(navigator.getRoot()).toStrictEqual(sourceFile);
        expect(navigator.getNode()).toStrictEqual(sourceFile.elements[sourceFile.elements.length - 1]);
        expect(navigator.getParent()).toStrictEqual(sourceFile);
        expect(navigator.getKind()).toStrictEqual(tokens_1.SyntaxKind.Production);
        expect(navigator.getDepth()).toStrictEqual(1);
        expect(navigator.getName()).toStrictEqual("elements");
        expect(navigator.getOffset()).toStrictEqual(sourceFile.elements.length - 1);
        expect(navigator.getArray()).toBeDefined();
        expect(navigator.isArray()).toStrictEqual(true);
        expect(navigator.hasChildren()).toStrictEqual(true);
    });
    it("moveToNextSibling (in array)", () => {
        const { sourceFile, navigator } = getNavigator();
        navigator.moveToFirstChild();
        const moved = navigator.moveToNextSibling();
        expect(moved).toEqual(true);
        expect(navigator.getRoot()).toStrictEqual(sourceFile);
        expect(navigator.getNode()).toStrictEqual(sourceFile.elements[1]);
        expect(navigator.getParent()).toStrictEqual(sourceFile);
        expect(navigator.getKind()).toStrictEqual(tokens_1.SyntaxKind.Production);
        expect(navigator.getDepth()).toStrictEqual(1);
        expect(navigator.getName()).toStrictEqual("elements");
        expect(navigator.getOffset()).toStrictEqual(1);
        expect(navigator.getArray()).toBeDefined();
        expect(navigator.isArray()).toStrictEqual(true);
        expect(navigator.hasChildren()).toStrictEqual(true);
    });
    it("moveToNextSibling (in object)", () => {
        const { navigator } = getNavigator();
        navigator.moveToFirstChild();
        const movedToFirstChild = navigator.moveToFirstChild();
        const production = navigator.getParent();
        const firstChild = navigator.getNode();
        const firstChildName = navigator.getName();
        const movedToSibling = navigator.moveToNextSibling();
        const nextSibling = navigator.getNode();
        const nextSiblingName = navigator.getName();
        expect(movedToFirstChild).toBe(true);
        expect(movedToSibling).toBe(true);
        expect(production.kind).toBe(tokens_1.SyntaxKind.Production);
        expect(firstChildName).toBe("name");
        expect(firstChild).toBe(production.name);
        expect(nextSiblingName).toBe("colonToken");
        expect(nextSibling).toBe(production.colonToken);
    });
    it("moveTopPreviousSibling (in array)", () => {
        const { sourceFile, navigator } = getNavigator();
        navigator.moveToLastChild();
        const moved = navigator.moveToPreviousSibling();
        expect(moved).toEqual(true);
        expect(navigator.getRoot()).toStrictEqual(sourceFile);
        expect(navigator.getNode()).toStrictEqual(sourceFile.elements[sourceFile.elements.length - 2]);
        expect(navigator.getParent()).toStrictEqual(sourceFile);
        expect(navigator.getKind()).toStrictEqual(tokens_1.SyntaxKind.Production);
        expect(navigator.getDepth()).toStrictEqual(1);
        expect(navigator.getName()).toStrictEqual("elements");
        expect(navigator.getOffset()).toStrictEqual(sourceFile.elements.length - 2);
        expect(navigator.getArray()).toBeDefined();
        expect(navigator.isArray()).toStrictEqual(true);
        expect(navigator.hasChildren()).toStrictEqual(true);
    });
    it("moveTopPreviousSibling (in object)", () => {
        const { navigator } = getNavigator();
        navigator.moveToFirstChild();
        const movedToLastChild = navigator.moveToLastChild();
        const production = navigator.getParent();
        const lastChild = navigator.getNode();
        const lastChildName = navigator.getName();
        const movedToSibling = navigator.moveToPreviousSibling();
        const previousSibling = navigator.getNode();
        const previousSiblingName = navigator.getName();
        expect(movedToLastChild).toBe(true);
        expect(movedToSibling).toBe(true);
        expect(production.kind).toBe(tokens_1.SyntaxKind.Production);
        expect(lastChildName).toBe("body");
        expect(lastChild).toBe(production.body);
        expect(previousSiblingName).toBe("colonToken");
        expect(previousSibling).toBe(production.colonToken);
    });
    it("moveToPosition", () => {
        const { sourceFile, navigator } = getNavigator();
        const moved = navigator.moveToPosition({ line: 14, character: 9 });
        expect(moved).toEqual(true);
        expect(navigator.getKind()).toStrictEqual(tokens_1.SyntaxKind.Identifier);
        expect(navigator.getName()).toStrictEqual("name");
        const production = sourceFile.elements[2];
        const list = production.body;
        const rhs = (list.elements && list.elements[0]);
        const symbol = rhs.head.symbol;
        expect(navigator.getNode()).toStrictEqual(symbol.name);
    });
    describe("moveToTouchingToken", () => {
        it("at start", () => {
            const { navigator } = getNavigator();
            expect(navigator.moveToTouchingToken({ line: 6, character: 1 })).toBe(true);
            expect(navigator.getKind()).toBeSyntaxKind(tokens_1.SyntaxKind.Identifier);
            expect(navigator.getTextContent()).toBe("WhiteSpace");
        });
        it("in leading trivia", () => {
            const { navigator } = getNavigator();
            expect(navigator.moveToTouchingToken({ line: 6, character: 0 })).toBe(true);
            expect(navigator.getKind()).toBeSyntaxKind(tokens_1.SyntaxKind.ColonColonToken);
        });
        it("in middle", () => {
            const { navigator } = getNavigator();
            expect(navigator.moveToTouchingToken({ line: 6, character: 5 })).toBe(true);
            expect(navigator.getKind()).toBeSyntaxKind(tokens_1.SyntaxKind.Identifier);
            expect(navigator.getTextContent()).toBe("WhiteSpace");
        });
        it("at end", () => {
            const { navigator } = getNavigator();
            expect(navigator.moveToTouchingToken({ line: 6, character: 11 })).toBe(true);
            expect(navigator.getKind()).toBeSyntaxKind(tokens_1.SyntaxKind.Identifier);
            expect(navigator.getTextContent()).toBe("WhiteSpace");
        });
        it("at bof", () => {
            const { navigator } = getNavigator();
            expect(navigator.moveToTouchingToken({ line: 0, character: 0 })).toBe(false);
        });
        it("at eof", () => {
            const { navigator } = getNavigator();
            expect(navigator.moveToTouchingToken({ line: 25, character: 36 })).toBe(true);
            expect(navigator.getKind()).toBeSyntaxKind(tokens_1.SyntaxKind.Identifier);
            expect(navigator.getTextContent()).toBe("IdentifierName");
        });
    });
    describe("moveToFirstToken", () => {
        it("when token in AST", () => {
            const { sourceFile, navigator, firstToken } = getNavigator();
            firstToken();
            expect(navigator.getNode()).toStrictEqual(sourceFile.elements[0].name);
        });
        it("when token not in AST", () => {
            const { navigator, firstToken } = getNavigator(",");
            firstToken();
            expect(navigator.getParent()).toBe(navigator.getRoot());
        });
        it("moves to first token in node", () => {
            const { navigator, firstToken } = getNavigator("A : B? C?");
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.Production)).toBe(true);
            expect(navigator.moveToLastChild(tokens_1.SyntaxKind.RightHandSide)).toBe(true);
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.SymbolSpan)).toBe(true);
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.Nonterminal)).toBe(true);
            firstToken(tokens_1.SyntaxKind.Identifier, "B");
        });
    });
    describe("moveToLastToken", () => {
        it("when in ast", () => {
            const { sourceFile, navigator, lastToken } = getNavigator();
            lastToken(tokens_1.SyntaxKind.Identifier);
            expect(navigator.getNode().end === sourceFile.end);
        });
        it("when not in ast", () => {
            const { navigator, lastToken, bof } = getNavigator(",");
            lastToken(tokens_1.SyntaxKind.CommaToken);
            expect(navigator.getParent()).toBe(navigator.getRoot());
            bof();
        });
        it("moves to last token in node", () => {
            const { navigator, lastToken, prevToken } = getNavigator("A : B? C?");
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.Production)).toBe(true);
            expect(navigator.moveToLastChild(tokens_1.SyntaxKind.RightHandSide)).toBe(true);
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.SymbolSpan)).toBe(true);
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.Nonterminal)).toBe(true);
            lastToken(tokens_1.SyntaxKind.QuestionToken);
            prevToken(tokens_1.SyntaxKind.Identifier, "B");
        });
    });
    describe("moveToNextToken", () => {
        it("when in ast", () => {
            const { firstToken, nextToken, eof } = getNavigator();
            firstToken(tokens_1.SyntaxKind.Identifier, "SourceCharacter"); // SourceCharacter
            nextToken(tokens_1.SyntaxKind.ColonColonToken); // ::
            nextToken(tokens_1.SyntaxKind.GreaterThanToken); // >
            nextToken(tokens_1.SyntaxKind.ProseFull, "any Unicode code point"); // any Unicode code point
            nextToken(tokens_1.SyntaxKind.Identifier, "InputElementDiv"); // InputElementDiv
            nextToken(tokens_1.SyntaxKind.ColonColonToken); // ::
            nextToken(tokens_1.SyntaxKind.Identifier, "WhiteSpace"); // WhiteSpace
            nextToken(tokens_1.SyntaxKind.Identifier, "LineTerminator"); // LineTerminator
            nextToken(tokens_1.SyntaxKind.Identifier, "Comment"); // Comment
            nextToken(tokens_1.SyntaxKind.Identifier, "CommonToken"); // CommonToken
            nextToken(tokens_1.SyntaxKind.Identifier, "DivPunctuator"); // DivPunctuator
            nextToken(tokens_1.SyntaxKind.Identifier, "RightBracePunctuator"); // RightBracePunctuator
            nextToken(tokens_1.SyntaxKind.Identifier, "InputElementRegExp"); // InputElementRegExp
            nextToken(tokens_1.SyntaxKind.ColonColonToken); // ::
            nextToken(tokens_1.SyntaxKind.Identifier, "WhiteSpace"); // WhiteSpace
            nextToken(tokens_1.SyntaxKind.Identifier, "LineTerminator"); // LineTerminator
            nextToken(tokens_1.SyntaxKind.Identifier, "Comment"); // Comment
            nextToken(tokens_1.SyntaxKind.Identifier, "CommonToken"); // CommonToken
            nextToken(tokens_1.SyntaxKind.Identifier, "RightBracePunctuator"); // RightBracePunctuator
            nextToken(tokens_1.SyntaxKind.Identifier, "RegularExpressionLiteral"); // RegularExpressionLiteral
            nextToken(tokens_1.SyntaxKind.Identifier, "ExportSpecifier"); // ExportSpecifier
            nextToken(tokens_1.SyntaxKind.ColonToken); // :
            nextToken(tokens_1.SyntaxKind.Identifier, "IdentifierName"); // IdentifierName
            nextToken(tokens_1.SyntaxKind.Identifier, "IdentifierName"); // IdentifierName
            nextToken(tokens_1.SyntaxKind.TerminalLiteral, "as"); // `as`
            nextToken(tokens_1.SyntaxKind.Identifier, "IdentifierName"); // IdentifierName
            eof();
        });
        it("when not in ast", () => {
            var _a;
            const { navigator, firstToken, nextToken, eof } = getNavigator("A[B, C] : `a`");
            firstToken(tokens_1.SyntaxKind.Identifier, "A");
            nextToken(tokens_1.SyntaxKind.OpenBracketToken); // [
            nextToken(tokens_1.SyntaxKind.Identifier, "B"); // B
            nextToken(tokens_1.SyntaxKind.CommaToken); // ,
            expect((_a = navigator.getParent()) === null || _a === void 0 ? void 0 : _a.kind).toBe(tokens_1.SyntaxKind.Parameter);
            nextToken(tokens_1.SyntaxKind.Identifier, "C"); // C
            nextToken(tokens_1.SyntaxKind.CloseBracketToken); // ]
            nextToken(tokens_1.SyntaxKind.ColonToken); // :
            nextToken(tokens_1.SyntaxKind.TerminalLiteral); // `a`
            eof();
        });
        it("in one of symbol", () => {
            const { firstToken, nextToken, eof } = getNavigator("A :: B but not one of C or D");
            firstToken(tokens_1.SyntaxKind.Identifier, "A");
            nextToken(tokens_1.SyntaxKind.ColonColonToken);
            nextToken(tokens_1.SyntaxKind.Identifier);
            nextToken(tokens_1.SyntaxKind.ButKeyword);
            nextToken(tokens_1.SyntaxKind.NotKeyword);
            nextToken(tokens_1.SyntaxKind.OneKeyword);
            nextToken(tokens_1.SyntaxKind.OfKeyword);
            nextToken(tokens_1.SyntaxKind.Identifier, "C");
            nextToken(tokens_1.SyntaxKind.OrKeyword);
            nextToken(tokens_1.SyntaxKind.Identifier, "D");
            eof();
        });
        it("in InvalidAssertion", () => {
            const { firstToken, nextToken, eof } = getNavigator("A :: B [,@]");
            firstToken(tokens_1.SyntaxKind.Identifier, "A");
            nextToken(tokens_1.SyntaxKind.ColonColonToken);
            nextToken(tokens_1.SyntaxKind.Identifier, "B");
            nextToken(tokens_1.SyntaxKind.OpenBracketToken);
            nextToken(tokens_1.SyntaxKind.CommaToken);
            nextToken(tokens_1.SyntaxKind.AtToken);
            nextToken(tokens_1.SyntaxKind.CloseBracketToken);
            eof();
        });
        it("moves to next token following current node", () => {
            const { navigator, nextToken, eof } = getNavigator("A :: B? `c`");
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.Production)).toBe(true);
            expect(navigator.moveToLastChild(tokens_1.SyntaxKind.RightHandSide)).toBe(true);
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.SymbolSpan)).toBe(true);
            expect(navigator.moveToFirstChild(tokens_1.SyntaxKind.Nonterminal)).toBe(true);
            nextToken(tokens_1.SyntaxKind.TerminalLiteral, "c");
            eof();
        });
    });
    describe("moveToPreviousToken", () => {
        it("when in ast", () => {
            const { lastToken, prevToken } = getNavigator();
            lastToken(tokens_1.SyntaxKind.Identifier, "IdentifierName"); // IdentifierName
            prevToken(tokens_1.SyntaxKind.TerminalLiteral, "as"); // `as`
            prevToken(tokens_1.SyntaxKind.Identifier, "IdentifierName"); // IdentifierName
            prevToken(tokens_1.SyntaxKind.Identifier, "IdentifierName"); // IdentifierName
            prevToken(tokens_1.SyntaxKind.ColonToken); // :
            prevToken(tokens_1.SyntaxKind.Identifier, "ExportSpecifier"); // ExportSpecifier
            prevToken(tokens_1.SyntaxKind.Identifier, "RegularExpressionLiteral"); // RegularExpressionLiteral
        });
        it("when not in ast", () => {
            const { lastToken, prevToken, bof } = getNavigator("A[B, C] : `a`");
            lastToken(tokens_1.SyntaxKind.TerminalLiteral);
            prevToken(tokens_1.SyntaxKind.ColonToken);
            prevToken(tokens_1.SyntaxKind.CloseBracketToken);
            prevToken(tokens_1.SyntaxKind.Identifier);
            prevToken(tokens_1.SyntaxKind.CommaToken);
            prevToken(tokens_1.SyntaxKind.Identifier);
            prevToken(tokens_1.SyntaxKind.OpenBracketToken);
            prevToken(tokens_1.SyntaxKind.Identifier);
            bof();
        });
        it("moves to previous token preceding current node", () => {
            const { navigator, lastToken, prevToken } = getNavigator("A :: B? `c`");
            lastToken();
            expect(navigator.moveToAncestor(tokens_1.SyntaxKind.SymbolSpan)).toBe(true);
            prevToken(tokens_1.SyntaxKind.QuestionToken);
        });
    });
    function getNavigator(text = es6GrammarText) {
        const parser = new parser_1.Parser();
        const sourceFile = parser.parseSourceFile("file.grammar", text);
        const navigator = new navigator_1.NodeNavigator(sourceFile);
        return { sourceFile, navigator, ...(0, navigatorUtils_1.makeExpectToken)(navigator) };
    }
});
//# sourceMappingURL=navigator.test.js.map