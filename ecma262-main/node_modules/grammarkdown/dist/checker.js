"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resolver = exports.Checker = void 0;
const crypto_1 = require("crypto");
const binder_1 = require("./binder");
const core_1 = require("./core");
const diagnostics_1 = require("./diagnostics");
const lineOffsetMap_1 = require("./lineOffsetMap");
const navigator_1 = require("./navigator");
const regionMap_1 = require("./regionMap");
const stringwriter_1 = require("./stringwriter");
const symbols_1 = require("./symbols");
const tokens_1 = require("./tokens");
const scanner_1 = require("./scanner");
class NodeLinks {
}
class SymbolLinks {
}
function equateDefines(a, b) {
    return a.noStrictParametricProductions === b.noStrictParametricProductions
        && a.noUnusedParameters === b.noUnusedParameters;
}
/** {@docCategory Check} */
class Checker {
    constructor(options, lineOffsetMap = new lineOffsetMap_1.LineOffsetMap()) {
        var _a, _b, _c, _d;
        this._checkedFileSet = new Set();
        this._options = options;
        this._lineOffsetMap = lineOffsetMap;
        this._defines = {
            noStrictParametricProductions: (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.noStrictParametricProductions) !== null && _b !== void 0 ? _b : false,
            noUnusedParameters: (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.noUnusedParameters) !== null && _d !== void 0 ? _d : false
        };
    }
    checkSourceFile(sourceFile, bindings, diagnostics, cancelable) {
        var _a, _b;
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        if (!this._checkedFileSet.has(sourceFile.filename)) {
            const savedNoChecks = this._noChecks;
            const savedCancellationToken = this._cancelToken;
            const savedSourceFile = this._sourceFile;
            const savedProductionParametersByName = this._productionParametersByName;
            const savedBindings = this._bindings;
            const savedDiagnostics = this._diagnostics;
            try {
                this._cancelToken = cancelToken;
                this._sourceFile = sourceFile;
                this._productionParametersByName = new Map();
                this._noChecks = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.noChecks) !== null && _b !== void 0 ? _b : false;
                this._bindings = new binder_1.BindingTable();
                this._bindings._copyFrom(bindings);
                this._diagnostics = this._noChecks ? diagnostics_1.NullDiagnosticMessages.instance : new diagnostics_1.DiagnosticMessages();
                this._diagnostics.setSourceFile(this._sourceFile);
                for (const element of sourceFile.elements) {
                    this.preprocessSourceElement(element);
                }
                for (const element of sourceFile.elements) {
                    this.checkSourceElement(element);
                }
                diagnostics.copyFrom(this._diagnostics);
                bindings._copyFrom(this._bindings);
                this._checkedFileSet.add(sourceFile.filename);
            }
            finally {
                this._noChecks = savedNoChecks;
                this._cancelToken = savedCancellationToken;
                this._sourceFile = savedSourceFile;
                this._productionParametersByName = savedProductionParametersByName;
                this._bindings = savedBindings;
                this._diagnostics = savedDiagnostics;
            }
        }
    }
    getDefine(location, key) {
        if (this._defineOverrideMap) {
            const position = this._sourceFile.lineMap.positionAt(location.getStart(this._sourceFile));
            for (const region of this._defineOverrideMap.regions(this._sourceFile, position.line)) {
                const value = region.value[key];
                if (value === "default")
                    break;
                if (value === undefined)
                    continue;
                return value;
            }
        }
        return this._defines[key];
    }
    preprocessSourceElement(node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Define:
                this.preprocessDefine(node);
                break;
            case tokens_1.SyntaxKind.Line:
                this.preprocessLine(node);
                break;
        }
    }
    preprocessDefine(node) {
        var _a;
        if (!this.checkGrammarDefine(node)) {
            const position = this._sourceFile.lineMap.positionAt(node.getStart(this._sourceFile));
            const nodeKey = node.key;
            const nodeKeyText = nodeKey.text;
            (_a = this._defineOverrideMap) !== null && _a !== void 0 ? _a : (this._defineOverrideMap = new regionMap_1.RegionMap(equateDefines));
            switch (nodeKeyText) {
                case "noStrictParametricProductions":
                    this._defineOverrideMap.addRegion(this._sourceFile, position.line, {
                        noStrictParametricProductions: node.valueToken.kind === tokens_1.SyntaxKind.DefaultKeyword ? "default" :
                            node.valueToken.kind === tokens_1.SyntaxKind.TrueKeyword
                    });
                    break;
                case "noUnusedParameters":
                    this._defineOverrideMap.addRegion(this._sourceFile, position.line, {
                        noUnusedParameters: node.valueToken.kind === tokens_1.SyntaxKind.DefaultKeyword ? "default" :
                            node.valueToken.kind === tokens_1.SyntaxKind.TrueKeyword
                    });
                    break;
                default:
                    this.reportError(nodeKey, diagnostics_1.Diagnostics.Cannot_find_name_0_, nodeKeyText);
                    break;
            }
        }
    }
    checkGrammarDefine(node) {
        var _a;
        if (((_a = node.key) === null || _a === void 0 ? void 0 : _a.text) === undefined) {
            return this.reportGrammarError(node, node.defineKeyword.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.valueToken) {
            return this.reportGrammarError(node, node.key.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.TrueKeyword, tokens_1.SyntaxKind.FalseKeyword, tokens_1.SyntaxKind.DefaultKeyword]));
        }
        return false;
    }
    preprocessLine(node) {
        var _a, _b, _c;
        if (!this.checkGrammarLine(node)) {
            // @line re-numbering starts with the next line
            const generatedLine = this._sourceFile.lineMap.positionAt(node.end).line + 1;
            if (((_a = node.number) === null || _a === void 0 ? void 0 : _a.kind) === tokens_1.SyntaxKind.DefaultKeyword) {
                this._lineOffsetMap.addLineOffset(this._sourceFile, generatedLine, "default");
            }
            else if (((_b = node.number) === null || _b === void 0 ? void 0 : _b.kind) === tokens_1.SyntaxKind.NumberLiteral) {
                this._lineOffsetMap.addLineOffset(this._sourceFile, generatedLine, { line: +node.number.text - 1, file: (_c = node.path) === null || _c === void 0 ? void 0 : _c.text });
            }
        }
    }
    checkGrammarLine(node) {
        if (!node.number || node.number.kind === tokens_1.SyntaxKind.NumberLiteral && node.number.text === undefined) {
            return this.reportGrammarError(node, node.lineKeyword.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.NumberLiteral, tokens_1.SyntaxKind.DefaultKeyword]));
        }
        if (node.path && node.path.text === undefined) {
            return this.reportGrammarError(node, node.number.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.StringLiteral]));
        }
        return false;
    }
    checkSourceElement(node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Production:
                this.checkProduction(node);
                break;
        }
    }
    checkProduction(node) {
        var _a, _b;
        this.checkGrammarProduction(node);
        if (this.getDefine(node, "noStrictParametricProductions")) {
            this.checkProductionNonStrict(node);
        }
        else {
            this.checkProductionStrict(node);
        }
        if (node.body) {
            switch (node.body.kind) {
                case tokens_1.SyntaxKind.OneOfList:
                    this.checkOneOfList(node.body);
                    break;
                case tokens_1.SyntaxKind.RightHandSideList:
                    this.checkRightHandSideList(node.body);
                    break;
                case tokens_1.SyntaxKind.RightHandSide:
                    this.checkRightHandSide(node.body);
                    break;
            }
        }
        this.getNodeLinks(node, /*create*/ true).hasResolvedSymbols = true;
        if (this.getDefine(node, "noUnusedParameters")) {
            const symbol = this._bindings.getSymbol(node);
            if (symbol) {
                for (const decl of this._bindings.getDeclarations(symbol)) {
                    if (decl.kind === tokens_1.SyntaxKind.Production) {
                        this.resolveProduction(decl);
                    }
                }
            }
            if ((_a = node.parameterList) === null || _a === void 0 ? void 0 : _a.elements) {
                for (const param of node.parameterList.elements) {
                    const symbol = this._bindings.getSymbol(param);
                    if (symbol && !((_b = this.getSymbolLinks(symbol)) === null || _b === void 0 ? void 0 : _b.isReferenced)) {
                        this.reportError(param, diagnostics_1.Diagnostics.Parameter_0_is_unused, param.name.text);
                    }
                }
            }
        }
    }
    resolveProduction(node) {
        var _a;
        if (!((_a = this.getNodeLinks(node)) === null || _a === void 0 ? void 0 : _a.hasResolvedSymbols)) {
            this.getNodeLinks(node, /*create*/ true).hasResolvedSymbols = true;
        }
        const visitNode = (node) => {
            if (node.kind === tokens_1.SyntaxKind.Identifier) {
                this.resolveIdentifier(node);
            }
            node.forEachChild(visitNode);
        };
        node.forEachChild(visitNode);
    }
    checkProductionNonStrict(node) {
        this.checkIdentifier(node.name);
        if (node.parameterList) {
            this.checkParameterList(node.parameterList);
        }
    }
    getProductionParametersByName(node) {
        var _a, _b;
        let parametersByName = this._productionParametersByName.get(node);
        if (parametersByName)
            return parametersByName;
        this._productionParametersByName.set(node, parametersByName = new Set());
        const parameterList = node.parameterList;
        const parameters = parameterList === null || parameterList === void 0 ? void 0 : parameterList.elements;
        if (parameters) {
            for (let i = 0; i < parameters.length; i++) {
                const parameterNameText = (_b = (_a = parameters[i]) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.text;
                if (parameterNameText) {
                    parametersByName.add(parameterNameText);
                }
            }
        }
        return parametersByName;
    }
    checkProductionStrict(thisProduction) {
        var _a, _b;
        const thisProductionName = thisProduction.name;
        const thisProductionNameText = thisProductionName.text;
        const thisProductionSymbol = this.checkIdentifier(thisProductionName);
        const thisProductionParameterList = thisProduction.parameterList;
        const thisProductionParameters = thisProductionParameterList === null || thisProductionParameterList === void 0 ? void 0 : thisProductionParameterList.elements;
        const thisProductionParameterCount = (_a = thisProductionParameters === null || thisProductionParameters === void 0 ? void 0 : thisProductionParameters.length) !== null && _a !== void 0 ? _a : 0;
        const firstProduction = this._bindings.getDeclarations(thisProductionSymbol)[0];
        if (thisProductionParameterList && thisProductionParameters) {
            this.checkParameterList(thisProductionParameterList);
        }
        if (firstProduction === thisProduction) {
            return;
        }
        const thisProductionParameterNames = this.getProductionParametersByName(thisProduction);
        const firstProductionParameterList = firstProduction.parameterList;
        const firstProductionParameters = firstProductionParameterList === null || firstProductionParameterList === void 0 ? void 0 : firstProductionParameterList.elements;
        const firstProductionParameterCount = (_b = firstProductionParameters === null || firstProductionParameters === void 0 ? void 0 : firstProductionParameters.length) !== null && _b !== void 0 ? _b : 0;
        const firstProductionParameterNames = this.getProductionParametersByName(firstProduction);
        if (firstProductionParameters) {
            for (let i = 0; i < firstProductionParameterCount; i++) {
                const firstProductionParameter = firstProductionParameters[i];
                const firstProductionParameterName = firstProductionParameter.name;
                const firstProductionParameterNameText = firstProductionParameterName.text;
                if (firstProductionParameterNameText && !thisProductionParameterNames.has(firstProductionParameterNameText)) {
                    this.reportError(thisProductionName, diagnostics_1.Diagnostics.Production_0_is_missing_parameter_1_All_definitions_of_production_0_must_specify_the_same_formal_parameters, thisProductionNameText, firstProductionParameterNameText);
                }
            }
        }
        if (thisProductionParameters) {
            for (let i = 0; i < thisProductionParameterCount; i++) {
                const thisProductionParameter = thisProductionParameters[i];
                const thisProductionParameterName = thisProductionParameter.name;
                const thisProductionParameterNameText = thisProductionParameterName.text;
                if (thisProductionParameterNameText && !firstProductionParameterNames.has(thisProductionParameterNameText)) {
                    this.reportError(firstProduction, diagnostics_1.Diagnostics.Production_0_is_missing_parameter_1_All_definitions_of_production_0_must_specify_the_same_formal_parameters, thisProductionNameText, thisProductionParameterNameText);
                }
            }
        }
    }
    checkGrammarProduction(node) {
        var _a, _b;
        if (!node.colonToken) {
            return this.reportGrammarError(node, (_b = (_a = node.parameterList) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : node.name.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.ColonToken));
        }
        if (!node.body) {
            return this.reportGrammarError(node, node.colonToken.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.OneOfList,
                tokens_1.SyntaxKind.RightHandSide,
            ]));
        }
        switch (node.body.kind) {
            case tokens_1.SyntaxKind.OneOfList:
            case tokens_1.SyntaxKind.RightHandSide:
            case tokens_1.SyntaxKind.RightHandSideList:
                break;
            default:
                return this.reportGrammarError(node, node.colonToken.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                    tokens_1.SyntaxKind.OneOfList,
                    tokens_1.SyntaxKind.RightHandSide,
                ]));
        }
        return this.reportInvalidHtmlTrivia(node.name.trailingHtmlTrivia)
            || this.reportInvalidHtmlTrivia(node.colonToken.leadingHtmlTrivia)
            || this.reportInvalidHtmlTrivia(node.colonToken.trailingHtmlTrivia);
    }
    checkParameterList(node) {
        this.checkGrammarParameterList(node);
        if (node.elements) {
            for (const element of node.elements) {
                this.checkParameter(element);
            }
        }
    }
    checkGrammarParameterList(node) {
        var _a, _b;
        if (!node.openBracketToken) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OpenBracketToken));
        }
        if (((_b = (_a = node.elements) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 0) {
            return this.reportGrammarError(node, node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.closeBracketToken) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return this.reportInvalidHtmlTrivia(node.leadingHtmlTrivia)
            || this.reportInvalidHtmlTrivia(node.trailingHtmlTrivia);
    }
    checkParameter(node) {
        this.reportInvalidHtmlTrivia(node.leadingHtmlTrivia) || this.reportInvalidHtmlTrivia(node.trailingHtmlTrivia);
        this.checkIdentifier(node.name);
    }
    checkOneOfList(node) {
        this.checkGrammarOneOfList(node);
        if (node.terminals) {
            const terminalSet = new Set();
            for (const terminal of node.terminals) {
                const text = terminal.text;
                if (text) {
                    if (terminalSet.has(text)) {
                        this.reportError(terminal, diagnostics_1.Diagnostics.Duplicate_terminal_0_, text);
                    }
                    else {
                        terminalSet.add(text);
                        this.checkTerminalLiteral(terminal);
                    }
                }
            }
        }
    }
    checkGrammarOneOfList(node) {
        var _a, _b;
        if (!node.oneKeyword) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OneKeyword));
        }
        if (!node.ofKeyword) {
            return this.reportGrammarError(node, node.oneKeyword.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OfKeyword));
        }
        if (((_b = (_a = node.terminals) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 0) {
            return this.reportGrammarError(node, node.ofKeyword.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.TerminalLiteral));
        }
        return false;
    }
    checkRightHandSideList(node) {
        this.checkGrammarRightHandSideList(node);
        if (node.elements) {
            for (const element of node.elements) {
                this.checkRightHandSide(element);
            }
        }
    }
    checkGrammarRightHandSideList(node) {
        if (!node.elements || node.elements.length === 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.TerminalLiteral,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken
            ]));
        }
        // if (!node.closeIndentToken) {
        //     return this.reportGrammarError(node, node.end, Diagnostics._0_expected, tokenToString(SyntaxKind.DedentToken));
        // }
        return false;
    }
    checkRightHandSide(node) {
        this.checkGrammarRightHandSide(node);
        if (node.constraints) {
            this.checkConstraints(node.constraints);
        }
        if (node.head) {
            this.checkSymbolSpan(node.head, !node.constraints);
        }
        if (node.reference) {
            this.checkLinkReference(node.reference);
        }
    }
    checkGrammarRightHandSide(node) {
        if (!node.head) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.GreaterThanToken, tokens_1.SyntaxKind.OpenBracketToken, tokens_1.SyntaxKind.Identifier, tokens_1.SyntaxKind.TerminalLiteral, tokens_1.SyntaxKind.UnicodeCharacterLiteral]));
        }
        return false;
    }
    checkLinkReference(node) {
        this.checkGrammarLinkReference(node);
    }
    checkGrammarLinkReference(node) {
        if (!node.text) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, "string");
        }
        return false;
    }
    checkConstraints(node) {
        this.checkGrammarConstraints(node);
        if (node.elements) {
            for (const element of node.elements) {
                this.checkArgument(element);
            }
        }
    }
    checkGrammarConstraints(node) {
        var _a, _b;
        if (((_b = (_a = node.elements) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 0) {
            return this.reportGrammarError(node, node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.TildeToken, tokens_1.SyntaxKind.PlusToken]));
        }
        if (!node.closeBracketToken) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return false;
    }
    checkSymbolSpan(node, suggestConstraints) {
        this.checkGrammarSymbolSpan(node);
        this.checkSymbolSpanOrHigher(node.symbol, suggestConstraints);
        if (node.next) {
            this.checkSymbolSpanRest(node.next);
        }
    }
    checkGrammarSymbolSpan(node) {
        if (!node.symbol) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.TerminalLiteral,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken,
                tokens_1.SyntaxKind.Prose
            ]));
        }
        if (node.next && node.symbol.kind === tokens_1.SyntaxKind.Prose) {
            return this.reportGrammarError(node, node.symbol.end, diagnostics_1.Diagnostics._0_expected, "«line terminator»");
        }
        return false;
    }
    checkSymbolSpanOrHigher(node, suggestConstraints) {
        if (node.kind === tokens_1.SyntaxKind.Prose) {
            this.checkProse(node);
            return;
        }
        this.checkSymbolOrHigher(node, suggestConstraints);
    }
    checkProse(node) {
        if (node.fragments) {
            for (const fragment of node.fragments) {
                this.checkProseFragment(fragment);
            }
        }
    }
    checkSymbolSpanRest(node) {
        this.checkGrammarSymbolSpanRest(node);
        this.checkSymbolOrHigher(node.symbol, /*suggestConstraints*/ false);
        if (node.next) {
            this.checkSymbolSpanRest(node.next);
        }
    }
    checkGrammarSymbolSpanRest(node) {
        var _a;
        if (!node.symbol) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.TerminalLiteral,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken,
                "«line terminator»"
            ]));
        }
        if (node.symbol.kind === tokens_1.SyntaxKind.Prose) {
            return this.reportGrammarError(node, node.symbol.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, "«line terminator»");
        }
        if (((_a = node.next) === null || _a === void 0 ? void 0 : _a.symbol.kind) === tokens_1.SyntaxKind.Prose) {
            return this.reportGrammarError(node, node.symbol.end, diagnostics_1.Diagnostics._0_expected, "«line terminator»");
        }
        return false;
    }
    checkSymbolOrHigher(node, suggestConstraints) {
        if (isAssertion(node)) {
            this.checkAssertion(node, suggestConstraints);
            return;
        }
        this.checkButNotSymbolOrHigher(node);
    }
    checkAssertion(node, suggestConstraints) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.checkEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.checkLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.checkLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.checkNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseAssertion:
                this.checkProseAssertion(node);
                break;
            case tokens_1.SyntaxKind.InvalidAssertion:
                this.reportInvalidAssertion(node, suggestConstraints);
                break;
        }
    }
    checkGrammarAssertionHead(node) {
        if (!node.openBracketToken) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OpenBracketToken));
        }
        return false;
    }
    checkGrammarAssertionTail(node) {
        if (!node.closeBracketToken) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return false;
    }
    checkEmptyAssertion(node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarEmptyAssertion(node) || this.checkGrammarAssertionTail(node);
    }
    checkGrammarEmptyAssertion(node) {
        if (!node.emptyKeyword) {
            return this.reportGrammarError(node, node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.EmptyKeyword, /*quoted*/ true));
        }
    }
    checkLookaheadAssertion(node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarLookaheadAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.lookahead) {
            if (node.lookahead.kind === tokens_1.SyntaxKind.SymbolSet) {
                this.checkSymbolSet(node.lookahead);
                return;
            }
            this.checkSymbolSpanRest(node.lookahead);
        }
    }
    checkGrammarLookaheadAssertion(node) {
        if (!node.lookaheadKeyword) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.LookaheadKeyword, /*quoted*/ true));
        }
        if (!node.operatorToken) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.EqualsToken,
                tokens_1.SyntaxKind.EqualsEqualsToken,
                tokens_1.SyntaxKind.ExclamationEqualsToken,
                tokens_1.SyntaxKind.LessThanMinusToken,
                tokens_1.SyntaxKind.LessThanExclamationToken
            ]));
        }
        switch (node.operatorToken.kind) {
            case tokens_1.SyntaxKind.EqualsToken:
            case tokens_1.SyntaxKind.EqualsEqualsToken:
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
            case tokens_1.SyntaxKind.NotEqualToToken:
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.ElementOfToken:
            case tokens_1.SyntaxKind.LessThanExclamationToken:
            case tokens_1.SyntaxKind.NotAnElementOfToken:
                break;
            default:
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                    tokens_1.SyntaxKind.EqualsToken,
                    tokens_1.SyntaxKind.EqualsEqualsToken,
                    tokens_1.SyntaxKind.ExclamationEqualsToken,
                    tokens_1.SyntaxKind.LessThanMinusToken,
                    tokens_1.SyntaxKind.LessThanExclamationToken
                ]));
        }
        if (!node.lookahead) {
            switch (node.operatorToken.kind) {
                case tokens_1.SyntaxKind.EqualsToken:
                case tokens_1.SyntaxKind.EqualsEqualsToken:
                case tokens_1.SyntaxKind.ExclamationEqualsToken:
                case tokens_1.SyntaxKind.NotEqualToToken:
                    return this.reportGrammarError(node, node.operatorToken.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.TerminalLiteral));
                case tokens_1.SyntaxKind.LessThanMinusToken:
                case tokens_1.SyntaxKind.ElementOfToken:
                case tokens_1.SyntaxKind.LessThanExclamationToken:
                case tokens_1.SyntaxKind.NotAnElementOfToken:
                    return this.reportGrammarError(node, node.operatorToken.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.OpenBraceToken, tokens_1.SyntaxKind.Nonterminal]));
            }
        }
        switch (node.operatorToken.kind) {
            case tokens_1.SyntaxKind.EqualsToken:
            case tokens_1.SyntaxKind.EqualsEqualsToken:
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
            case tokens_1.SyntaxKind.NotEqualToToken:
                if (!node.lookahead || !isTerminalSpan(node.lookahead)) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                        tokens_1.SyntaxKind.TerminalLiteral,
                        tokens_1.SyntaxKind.UnicodeCharacterLiteral
                    ]));
                }
                break;
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.ElementOfToken:
            case tokens_1.SyntaxKind.LessThanExclamationToken:
            case tokens_1.SyntaxKind.NotAnElementOfToken:
                if (!node.lookahead || !isNonterminalOrSymbolSet(node.lookahead)) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                        tokens_1.SyntaxKind.OpenBraceToken,
                        tokens_1.SyntaxKind.Nonterminal
                    ]));
                }
                break;
        }
        return false;
        function isTerminalSpan(node) {
            while (node.kind === tokens_1.SyntaxKind.SymbolSpan) {
                switch (node.symbol.kind) {
                    case tokens_1.SyntaxKind.Terminal:
                        if (!node.next)
                            return true;
                        node = node.next;
                        break;
                    default:
                        return false;
                }
            }
            return false;
        }
        function isNonterminalOrSymbolSet(node) {
            return node.kind === tokens_1.SyntaxKind.SymbolSpan
                ? node.symbol.kind === tokens_1.SyntaxKind.Nonterminal
                : node.kind === tokens_1.SyntaxKind.SymbolSet;
        }
    }
    checkSymbolSet(node) {
        this.checkGrammarSymbolSet(node);
        if (node.elements) {
            for (const element of node.elements) {
                this.checkSymbolSpanRest(element);
            }
        }
    }
    checkGrammarSymbolSet(node) {
        var _a, _b;
        if (!node.openBraceToken) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OpenBraceToken));
        }
        if (((_b = (_a = node.elements) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 0) {
            return this.reportGrammarError(node, node.openBraceToken.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.TerminalLiteral,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        if (!node.closeBraceToken) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.CloseBraceToken));
        }
        return false;
    }
    checkLexicalGoalAssertion(node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarLexicalGoalAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.symbol) {
            this.checkIdentifier(node.symbol);
        }
    }
    checkGrammarLexicalGoalAssertion(node) {
        if (!node.lexicalKeyword) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.LexicalKeyword));
        }
        if (!node.goalKeyword) {
            return this.reportGrammarError(node, node.lexicalKeyword.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.GoalKeyword));
        }
        if (!node.symbol) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.Identifier));
        }
        return false;
    }
    checkNoSymbolHereAssertion(node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarNoSymbolHereAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.symbols) {
            for (const symbol of node.symbols) {
                this.checkPrimarySymbol(symbol);
            }
        }
    }
    checkGrammarNoSymbolHereAssertion(node) {
        var _a, _b, _c;
        if (!node.noKeyword) {
            return this.reportGrammarError(node, node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.NoKeyword));
        }
        if (((_b = (_a = node.symbols) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 0) {
            return this.reportGrammarError(node, node.noKeyword.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.TerminalLiteral,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        if (!node.hereKeyword) {
            const pos = ((_c = node.symbols) === null || _c === void 0 ? void 0 : _c.length) ? node.symbols[node.symbols.length - 1].end :
                node.noKeyword ? node.noKeyword.end :
                    node.openBracketToken.end;
            return this.reportGrammarError(node, pos, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.HereKeyword));
        }
        return false;
    }
    checkProseAssertion(node) {
        this.checkGrammarProseAssertionHead(node) || this.checkGrammarAssertionTail(node);
        if (node.fragments) {
            for (const fragment of node.fragments) {
                this.checkProseFragment(fragment);
            }
        }
    }
    checkGrammarProseAssertionHead(node) {
        if (!node.openBracketToken) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OpenBracketGreaterThanToken));
        }
        return false;
    }
    checkProseFragment(fragment) {
        switch (fragment.kind) {
            case tokens_1.SyntaxKind.Nonterminal:
                this.checkNonterminal(fragment, /*allowOptional*/ false, /*allowArguments*/ false);
                break;
            case tokens_1.SyntaxKind.Terminal:
                this.checkTerminal(fragment, /*allowOptional*/ false);
                break;
            case tokens_1.SyntaxKind.ProseFull:
            case tokens_1.SyntaxKind.ProseHead:
            case tokens_1.SyntaxKind.ProseMiddle:
            case tokens_1.SyntaxKind.ProseTail:
                this.checkProseFragmentLiteral(fragment);
                break;
        }
    }
    checkProseFragmentLiteral(node) {
        if (!node.text) {
            this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
    }
    reportInvalidAssertion(node, suggestConstraints) {
        if (this.checkGrammarAssertionHead(node)) {
            return;
        }
        if (suggestConstraints) {
            this.reportGrammarError(node, node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.LookaheadKeyword,
                tokens_1.SyntaxKind.LexicalKeyword,
                tokens_1.SyntaxKind.NoKeyword,
                tokens_1.SyntaxKind.TildeToken,
                tokens_1.SyntaxKind.PlusToken
            ]));
        }
        else {
            this.reportGrammarError(node, node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.LookaheadKeyword,
                tokens_1.SyntaxKind.LexicalKeyword,
                tokens_1.SyntaxKind.NoKeyword,
            ]));
        }
    }
    checkButNotSymbolOrHigher(node) {
        if (node.kind === tokens_1.SyntaxKind.ButNotSymbol) {
            this.checkButNotSymbol(node);
            return;
        }
        this.checkUnarySymbolOrHigher(node);
    }
    checkButNotSymbol(node) {
        this.checkGrammarButNotSymbol(node);
        if (node.left)
            this.checkUnarySymbolOrHigher(node.left);
        if (node.right)
            this.checkUnarySymbolOrHigher(node.right);
    }
    checkGrammarButNotSymbol(node) {
        if (!node.butKeyword) {
            return this.reportGrammarErrorForNodeOrPos(node, node.notKeyword || node.right, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.ButKeyword));
        }
        if (!node.notKeyword) {
            return this.reportGrammarErrorForNodeOrPos(node, node.right, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.NotKeyword));
        }
        if (!node.right) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.TerminalLiteral,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.OneKeyword
            ]));
        }
        return false;
    }
    checkUnarySymbolOrHigher(node) {
        if (node.kind === tokens_1.SyntaxKind.OneOfSymbol) {
            this.checkOneOfSymbol(node);
            return;
        }
        this.checkOptionalSymbolOrHigher(node);
    }
    checkOneOfSymbol(node) {
        this.checkGrammarOneOfSymbol(node);
        if (node.symbols) {
            for (const symbol of node.symbols) {
                this.checkPrimarySymbol(symbol);
            }
        }
    }
    checkGrammarOneOfSymbol(node) {
        var _a, _b;
        if (!node.oneKeyword) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OneKeyword));
        }
        if (!node.ofKeyword) {
            return this.reportGrammarError(node, node.oneKeyword.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OfKeyword));
        }
        if (((_b = (_a = node.symbols) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 0) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.TerminalLiteral,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        return false;
    }
    checkOptionalSymbolOrHigher(node) {
        this.checkPrimarySymbol(node, true);
    }
    checkPrimarySymbol(node, allowOptional) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Terminal:
                this.checkTerminal(node, allowOptional);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.checkUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.checkNonterminal(node, allowOptional, /*allowArguments*/ true);
                break;
            case tokens_1.SyntaxKind.PlaceholderSymbol:
                this.checkPlaceholder(node);
                break;
            default:
                this.reportInvalidSymbol(node);
                break;
        }
    }
    checkGrammarNonTerminal(node, allowOptional, allowArguments) {
        if (this.checkGrammarOptionalSymbol(node, allowOptional)) {
            return true;
        }
        if (!allowArguments && node.argumentList) {
            return this.reportGrammarErrorForNode(node.argumentList, diagnostics_1.Diagnostics.Unexpected_token_0_, (0, tokens_1.tokenToString)(node.argumentList.openBracketToken.kind));
        }
        return false;
    }
    checkGrammarOptionalSymbol(node, allowOptional) {
        if (node.questionToken) {
            if (!allowOptional || node.questionToken.kind !== tokens_1.SyntaxKind.QuestionToken) {
                return this.reportGrammarErrorForNode(node.questionToken, diagnostics_1.Diagnostics.Unexpected_token_0_, (0, tokens_1.tokenToString)(node.questionToken.kind));
            }
        }
        return false;
    }
    checkTerminal(node, allowOptional = false) {
        this.checkGrammarOptionalSymbol(node, allowOptional);
        switch (node.literal.kind) {
            case tokens_1.SyntaxKind.TerminalLiteral:
                this.checkTerminalLiteral(node.literal);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.checkUnicodeCharacterLiteral(node.literal);
                break;
        }
    }
    checkTerminalLiteral(node) {
        this.checkGrammarTerminalLiteral(node);
    }
    checkGrammarTerminalLiteral(node) {
        if (!node.text) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.TerminalLiteral));
        }
        return false;
    }
    checkGrammarUnicodeCharacterRange(node) {
        if (!node.left) {
            return this.reportGrammarErrorForNode(node.throughKeyword || node.right || node, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        if (!node.throughKeyword) {
            return this.reportGrammarErrorForNode(node.right || node, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.ThroughKeyword));
        }
        if (!node.right) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        return false;
    }
    checkUnicodeCharacterRange(node) {
        this.checkGrammarUnicodeCharacterRange(node);
        this.checkUnicodeCharacterLiteral(node.left);
        this.checkUnicodeCharacterLiteral(node.right);
    }
    checkUnicodeCharacterLiteral(node) {
        this.checkGrammarUnicodeCharacterLiteral(node);
    }
    checkGrammarUnicodeCharacterLiteralCodePointErrors(node, text, start, end) {
        const len = end - start;
        if (len < "U+0000".length) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_code_point_literals_must_have_at_least_four_hexadecimal_digits);
        }
        if (len >= "U+10000".length) {
            if (text.charCodeAt(start + 2) === 48 /* Number0 */) {
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_code_point_literals_with_more_than_four_digits_may_not_have_leading_zeros);
            }
            if (len > "U+100000".length) {
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_code_point_literal_value_is_outside_of_the_allowed_range);
            }
            else if (len === "U+100000".length) {
                if (text.charCodeAt(start + 2) !== 49 /* Number1 */ ||
                    text.charCodeAt(start + 3) !== 48 /* Number0 */) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_code_point_literal_value_is_outside_of_the_allowed_range);
                }
            }
        }
        return false;
    }
    checkGrammarUnicodeCharacterLiteralCodePointWarnings(node, text, start, end) {
        const len = end - start;
        if (text.charCodeAt(start) === 117 /* LowerU */) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_code_point_literals_should_use_uppercase_U_prefix);
        }
        for (let i = 2; i < len; i++) {
            const ch = text.charCodeAt(start + i);
            if (ch >= 97 /* LowerA */ && ch <= 102 /* LowerF */) {
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_code_point_literals_should_use_uppercase_hexadecimal_digits);
            }
        }
        return false;
    }
    checkGrammarUnicodeCharacterLiteralCharacterNameCodePointDescription(node, text, pos) {
        let end = text.length;
        if (end - 1 > pos && text.charCodeAt(end - 1) === 62 /* GreaterThan */) {
            end--;
        }
        if (pos === end) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_that_includes_a_code_point_must_have_a_description);
        }
        if (!(0, scanner_1.isWhiteSpace)(text.charCodeAt(pos))) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_code_point_and_description_must_be_separated_by_whitespace);
        }
        pos++;
        if (pos === end) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_that_includes_a_code_point_must_have_a_description);
        }
        while (pos < end) {
            const ch = text.charCodeAt(pos);
            if (!(ch >= 0x20 && ch <= 0x7e)) {
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_code_point_description_may_only_contain_printable_ASCII_characters);
            }
            pos++;
        }
        return false;
    }
    checkGrammarUnicodeCharacterLiteralCharacterNameIdentifier(node, text) {
        let pos = 1;
        let end = text.length;
        if (end - 1 > pos && text.charCodeAt(end - 1) === 62 /* GreaterThan */) {
            end--;
        }
        pos++;
        if (pos < end) {
            const ch = text.charCodeAt(pos);
            if (!(0, scanner_1.isIdentifierStart)(ch)) {
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_must_be_an_ASCII_identifier);
            }
            pos++;
        }
        while (pos < end) {
            const ch = text.charCodeAt(pos);
            if (!(0, scanner_1.isIdentifierPart)(ch)) {
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_must_be_an_ASCII_identifier);
            }
            pos++;
        }
        return false;
    }
    checkGrammarUnicodeCharacterLiteralCharacterName(node, text) {
        if (text.length >= "<U+".length) {
            let ch = text.charCodeAt(1);
            if ((ch === 85 /* UpperU */ || ch === 117 /* LowerU */) && text.charCodeAt(2) === 43 /* Plus */) {
                let end = "<U+".length;
                while (end < text.length) {
                    ch = text.charCodeAt(end);
                    if (!(0, scanner_1.isHexDigit)(ch)) {
                        break;
                    }
                    end++;
                }
                if (end === "<U+".length) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_may_not_start_with_U_unless_it_is_a_valid_code_point);
                }
                if (this.checkGrammarUnicodeCharacterLiteralCodePointErrors(node, text, 1, end)) {
                    return true;
                }
                if (end === text.length || text.charCodeAt(end) === 62 /* GreaterThan */) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_that_includes_a_code_point_must_have_a_description);
                }
                if (end < text.length && !(0, scanner_1.isWhiteSpace)(text.charCodeAt(end))) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics.Unicode_character_name_literal_code_point_and_description_must_be_separated_by_whitespace);
                }
                return this.checkGrammarUnicodeCharacterLiteralCharacterNameCodePointDescription(node, text, end) ||
                    this.checkGrammarUnicodeCharacterLiteralCodePointWarnings(node, text, 1, end);
            }
        }
        return this.checkGrammarUnicodeCharacterLiteralCharacterNameIdentifier(node, text);
    }
    checkGrammarUnicodeCharacterLiteral(node) {
        if (!node.text) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        const ch = node.text.charCodeAt(0);
        if (ch === 85 /* UpperU */ || ch === 117 /* LowerU */) {
            return this.checkGrammarUnicodeCharacterLiteralCodePointErrors(node, node.text, 0, node.text.length) ||
                this.checkGrammarUnicodeCharacterLiteralCodePointWarnings(node, node.text, 0, node.text.length);
        }
        if (ch === 60 /* LessThan */) {
            return this.checkGrammarUnicodeCharacterLiteralCharacterName(node, node.text);
        }
        return false;
    }
    checkPlaceholder(node) {
    }
    checkNonterminal(node, allowOptional = false, allowArguments = true) {
        this.checkGrammarNonTerminal(node, allowOptional, allowArguments);
        if (this.getDefine(node, "noStrictParametricProductions") || !allowArguments) {
            this.checkNonterminalNonStrict(node);
        }
        else {
            this.checkNonterminalStrict(node);
        }
    }
    checkNonterminalNonStrict(node) {
        this.checkIdentifier(node.name);
        if (node.argumentList) {
            this.checkArgumentList(node.argumentList);
        }
    }
    checkNonterminalStrict(node) {
        var _a, _b, _c;
        const nonterminalName = node.name;
        const productionSymbol = this.checkIdentifier(nonterminalName);
        if (productionSymbol) {
            const production = this._bindings.getDeclarations(productionSymbol)[0];
            const parameterListElements = (_a = production.parameterList) === null || _a === void 0 ? void 0 : _a.elements;
            const argumentListElements = (_b = node.argumentList) === null || _b === void 0 ? void 0 : _b.elements;
            const nameSet = new Set();
            // Check each argument has a matching parameter.
            if (argumentListElements) {
                for (let i = 0; i < argumentListElements.length; i++) {
                    const argumentName = argumentListElements[i].name;
                    if (argumentName) {
                        const argumentNameText = argumentName.text;
                        if (argumentNameText) {
                            if (nameSet.has(argumentNameText)) {
                                this.reportError(argumentName, diagnostics_1.Diagnostics.Argument_0_cannot_be_specified_multiple_times, argumentNameText);
                            }
                            else {
                                nameSet.add(argumentNameText);
                                const parameterSymbol = this.resolveSymbol(production, argumentNameText, symbols_1.SymbolKind.Parameter);
                                if (!parameterSymbol) {
                                    this.reportError(argumentName, diagnostics_1.Diagnostics.Production_0_does_not_have_a_parameter_named_1_, productionSymbol.name, argumentNameText);
                                }
                            }
                        }
                    }
                }
            }
            // Check each parameter has a matching argument.
            if (parameterListElements) {
                for (let i = 0; i < parameterListElements.length; i++) {
                    const parameterNameText = (_c = parameterListElements[i].name) === null || _c === void 0 ? void 0 : _c.text;
                    if (parameterNameText && !nameSet.has(parameterNameText)) {
                        this.reportError(nonterminalName, diagnostics_1.Diagnostics.There_is_no_argument_given_for_parameter_0_, parameterNameText);
                    }
                }
            }
        }
        if (node.argumentList) {
            this.checkArgumentList(node.argumentList);
        }
    }
    checkArgumentList(node) {
        this.checkGrammarArgumentList(node);
        if (node.elements) {
            for (const element of node.elements) {
                this.checkArgument(element);
            }
        }
    }
    checkGrammarArgumentList(node) {
        var _a, _b;
        if (!node.openBracketToken) {
            return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.OpenBracketToken));
        }
        if (((_b = (_a = node.elements) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 0) {
            return this.reportGrammarError(node, node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.closeBracketToken) {
            return this.reportGrammarError(node, node.end, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return false;
    }
    checkArgument(node) {
        this.checkGrammarArgument(node);
        if (node.name)
            this.checkIdentifier(node.name);
    }
    checkGrammarArgument(node) {
        const parent = this._bindings.getParent(node);
        if ((parent === null || parent === void 0 ? void 0 : parent.kind) === tokens_1.SyntaxKind.Constraints) {
            if (!node.operatorToken) {
                return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.PlusToken, tokens_1.SyntaxKind.TildeToken]));
            }
            if (node.operatorToken.kind !== tokens_1.SyntaxKind.PlusToken
                && node.operatorToken.kind !== tokens_1.SyntaxKind.TildeToken) {
                return this.reportGrammarErrorForNode(node.operatorToken, diagnostics_1.Diagnostics.Unexpected_token_0_, (0, tokens_1.tokenToString)(node.operatorToken.kind));
            }
        }
        else {
            if (node.operatorToken
                && node.operatorToken.kind !== tokens_1.SyntaxKind.QuestionToken
                && node.operatorToken.kind !== tokens_1.SyntaxKind.PlusToken
                && node.operatorToken.kind !== tokens_1.SyntaxKind.TildeToken) {
                return this.reportGrammarErrorForNode(node.operatorToken, diagnostics_1.Diagnostics.Unexpected_token_0_, (0, tokens_1.tokenToString)(node.operatorToken.kind));
            }
            if (!node.operatorToken) {
                return this.reportGrammarError(node, node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.QuestionToken, tokens_1.SyntaxKind.PlusToken, tokens_1.SyntaxKind.TildeToken]));
            }
        }
        if (!node.name) {
            return this.reportGrammarError(node, node.operatorToken ? node.operatorToken.end : node.getStart(this._sourceFile), diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.Identifier));
        }
        return false;
    }
    reportInvalidSymbol(node) {
        this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([
            tokens_1.SyntaxKind.TerminalLiteral,
            tokens_1.SyntaxKind.Identifier,
            tokens_1.SyntaxKind.OpenBracketToken,
            tokens_1.SyntaxKind.OneKeyword
        ]));
    }
    markSymbolAsReferenced(symbol) {
        if (symbol) {
            this.getSymbolLinks(symbol, /*create*/ true).isReferenced = true;
        }
    }
    resolveIdentifier(node, reportErrors) {
        var _a, _b;
        let symbol = reportErrors ? undefined : this._bindings.getSymbol(node);
        if (!symbol && node.text) {
            const parent = this._bindings.getParent(node);
            if (parent) {
                switch (parent.kind) {
                    case tokens_1.SyntaxKind.Parameter:
                        symbol !== null && symbol !== void 0 ? symbol : (symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter));
                        if (reportErrors) {
                            let declarationSymbol = this._bindings.getSymbol(parent);
                            if (declarationSymbol !== symbol) {
                                this.reportError(node, diagnostics_1.Diagnostics.Duplicate_identifier_0_, node.text);
                            }
                        }
                        this._bindings._setSymbol(node, symbol);
                        return symbol;
                    case tokens_1.SyntaxKind.Production:
                        symbol = this._bindings.getSymbol(parent);
                        this._bindings._setSymbol(node, symbol);
                        return symbol;
                    case tokens_1.SyntaxKind.LookaheadAssertion:
                    case tokens_1.SyntaxKind.Nonterminal:
                        if (!symbol) {
                            symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production, reportErrors ? diagnostics_1.Diagnostics.Cannot_find_name_0_ : undefined);
                            this.markSymbolAsReferenced(symbol);
                        }
                        break;
                    case tokens_1.SyntaxKind.Argument:
                        const argument = parent;
                        if (((_a = argument.operatorToken) === null || _a === void 0 ? void 0 : _a.kind) === tokens_1.SyntaxKind.QuestionToken) {
                            symbol !== null && symbol !== void 0 ? symbol : (symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter));
                            if (!symbol && reportErrors) {
                                const production = this._bindings.getAncestor(argument, tokens_1.SyntaxKind.Production);
                                this.reportError(node, diagnostics_1.Diagnostics.Production_0_does_not_have_a_parameter_named_1_, production.name.text, node.text);
                            }
                            this.markSymbolAsReferenced(symbol);
                        }
                        else {
                            // get the symbol of the parameter of the target production
                            const nonterminal = this._bindings.getAncestor(parent, tokens_1.SyntaxKind.Nonterminal);
                            if ((_b = nonterminal === null || nonterminal === void 0 ? void 0 : nonterminal.name) === null || _b === void 0 ? void 0 : _b.text) {
                                const productionSymbol = this.resolveSymbol(node, nonterminal.name.text, symbols_1.SymbolKind.Production);
                                if (productionSymbol) {
                                    const production = this._bindings.getDeclarations(productionSymbol)[0];
                                    symbol !== null && symbol !== void 0 ? symbol : (symbol = this.resolveSymbol(production, node.text, symbols_1.SymbolKind.Parameter));
                                    if (!symbol && reportErrors) {
                                        this.reportError(node, diagnostics_1.Diagnostics.Production_0_does_not_have_a_parameter_named_1_, production.name.text, node.text);
                                    }
                                }
                            }
                            else {
                                const constraints = this._bindings.getAncestor(parent, tokens_1.SyntaxKind.Constraints);
                                if (constraints) {
                                    const production = this._bindings.getAncestor(constraints, tokens_1.SyntaxKind.Production);
                                    if (!symbol) {
                                        symbol = this.resolveSymbol(production, node.text, symbols_1.SymbolKind.Parameter);
                                        this.markSymbolAsReferenced(symbol);
                                    }
                                    if (!symbol && reportErrors) {
                                        this.reportError(node, diagnostics_1.Diagnostics.Production_0_does_not_have_a_parameter_named_1_, production.name.text, node.text);
                                    }
                                }
                            }
                        }
                        break;
                }
                this._bindings._setSymbol(node, symbol);
            }
        }
        return symbol;
    }
    checkIdentifier(node) {
        this.checkGrammarIdentifier(node);
        return this.resolveIdentifier(node, /*reportErrors*/ true);
    }
    checkGrammarIdentifier(node) {
        if (!node.text) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, (0, tokens_1.tokenToString)(tokens_1.SyntaxKind.Identifier));
        }
        return false;
    }
    getNodeLinks(node, create) {
        var _a, _b;
        let links = (_a = this._nodeLinks) === null || _a === void 0 ? void 0 : _a.get(node);
        if (!links && create)
            ((_b = this._nodeLinks) !== null && _b !== void 0 ? _b : (this._nodeLinks = new Map())).set(node, links = new NodeLinks());
        return links;
    }
    getSymbolLinks(symbol, create) {
        var _a, _b;
        let links = (_a = this._symbolLinks) === null || _a === void 0 ? void 0 : _a.get(symbol);
        if (!links && create)
            ((_b = this._symbolLinks) !== null && _b !== void 0 ? _b : (this._symbolLinks = new Map())).set(symbol, links = new SymbolLinks());
        return links;
    }
    resolveSymbol(location, name, meaning, diagnosticMessage) {
        const result = this._bindings.resolveSymbol(location, name, meaning);
        if (!result && diagnosticMessage) {
            this.reportError(location, diagnosticMessage, name);
        }
        return result;
    }
    reportError(location, diagnosticMessage, arg0, arg1, arg2) {
        var _a;
        const sourceFile = (_a = this._bindings.getSourceFile(location)) !== null && _a !== void 0 ? _a : this._sourceFile;
        if (sourceFile !== this._sourceFile) {
            this._diagnostics.setSourceFile(sourceFile);
            this._diagnostics.reportNode(sourceFile, location, diagnosticMessage, arg0, arg1, arg2);
            this._diagnostics.setSourceFile(this._sourceFile);
        }
        else {
            this._diagnostics.reportNode(sourceFile, location, diagnosticMessage, arg0, arg1, arg2);
        }
    }
    reportGrammarError(context, pos, diagnosticMessage, arg0, arg1, arg2) {
        var _a;
        const sourceFile = (_a = this._bindings.getSourceFile(context)) !== null && _a !== void 0 ? _a : this._sourceFile;
        if (sourceFile !== this._sourceFile) {
            this._diagnostics.setSourceFile(sourceFile);
            this._diagnostics.report(pos, diagnosticMessage, arg0, arg1, arg2);
            this._diagnostics.setSourceFile(this._sourceFile);
        }
        else {
            this._diagnostics.report(pos, diagnosticMessage, arg0, arg1, arg2);
        }
        return true;
    }
    reportGrammarErrorForNode(location, diagnosticMessage, arg0, arg1, arg2) {
        this.reportError(location, diagnosticMessage, arg0, arg1, arg2);
        return true;
    }
    reportGrammarErrorForNodeOrPos(context, location, pos, diagnosticMessage, arg0, arg1, arg2) {
        return location
            ? this.reportGrammarErrorForNode(location, diagnosticMessage, arg0, arg1, arg2)
            : this.reportGrammarError(context, pos, diagnosticMessage, arg0, arg1, arg2);
    }
    reportInvalidHtmlTrivia(nodes) {
        if (nodes === null || nodes === void 0 ? void 0 : nodes.length) {
            return this.reportGrammarErrorForNode(nodes[0], diagnostics_1.Diagnostics.HTML_trivia_not_allowed_here);
        }
        return false;
    }
}
exports.Checker = Checker;
/** {@docCategory Check} */
class Resolver {
    constructor(bindings, lineOffsetMap) {
        this.bindings = bindings;
        this._lineOffsetMap = lineOffsetMap;
    }
    /**
     * Gets the effective filename of a raw position within a source file, taking into account `@line` directives.
     */
    getEffectiveFilenameAtPosition(sourceFile, position) {
        var _a, _b;
        return (_b = (_a = this._lineOffsetMap) === null || _a === void 0 ? void 0 : _a.getEffectiveFilenameAtPosition(sourceFile, position)) !== null && _b !== void 0 ? _b : sourceFile.filename;
    }
    /**
     * Gets the effective position of a raw position within a source file, taking into account `@line` directives.
     */
    getEffectivePosition(sourceFile, position) {
        var _a, _b;
        return (_b = (_a = this._lineOffsetMap) === null || _a === void 0 ? void 0 : _a.getEffectivePosition(sourceFile, position)) !== null && _b !== void 0 ? _b : position;
    }
    /**
     * Gets the effective range of a raw range within a source file, taking into account `@line` directives.
     */
    getEffectiveRange(sourceFile, range) {
        var _a, _b;
        return (_b = (_a = this._lineOffsetMap) === null || _a === void 0 ? void 0 : _a.getEffectiveRange(sourceFile, range)) !== null && _b !== void 0 ? _b : range;
    }
    /**
     * Gets the filename of a parsed grammarkdown file for the provided effective filename and position, taking into account `@line` directives.
     */
    getRawFilenameAtEffectivePosition(filename, position) {
        var _a;
        return (_a = this._lineOffsetMap) === null || _a === void 0 ? void 0 : _a.getRawFilenameAtEffectivePosition(filename, position);
    }
    /**
     * Gets the position in a parsed grammarkdown file for the provided effective filename and position, taking into account `@line` directives.
     */
    getRawPositionFromEffectivePosition(filename, position) {
        var _a;
        return (_a = this._lineOffsetMap) === null || _a === void 0 ? void 0 : _a.getRawPositionFromEffectivePosition(filename, position);
    }
    /**
     * Gets the range in a parsed grammarkdown file for the provided effective filename and position, taking into account `@line` directives.
     */
    getRawRangeFromEffectiveRange(filename, range) {
        var _a;
        return (_a = this._lineOffsetMap) === null || _a === void 0 ? void 0 : _a.getRawRangeFromEffectiveRange(filename, range);
    }
    /**
     * Gets the parent `Node` for `node`.
     */
    getParent(node) {
        return this.bindings.getParent(node);
    }
    /**
     * Creates a `NodeNavigator` pointing at `node`. Returns `undefined` if `node` does not have a `SourceFile` as an ancestor.
     */
    createNavigator(node) {
        if (node.kind === tokens_1.SyntaxKind.SourceFile) {
            return new navigator_1.NodeNavigator(node);
        }
        else {
            const parent = this.bindings.getParent(node);
            if (parent) {
                const navigator = this.createNavigator(parent);
                if (navigator === null || navigator === void 0 ? void 0 : navigator.moveToFirstChild(child => child === node)) {
                    return navigator;
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the `SourceFile` of `node`, if it belongs to one.
     */
    getSourceFileOfNode(node) {
        return this.bindings.getAncestor(node, tokens_1.SyntaxKind.SourceFile);
    }
    /**
     * Gets the `Symbol` for `node`, if it has one.
     */
    getSymbolOfNode(node) {
        return this.bindings.getSymbol(node);
    }
    /**
     * Resolves a `Symbol` for the provided `name` at the given `location` that has the provided `meaning`.
     */
    resolveSymbol(location, name, meaning) {
        return this.bindings.resolveSymbol(location, name, meaning);
    }
    getDeclarations(node, meaning, location) {
        let symbol;
        if (typeof node === "string") {
            if (meaning === undefined)
                throw new TypeError("SymbolKind expected: meaning");
            if (location === undefined)
                throw new TypeError("Node expected: location");
            symbol = this.bindings.resolveSymbol(location, node, meaning);
        }
        else {
            const parent = this.bindings.getParent(node);
            symbol = this.bindings.getSymbol(node);
            if (!symbol && node.text) {
                symbol = this.bindings.resolveSymbol(node, node.text, getSymbolMeaning(parent));
            }
        }
        if (symbol) {
            return this.bindings.getDeclarations(symbol);
        }
        return [];
    }
    getReferences(node, meaning, location) {
        let symbol;
        if (typeof node === "string") {
            if (meaning === undefined)
                throw new TypeError("SymbolKind expected: meaning");
            if (location === undefined)
                throw new TypeError("Node expected: location");
            symbol = this.bindings.resolveSymbol(location, node, meaning);
        }
        else {
            const parent = this.bindings.getParent(node);
            if (parent) {
                symbol = parent.kind === tokens_1.SyntaxKind.Parameter
                    ? this.bindings.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter)
                    : this.bindings.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production);
            }
        }
        if (symbol) {
            return this.bindings.getReferences(symbol);
        }
        return [];
    }
    /**
     * Get the link id for the `Production` to which the provided `node` resolves.
     */
    getProductionLinkId(node) {
        const symbol = this.bindings.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production);
        return symbol === null || symbol === void 0 ? void 0 : symbol.name;
    }
    /**
     * Gets the right-hand-side link id for the provided `RightHandSide`.
     * @param includePrefix When `true`, prepends the production link id.
     */
    getRightHandSideLinkId(node, includePrefix) {
        var _a;
        let linkId;
        if ((_a = node.reference) === null || _a === void 0 ? void 0 : _a.text) {
            linkId = node.reference.text.replace(/[^a-z0-9]+/g, '-');
        }
        else {
            const digest = new RightHandSideDigest();
            linkId = digest.computeHash(node).toLowerCase();
        }
        if (includePrefix) {
            const production = this.bindings.getAncestor(node, tokens_1.SyntaxKind.Production);
            const productionId = this.getProductionLinkId(production.name);
            return productionId + "-" + linkId;
        }
        return linkId;
    }
}
exports.Resolver = Resolver;
class RightHandSideDigest {
    constructor() {
        this.spaceRequested = false;
    }
    computeHash(node) {
        this.writer = new stringwriter_1.StringWriter("\n");
        this.writeNode(node.constraints);
        this.writeNode(node.head);
        const hash = (0, crypto_1.createHash)("sha1");
        hash.update(this.writer.toString(), "utf8");
        const digest = hash.digest().toString("base64");
        const digestUrlSafe = digest.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
        return digestUrlSafe.slice(0, 8);
    }
    writeNode(node) {
        if (!node) {
            return;
        }
        switch (node.kind) {
            case tokens_1.SyntaxKind.Constraints:
                this.writeConstraints(node);
                break;
            case tokens_1.SyntaxKind.TerminalLiteral:
                this.writeTerminalLiteral(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.writeUnicodeCharacterLiteral(node);
                break;
            case tokens_1.SyntaxKind.Prose:
                this.writeProse(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.writeNonterminal(node);
                break;
            case tokens_1.SyntaxKind.Terminal:
                this.writeTerminal(node);
                break;
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.writeEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.writeLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.writeLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.writeNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseAssertion:
                this.writeProseAssertion(node);
                break;
            case tokens_1.SyntaxKind.ProseFull:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseHead:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseMiddle:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.ProseTail:
                this.writeProseFragmentLiteral(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.writeUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.ButNotSymbol:
                this.writeButNotSymbol(node);
                break;
            case tokens_1.SyntaxKind.OneOfSymbol:
                this.writeOneOfSymbol(node);
                break;
            case tokens_1.SyntaxKind.SymbolSpan:
                this.writeSymbolSpan(node);
                break;
            case tokens_1.SyntaxKind.SymbolSet:
                this.writeSymbolSet(node);
                break;
            case tokens_1.SyntaxKind.ArgumentList:
                this.writeArgumentList(node);
                break;
            case tokens_1.SyntaxKind.Argument:
                this.writeArgument(node);
                break;
            case tokens_1.SyntaxKind.Identifier:
                this.writeIdentifier(node);
                break;
            default:
                if ((node.kind >= tokens_1.SyntaxKind.FirstKeyword && node.kind <= tokens_1.SyntaxKind.LastKeyword) ||
                    (node.kind >= tokens_1.SyntaxKind.FirstPunctuation && node.kind <= tokens_1.SyntaxKind.LastPunctuation)) {
                    this.writeToken(node);
                    break;
                }
                else {
                    for (const child of node.children()) {
                        this.writeNode(child);
                    }
                    break;
                }
        }
    }
    write(text) {
        if (text) {
            if (this.spaceRequested && this.writer.size > 0) {
                this.spaceRequested = false;
                this.writer.write(" ");
            }
            this.writer.write(text);
        }
    }
    writeToken(node) {
        if (node) {
            this.write((0, tokens_1.tokenToString)(node.kind));
            this.spaceRequested = true;
        }
    }
    writeConstraints(node) {
        this.write("[");
        if (node.elements) {
            for (let i = 0; i < node.elements.length; ++i) {
                if (i > 0) {
                    this.write(", ");
                }
                this.writeNode(node.elements[i]);
            }
        }
        this.write("]");
        this.spaceRequested = true;
    }
    writeTerminal(node) {
        this.writeNode(node.literal);
        this.spaceRequested = false;
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    }
    writeTerminalLiteral(node) {
        this.write("`");
        this.write(node.text);
        this.write("`");
        this.spaceRequested = true;
    }
    writeUnicodeCharacterLiteral(node) {
        this.write("<");
        this.write(node.text);
        this.write(">");
        this.spaceRequested = true;
    }
    writeProse(node) {
        this.write("> ");
        if (node.fragments) {
            for (const fragment of node.fragments) {
                this.writeNode(fragment);
            }
        }
    }
    writeNonterminal(node) {
        this.writeNode(node.name);
        this.writeNode(node.argumentList);
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    }
    writeArgumentList(node) {
        this.write("[");
        if (node.elements) {
            for (let i = 0; i < node.elements.length; ++i) {
                if (i > 0) {
                    this.write(", ");
                }
                this.writeNode(node.elements[i]);
            }
        }
        this.write("]");
    }
    writeArgument(node) {
        this.writeNode(node.operatorToken);
        this.writeNode(node.name);
    }
    writeEmptyAssertion(node) {
        this.write("[empty]");
        this.spaceRequested = true;
    }
    writeLexicalGoalAssertion(node) {
        this.write("[lexical goal ");
        this.writeNode(node.symbol);
        this.spaceRequested = false;
        this.write("]");
        this.spaceRequested = true;
    }
    writeLookaheadAssertion(node) {
        this.write("[lookahead ");
        this.writeNode(node.operatorToken);
        this.writeNode(node.lookahead);
        this.spaceRequested = false;
        this.write("]");
        this.spaceRequested = true;
    }
    writeNoSymbolHereAssertion(node) {
        this.write("[no ");
        if (node.symbols) {
            for (let i = 0; i < node.symbols.length; ++i) {
                if (i > 0) {
                    this.write(" or ");
                }
                this.writeNode(node.symbols[i]);
                this.spaceRequested = false;
            }
        }
        this.write(" here]");
    }
    writeProseAssertion(node) {
        this.write("[>");
        this.spaceRequested = false;
        if (node.fragments) {
            for (const fragment of node.fragments) {
                if (fragment.kind === tokens_1.SyntaxKind.Identifier) {
                    this.write("|");
                    this.writeNode(fragment);
                    this.spaceRequested = false;
                    this.write("|");
                }
                else {
                    this.writeNode(fragment);
                }
            }
        }
        this.write("]");
        this.spaceRequested = true;
    }
    writeProseFragmentLiteral(node) {
        this.write(node.text);
    }
    writeUnicodeCharacterRange(node) {
        this.writeNode(node.left);
        this.writeNode(node.throughKeyword);
        this.writeNode(node.right);
        this.spaceRequested = true;
    }
    writeButNotSymbol(node) {
        this.writeNode(node.left);
        this.writeNode(node.butKeyword);
        this.writeNode(node.notKeyword);
        this.writeNode(node.right);
        this.spaceRequested = true;
    }
    writeOneOfSymbol(node) {
        this.write("one of ");
        if (node.symbols) {
            for (let i = 0; i < node.symbols.length; ++i) {
                if (i > 0) {
                    this.write(" or ");
                }
                this.writeNode(node.symbols[i]);
                this.spaceRequested = false;
            }
            this.spaceRequested = true;
        }
    }
    writeSymbolSpan(node) {
        this.writeNode(node.symbol);
        this.writeNode(node.next);
    }
    writeSymbolSet(node) {
        this.write("{ ");
        if (node.elements) {
            for (let i = 0; i < node.elements.length; ++i) {
                if (i > 0) {
                    this.write(", ");
                }
                this.writeNode(node.elements[i]);
                this.spaceRequested = false;
            }
        }
        this.write(" }");
        this.spaceRequested = true;
    }
    writeIdentifier(node) {
        this.write(node.text);
    }
}
function isAssertion(node) {
    if (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.EmptyAssertion:
            case tokens_1.SyntaxKind.LookaheadAssertion:
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
            case tokens_1.SyntaxKind.ProseAssertion:
            case tokens_1.SyntaxKind.InvalidAssertion:
                return true;
        }
    }
    return false;
}
function getSymbolMeaning(node) {
    if (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Parameter:
            case tokens_1.SyntaxKind.Argument:
            case tokens_1.SyntaxKind.Constraints:
                return symbols_1.SymbolKind.Parameter;
        }
    }
    return symbols_1.SymbolKind.Production;
}
//# sourceMappingURL=checker.js.map