"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringAsyncHost = exports.CoreAsyncHost = void 0;
const performance = require("./performance");
const parser_1 = require("./parser");
const core_1 = require("./core");
/**
 * A Host is a user-provided service that indicates how various Grammarkdown services
 * can interact with a file system. The `CoreAsyncHost` class provides the API surface that Grammarkdown
 * uses to interact with a host that is able to access the file system asynchronously.
 *
 * {@docCategory Hosts}
 */
class CoreAsyncHost {
    /**
     * @param options The options used to configure the host.
     * @param hostFallback An optional host to use as a fallback for operations not supported by this host.
     */
    constructor(options, hostFallback) {
        var _a;
        const { ignoreCase = (_a = hostFallback === null || hostFallback === void 0 ? void 0 : hostFallback.ignoreCase) !== null && _a !== void 0 ? _a : false, knownGrammars, useBuiltinGrammars = true, normalizeFile, resolveFile, resolveKnownGrammar, readFile, writeFile, } = options;
        this._ignoreCase = ignoreCase;
        this._useBuiltinGrammars = useBuiltinGrammars;
        if (knownGrammars) {
            for (const key in knownGrammars)
                if (Object.prototype.hasOwnProperty.call(knownGrammars, key)) {
                    this.registerKnownGrammar(key, knownGrammars[key]);
                }
        }
        this._normalizeFile = normalizeFile;
        this._resolveFile = resolveFile;
        this._resolveKnownGrammar = resolveKnownGrammar;
        this._readFile = readFile;
        this._writeFile = writeFile;
        this._hostFallback = hostFallback;
    }
    /**
     * Indicates whether comparisons for this host should be case insensitive.
     */
    get ignoreCase() {
        return this._ignoreCase;
    }
    /**
     * Gets the parser instance associated with this host.
     */
    get parser() {
        return this._innerParser
            || (this._innerParser = this.createParser());
    }
    /**
     * Creates a {@link StringAsyncHost} for the provided content.
     * @param content The content of the file.
     * @param file The file name for the content.
     * @param hostFallback An optional host to use as a fallback for operations not supported by this host.
     */
    static forFile(content, file = "file.grammar", hostFallback) {
        return new StringAsyncHost(file, content, hostFallback);
    }
    /**
     * Creates a `CoreAsyncHost`.
     * @param options The options used to configure the host.
     * @param hostFallback An optional host to use as a fallback for operations not supported by this host.
     */
    static from(custom, hostFallback) {
        return new CoreAsyncHost(custom, hostFallback);
    }
    /**
     * Normalize a file path's string representation for use as a key based on the case sensitivity of the host.
     * @param file The file path.
     */
    normalizeFile(file) {
        return this.normalizeFileCore(file);
    }
    /**
     * Returns the path for a known or built-in grammar based on its name (i.e., `"es2015"`, etc.)
     * @param name The name of the grammar.
     */
    resolveKnownGrammar(name) {
        var _a;
        return (_a = this.resolveKnownGrammarCore(name)) !== null && _a !== void 0 ? _a : (this._useBuiltinGrammars ? resolveBuiltInGrammar(name) : undefined);
    }
    /**
     * Registers a known grammar for use with `@import` directives.
     * @param name The name for the grammar.
     * @param file The file path of the grammar.
     */
    registerKnownGrammar(name, file) {
        this.registerKnownGrammarCore(name, file);
    }
    /**
     * Resolve the full path of a file relative to the provided referrer.
     * @param file The path to the requested file.
     * @param referrer An optional path indicating the file from which the path should be resolved.
     */
    resolveFile(file, referrer) {
        file = this.resolveKnownGrammar(file) || file;
        let result = this.resolveFileCore(file, referrer);
        result = result.replace(/\\/g, "/");
        return result;
    }
    /**
     * Parse a source file.
     * @param file The path to the source file.
     * @param text The text of the source file.
     * @param cancelable An optional cancelable object that can be used to abort a long-running parse.
     */
    parseSourceFile(file, text, cancelable) {
        performance.mark("beforeParse");
        try {
            return this.parser.parseSourceFile(file, text, cancelable);
        }
        finally {
            performance.mark("afterParse");
            performance.measure("parse", "beforeParse", "afterParse");
        }
    }
    /**
     * Reads a file from the host.
     * @param file The path to the file.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` for either a `string` containing the content if the file could be read, or `undefined` if the file could not be read.
     */
    async readFile(file, cancelable) {
        performance.mark("ioRead");
        try {
            return await this.readFileCore(file, (0, core_1.toCancelToken)(cancelable));
        }
        finally {
            performance.measure("ioRead", "ioRead");
        }
    }
    /**
     * Writes a file to the host.
     * @param file The path to the file.
     * @param text The contents of the file.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` that is settled when the operation completes.
     */
    async writeFile(file, text, cancelable) {
        performance.mark("ioWrite");
        try {
            await this.writeFileCore(file, text, (0, core_1.toCancelToken)(cancelable));
        }
        finally {
            performance.measure("ioWrite", "ioWrite");
        }
    }
    /**
     * Reads and parses a source file from the host.
     * @param file The path to the file.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` for either the parsed {@link SourceFile} of the file if the file could be read, or `undefined` if it could not be read.
     */
    async getSourceFile(file, cancelable) {
        cancelable = (0, core_1.toCancelToken)(cancelable);
        const result = await this.readFile(file, cancelable);
        return result !== undefined ? this.parseSourceFile(file, result, cancelable) : undefined;
    }
    /**
     * Creates a {@link Parser} for this host.
     * @virtual
     */
    createParser() {
        return new parser_1.Parser();
    }
    /**
     * When overridden in a derived class, normalizes a file path's string representation for use as a key based on the case sensitivity of the host.
     * @param file The file path.
     * @virtual
     */
    normalizeFileCore(file) {
        var _a;
        const normalizeFile = this._normalizeFile;
        if (normalizeFile) {
            return normalizeFile(file, (_a = this._normalizeFileCallback) !== null && _a !== void 0 ? _a : (this._normalizeFileCallback = this._normalizeFileFallback.bind(this)));
        }
        return this._normalizeFileFallback(file);
    }
    _normalizeFileFallback(file) {
        var _a, _b;
        return (_b = (_a = this._hostFallback) === null || _a === void 0 ? void 0 : _a.normalizeFile(file)) !== null && _b !== void 0 ? _b : (this.ignoreCase && !(0, core_1.isUri)(file) ? file.toUpperCase().toLowerCase() : file);
    }
    /**
     * When overridden in a derived class, resolves the full path of a file relative to the provided referrer.
     * @param file The path to the requested file.
     * @param referrer An optional path indicating the file from which the path should be resolved.
     * @virtual
     */
    resolveFileCore(file, referrer) {
        var _a;
        const resolveFile = this._resolveFile;
        if (resolveFile) {
            return resolveFile(file, referrer, (_a = this._resolveFileCallback) !== null && _a !== void 0 ? _a : (this._resolveFileCallback = this._resolveFileFallback.bind(this)));
        }
        return this._resolveFileFallback(file, referrer);
    }
    _resolveFileFallback(file, referrer) {
        if (this._hostFallback)
            return this._hostFallback.resolveFile(file, referrer);
        throw new Error("Cannot resolve a file without a fallback host.");
    }
    /**
     * When overridden in a derived class, returns the path for a known or built-in grammar based on its name (i.e., `"es2015"`, etc.)
     * @param name The name of the grammar.
     * @virtual
     */
    resolveKnownGrammarCore(name) {
        var _a;
        const resolveKnownGrammar = this._resolveKnownGrammar;
        if (resolveKnownGrammar) {
            return resolveKnownGrammar(name, (_a = this._resolveKnownGrammarCallback) !== null && _a !== void 0 ? _a : (this._resolveKnownGrammarCallback = this._resolveKnownGrammarFallback.bind(this)));
        }
        return this._resolveKnownGrammarFallback(name);
    }
    _resolveKnownGrammarFallback(name) {
        var _a;
        return (_a = this._hostFallback) === null || _a === void 0 ? void 0 : _a.resolveKnownGrammar(name);
    }
    /**
     * When overridden in a derived clas, registers a known grammar for use with `@import` directives.
     * @param name The name for the grammar.
     * @param file The file path of the grammar.
     * @virtual
     */
    registerKnownGrammarCore(name, file) {
        var _a;
        if (this._hostFallback)
            throw new Error("Known grammars must be registered on the fallback host.");
        ((_a = this._knownGrammars) !== null && _a !== void 0 ? _a : (this._knownGrammars = new Map())).set(name.toUpperCase(), file);
    }
    /**
     * When overridden in a derived class, reads a file from the host.
     * @param file The path to the file.
     * @param cancelToken A cancellation token that can be used by the caller to abort the operation.
     * @returns A `Promise` for either a `string` containing the content if the file could be read, or `undefined` if the file could not be read.
     * @virtual
     */
    async readFileCore(file, cancelToken) {
        var _a;
        const readFile = this._readFile;
        if (readFile) {
            return readFile(file, cancelToken, (_a = this._readFileCallback) !== null && _a !== void 0 ? _a : (this._readFileCallback = this._readFileFallback.bind(this)));
        }
        return this._readFileFallback(file, cancelToken);
    }
    async _readFileFallback(file, cancelToken) {
        if (this._hostFallback) {
            return this._hostFallback.readFile(file, cancelToken);
        }
        throw new Error(`File '${file}' cannot be read without a fallback host.`);
    }
    /**
     * When overridden in a derived class, writes a file to the host.
     * @param file The path to the file.
     * @param text The contents of the file.
     * @param cancelToken A cancellation token that can be used by the caller to abort the operation.
     * @returns A `Promise` that is settled when the operation completes.
     * @virtual
     */
    async writeFileCore(file, content, cancelToken) {
        var _a;
        const writeFile = this._writeFile;
        if (writeFile) {
            return writeFile(file, content, cancelToken, (_a = this._writeFileCallback) !== null && _a !== void 0 ? _a : (this._writeFileCallback = this._writeFileFallback.bind(this)));
        }
        return this._writeFileFallback(file, content, cancelToken);
    }
    async _writeFileFallback(file, content, cancelToken) {
        if (this._hostFallback) {
            return this._hostFallback.writeFile(file, content, cancelToken);
        }
        throw new Error(`Cannot write file without a fallback host.`);
    }
}
exports.CoreAsyncHost = CoreAsyncHost;
/**
 * An implementation of a {@link CoreAsyncHost} to simplify creating a host for a single file.
 *
 * {@docCategory Hosts}
 */
class StringAsyncHost extends CoreAsyncHost {
    /**
     * @param file The file name for the content.
     * @param content The content of the file.
     * @param hostFallback An optional host to use as a fallback for operations not supported by this host.
     */
    constructor(file, content, hostFallback) {
        super({
            normalizeFile: (file, fallback) => file === this.file ? file : fallback(file),
            resolveFile: (file, referrer, fallback) => file === this.file ? file : fallback(file, referrer),
            readFile: (file, cancelToken, fallback) => file === this.file ? this.content : fallback(file, cancelToken)
        }, hostFallback);
        this.file = file;
        this.content = content;
    }
}
exports.StringAsyncHost = StringAsyncHost;
let builtinGrammars;
function resolveBuiltInGrammar(name) {
    if (!builtinGrammars) {
        builtinGrammars = new Map([
            ["ES6", require.resolve("../grammars/es2015.grammar")],
            ["ES2015", require.resolve("../grammars/es2015.grammar")],
            ["ES2020", require.resolve("../grammars/es2020.grammar")],
            ["TS", require.resolve("../grammars/typescript.grammar")],
            ["TYPESCRIPT", require.resolve("../grammars/typescript.grammar")],
        ]);
    }
    return builtinGrammars.get(name.toUpperCase());
}
//# sourceMappingURL=host.js.map