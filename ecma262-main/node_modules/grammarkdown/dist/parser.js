"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = exports.TextChange = void 0;
const core_1 = require("./core");
const types_1 = require("./types");
const diagnostics_1 = require("./diagnostics");
const tokens_1 = require("./tokens");
const scanner_1 = require("./scanner");
const nodes_1 = require("./nodes");
const nodeInternal_1 = require("./nodeInternal");
var ParsingContext;
(function (ParsingContext) {
    ParsingContext[ParsingContext["SourceElements"] = 0] = "SourceElements";
    ParsingContext[ParsingContext["Parameters"] = 1] = "Parameters";
    ParsingContext[ParsingContext["Arguments"] = 2] = "Arguments";
    ParsingContext[ParsingContext["Constraints"] = 3] = "Constraints";
    ParsingContext[ParsingContext["RightHandSideListIndented"] = 4] = "RightHandSideListIndented";
    ParsingContext[ParsingContext["SymbolSet"] = 5] = "SymbolSet";
    ParsingContext[ParsingContext["OneOfList"] = 6] = "OneOfList";
    ParsingContext[ParsingContext["OneOfListIndented"] = 7] = "OneOfListIndented";
    ParsingContext[ParsingContext["OneOfSymbolList"] = 8] = "OneOfSymbolList";
    ParsingContext[ParsingContext["NoSymbolHere"] = 9] = "NoSymbolHere";
})(ParsingContext || (ParsingContext = {}));
/** {@docCategory Other} */
var TextChange;
(function (TextChange) {
    function create(text, range) {
        return { text, range };
    }
    TextChange.create = create;
    function clone(change) {
        return create(change.text, types_1.Range.clone(change.range));
    }
    TextChange.clone = clone;
    function isUnchanged(change) {
        return change.text.length === 0
            && types_1.Range.isCollapsed(change.range);
    }
    TextChange.isUnchanged = isUnchanged;
    function applyChange(originalText, change) {
        if (isUnchanged(change)) {
            return originalText;
        }
        const lineMap = new diagnostics_1.LineMap(originalText);
        const pos = lineMap.offsetAt(change.range.start);
        const end = lineMap.offsetAt(change.range.end);
        return originalText.substr(0, pos) + change.text + originalText.substr(end);
    }
    TextChange.applyChange = applyChange;
})(TextChange = exports.TextChange || (exports.TextChange = {}));
/** {@docCategory Parse} */
class Parser {
    // TODO(rbuckton): Incremental parser
    // public updateSourceFile(sourceFile: SourceFile, change: TextChange) {
    //     if (TextChange.isUnchanged(change)) {
    //         return sourceFile;
    //     }
    //     if (sourceFile.elements.length === 0) {
    //         return this.parseSourceFile(sourceFile.filename, change.text);
    //     }
    //     const navigator = new NodeNavigator(sourceFile);
    //     navigator.moveToPosition(change.range.start);
    //     navigator.moveToSourceElement();
    //     const startPos = navigator.getNode().pos;
    //     const startOffset = navigator.getOffset();
    //     navigator.moveToPosition(change.range.end);
    //     navigator.moveToSourceElement();
    //     const endPos = navigator.getNode().end;
    //     const endOffset = navigator.getOffset();
    //     // 1) replace the text from sourceFile.text with the specified changes
    //     // 2) create a new SourceFile, copying nodes from the original source file
    //     // up to startOffset
    //     // 3) parse the new text fragment, adding nodes to the new SourceFile
    //     // 4) clone nodes from the old source file to the new source file
    //     // with new positions
    // }
    parseSourceFile(filename, text, cancelable) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        const savedImports = this.imports;
        const savedDiagnostics = this.diagnostics;
        const savedCancellationToken = this.cancelToken;
        const savedScanner = this.scanner;
        const savedParsingContext = this.parsingContext;
        const savedTrivia = this.trivia;
        try {
            return this.parse(filename, text, /*previousSourceFile*/ undefined, /*changeRange*/ undefined, cancelToken);
        }
        finally {
            this.imports = savedImports;
            this.diagnostics = savedDiagnostics;
            this.cancelToken = savedCancellationToken;
            this.scanner = savedScanner;
            this.parsingContext = savedParsingContext;
            this.trivia = savedTrivia;
        }
    }
    parse(filename, text, previousSourceFile, changeRange, cancelToken) {
        const elements = [];
        const sourceFile = new nodes_1.SourceFile(filename, text, elements);
        this.imports = [];
        this.diagnostics = new diagnostics_1.DiagnosticMessages();
        this.diagnostics.setSourceFile(sourceFile);
        this.cancelToken = cancelToken;
        this.parsingContext = ParsingContext.SourceElements;
        this.trivia = undefined;
        this.scanner = new scanner_1.Scanner(filename, text, this.diagnostics, this.cancelToken);
        this.nextToken();
        this.parseSourceElementList(elements);
        (0, nodeInternal_1.getSourceFileAccessor)().setImports(sourceFile, this.imports);
        (0, nodeInternal_1.getSourceFileAccessor)().setParseDiagnostics(sourceFile, this.diagnostics);
        return sourceFile;
    }
    nextToken() {
        this.token = this.scanner.scan();
        const trivia = trimTrivia(this.scanner.getTrivia());
        if (trivia) {
            this.trivia || (this.trivia = new Map());
            this.trivia.set(this.scanner.getStartPos(), trivia);
        }
        return this.token;
    }
    lookahead(callback) {
        return this.speculate(callback, /*isLookahead*/ true);
    }
    // private tryParse<T>(callback: () => T): T {
    //     return this.speculate(callback, /*isLookahead*/ false);
    // }
    speculate(callback, isLookahead) {
        const savedToken = this.token;
        const savedParsingContext = this.parsingContext;
        const savedDiagnostics = this.diagnostics;
        const savedTrivia = this.trivia;
        if (this.trivia)
            this.trivia = new Map(this.trivia);
        this.diagnostics = diagnostics_1.NullDiagnosticMessages.instance;
        try {
            const result = this.scanner.speculate(callback, isLookahead);
            if (!result || isLookahead) {
                this.token = savedToken;
                this.parsingContext = savedParsingContext;
                this.trivia = savedTrivia;
            }
            return result;
        }
        finally {
            this.diagnostics = savedDiagnostics;
        }
    }
    isEOF() {
        return this.token === tokens_1.SyntaxKind.EndOfFileToken;
    }
    skipUntil(isRecoveryToken) {
        while (!isRecoveryToken(this.scanner) && !this.isEOF()) {
            this.nextToken();
        }
    }
    readTokenValue(token) {
        if (this.token === token) {
            const text = this.scanner.getTokenValue();
            this.nextToken();
            return text;
        }
        return undefined;
    }
    readTokenText(token) {
        if (this.token === token) {
            const text = this.scanner.getTokenText();
            this.nextToken();
            return (0, scanner_1.decodeHtmlEntities)(text);
        }
        return undefined;
    }
    finishNode(node, fullStart) {
        if (node) {
            (0, nodeInternal_1.getNodeAccessor)().setTextRange(node, fullStart, this.scanner.getStartPos());
            if (this.trivia) {
                attachTrivia(node, this.trivia.get(node.pos), this.trivia.get(node.end), this.scanner.hasPrecedingLineTerminator());
            }
            promoteTrivia(node, node.firstChild, node.lastChild);
        }
        return node;
    }
    parseToken(token) {
        if (this.token === token) {
            const fullStart = this.scanner.getStartPos();
            this.nextToken();
            return this.finishNode(new nodes_1.Token(token), fullStart);
        }
        return undefined;
    }
    parseAnyToken(predicate) {
        const token = this.token;
        if (predicate(token)) {
            const fullStart = this.scanner.getStartPos();
            this.nextToken();
            return this.finishNode(new nodes_1.Token(token), fullStart);
        }
        return undefined;
    }
    parseOptional(token) {
        if (this.token === token) {
            this.nextToken();
            return true;
        }
        else {
            return false;
        }
    }
    // list parsing
    isStartOfListElement() {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                return this.isStartOfSourceElement();
            case ParsingContext.Parameters:
                return this.isStartOfParameter();
            case ParsingContext.Arguments:
                return this.isStartOfArgument();
            case ParsingContext.Constraints:
                return this.isStartOfConstraint();
            case ParsingContext.RightHandSideListIndented:
                return this.isStartOfRightHandSide();
            case ParsingContext.SymbolSet:
                return this.token === tokens_1.SyntaxKind.TerminalLiteral || this.token === tokens_1.SyntaxKind.Identifier || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
                return this.token === tokens_1.SyntaxKind.TerminalLiteral || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            case ParsingContext.OneOfSymbolList:
                return this.token === tokens_1.SyntaxKind.TerminalLiteral || this.token === tokens_1.SyntaxKind.Identifier || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            case ParsingContext.NoSymbolHere:
                return this.token === tokens_1.SyntaxKind.TerminalLiteral || this.token === tokens_1.SyntaxKind.Identifier || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            default:
                return false;
        }
    }
    parseElement(listContext) {
        switch (listContext) {
            case ParsingContext.SourceElements:
                return this.parseSourceElement();
            case ParsingContext.Parameters:
                return this.parseParameter();
            case ParsingContext.Arguments:
                return this.parseArgument();
            case ParsingContext.Constraints:
                return this.parseConstraint();
            case ParsingContext.RightHandSideListIndented:
                return this.parseRightHandSide();
            case ParsingContext.SymbolSet:
                return this.parseSymbolSpan();
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
                return this.parseTerminalLiteral();
            case ParsingContext.OneOfSymbolList:
            case ParsingContext.NoSymbolHere:
                return this.parsePrimarySymbol(/*allowOptional*/ false);
            default:
                console.error(`Unexpected parsing context: ${this.parsingContext}`);
                return undefined;
        }
    }
    recover() {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                this.skipUntil(isSourceElementsRecoveryToken);
                break;
            case ParsingContext.Parameters:
                this.skipUntil(isAnyParametersRecoveryToken);
                break;
            case ParsingContext.Arguments:
                this.skipUntil(isAnyArgumentsRecoveryToken);
                break;
            case ParsingContext.Constraints:
                this.skipUntil(isAnyConstraintRecoveryToken);
                break;
            case ParsingContext.RightHandSideListIndented:
                this.skipUntil(isRightHandSideListIndentedRecoveryToken);
                break;
            case ParsingContext.SymbolSet:
                this.skipUntil(isSymbolSetRecoveryToken);
                break;
            case ParsingContext.OneOfList:
                this.skipUntil(isOneOfListRecoveryToken);
                break;
            case ParsingContext.OneOfListIndented:
                this.skipUntil(isOneOfListIndentedRecoveryToken);
                break;
            case ParsingContext.OneOfSymbolList:
                this.skipUntil(isOneOfSymbolListRecoveryToken);
                break;
            case ParsingContext.NoSymbolHere:
                this.skipUntil(isNoSymbolHereRecoveryToken);
                break;
        }
    }
    reportDiagnostics() {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics.Production_expected);
                break;
            case ParsingContext.Parameters:
            case ParsingContext.Arguments:
            case ParsingContext.Constraints:
                this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.CommaToken, tokens_1.SyntaxKind.CloseBracketToken]));
                break;
            case ParsingContext.SymbolSet:
                this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.CommaToken, tokens_1.SyntaxKind.CloseBraceToken]));
                break;
            case ParsingContext.OneOfList:
                this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.TerminalLiteral, "«line terminator»"]));
                break;
            case ParsingContext.OneOfListIndented:
                this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.TerminalLiteral, "«dedent»"]));
                break;
            case ParsingContext.RightHandSideListIndented:
                this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics.Production_expected);
                break;
        }
    }
    tryStopParsingList() {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                return this.token === tokens_1.SyntaxKind.EndOfFileToken;
            case ParsingContext.Parameters:
            case ParsingContext.Arguments:
            case ParsingContext.Constraints:
                return this.token === tokens_1.SyntaxKind.CloseBracketToken;
            case ParsingContext.RightHandSideListIndented:
                return this.token === tokens_1.SyntaxKind.EndOfFileToken
                    || this.scanner.hasPrecedingDedent()
                    || this.scanner.hasPrecedingBlankLine();
            case ParsingContext.SymbolSet:
                return this.token === tokens_1.SyntaxKind.CloseBraceToken;
            case ParsingContext.OneOfList:
                return this.token === tokens_1.SyntaxKind.EndOfFileToken
                    || this.scanner.hasPrecedingLineTerminator();
            case ParsingContext.OneOfListIndented:
                // OneOfListIndented does not consume the closing token
                return this.token === tokens_1.SyntaxKind.EndOfFileToken
                    || this.scanner.hasPrecedingDedent()
                    || this.scanner.hasPrecedingBlankLine();
            case ParsingContext.OneOfSymbolList:
                return this.token !== tokens_1.SyntaxKind.OrKeyword;
            case ParsingContext.NoSymbolHere:
                // NoSymbolHere does not consume the closing token
                return this.token === tokens_1.SyntaxKind.HereKeyword
                    || this.token === tokens_1.SyntaxKind.CloseBracketToken;
            default:
                return failUnhandled(this.parsingContext);
        }
    }
    tryMoveToNextElement(parsedPreviousElement) {
        switch (this.parsingContext) {
            case ParsingContext.Parameters:
            case ParsingContext.Arguments:
            case ParsingContext.Constraints:
            case ParsingContext.SymbolSet:
                return this.parseOptional(tokens_1.SyntaxKind.CommaToken);
            case ParsingContext.OneOfSymbolList:
            case ParsingContext.NoSymbolHere:
                return this.parseOptional(tokens_1.SyntaxKind.OrKeyword);
            case ParsingContext.SourceElements:
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
            case ParsingContext.RightHandSideListIndented:
                return parsedPreviousElement;
            default:
                return failUnhandled(this.parsingContext);
        }
    }
    parseList(listContext, result) {
        var _a;
        const saveContext = this.parsingContext;
        this.parsingContext = listContext;
        while (!this.isEOF()) {
            (_a = this.cancelToken) === null || _a === void 0 ? void 0 : _a.throwIfSignaled();
            let parsed = false;
            if (this.isStartOfListElement()) {
                parsed = true;
                if (!result) {
                    result = [];
                }
                const element = this.parseElement(listContext);
                if (element) {
                    result.push(element);
                }
                else {
                    this.recover();
                }
            }
            if (this.tryStopParsingList())
                break;
            if (!this.tryMoveToNextElement(parsed)) {
                const startPos = this.scanner.getStartPos();
                this.reportDiagnostics();
                this.recover();
                if (this.scanner.getStartPos() === startPos) {
                    this.nextToken();
                    this.recover();
                }
            }
        }
        this.parsingContext = saveContext;
        return result;
    }
    canBeIdentifier(kind) {
        if (kind === tokens_1.SyntaxKind.Identifier) {
            return true;
        }
        return kind >= tokens_1.SyntaxKind.FirstKeyword && kind <= tokens_1.SyntaxKind.LastKeyword;
    }
    parseIdentifier() {
        const fullStart = this.scanner.getStartPos();
        const text = this.canBeIdentifier(this.token) ? this.readTokenValue(this.token) : undefined;
        const node = new nodes_1.Identifier(text);
        return this.finishNode(node, fullStart);
    }
    parseUnicodeCharacterLiteral() {
        const fullStart = this.scanner.getStartPos();
        const text = this.readTokenText(tokens_1.SyntaxKind.UnicodeCharacterLiteral);
        const node = new nodes_1.UnicodeCharacterLiteral(text);
        return this.finishNode(node, fullStart);
    }
    parseProse(greaterThanToken) {
        const fragments = this.parseProseFragments();
        const node = new nodes_1.Prose(greaterThanToken, fragments);
        this.finishNode(node, greaterThanToken.pos);
        return node;
    }
    isStartOfParameter() {
        return this.canBeIdentifier(this.token);
    }
    parseParameter() {
        const fullStart = this.scanner.getStartPos();
        const name = this.parseIdentifier();
        const node = new nodes_1.Parameter(name);
        return this.finishNode(node, fullStart);
    }
    parseParameterListTail(openToken, parsingContext, closeTokenKind) {
        const elements = this.parseList(parsingContext);
        const closeToken = this.parseToken(closeTokenKind);
        const node = new nodes_1.ParameterList(openToken, elements, closeToken);
        return this.finishNode(node, openToken.pos);
    }
    tryParseParameterList() {
        const openBracketToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketToken);
        if (openBracketToken) {
            return this.parseParameterListTail(openBracketToken, ParsingContext.Parameters, tokens_1.SyntaxKind.CloseBracketToken);
        }
        return undefined;
    }
    parseOneOfList(oneKeyword) {
        const ofKeyword = this.parseToken(tokens_1.SyntaxKind.OfKeyword);
        const indented = this.scanner.hasPrecedingIndent();
        const terminals = this.parseList(indented ? ParsingContext.OneOfListIndented : ParsingContext.OneOfList);
        if (indented && !this.scanner.hasPrecedingDedent()) {
            this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics._0_expected, "«dedent»");
        }
        const node = new nodes_1.OneOfList(oneKeyword, ofKeyword, indented, terminals);
        return this.finishNode(node, oneKeyword.pos);
    }
    parseSymbolSetTail(openBraceToken) {
        const terminals = this.parseList(ParsingContext.SymbolSet);
        const closeBraceToken = this.parseToken(tokens_1.SyntaxKind.CloseBraceToken);
        const node = new nodes_1.SymbolSet(openBraceToken, terminals, closeBraceToken);
        return this.finishNode(node, openBraceToken.pos);
    }
    parseSymbolSpanRestOrSymbolSet() {
        const openBraceToken = this.parseToken(tokens_1.SyntaxKind.OpenBraceToken);
        if (openBraceToken) {
            return this.parseSymbolSetTail(openBraceToken);
        }
        else {
            return this.parseSymbolSpanRest();
        }
    }
    parseEmptyAssertionTail(openBracketToken, emptyKeyword) {
        const closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        const node = new nodes_1.EmptyAssertion(openBracketToken, emptyKeyword, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    }
    parseLookaheadAssertionTail(openBracketToken, lookaheadKeyword) {
        const operatorToken = this.parseAnyToken(isLookaheadOperatorToken);
        const lookahead = this.parseSymbolSpanRestOrSymbolSet();
        const closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        const node = new nodes_1.LookaheadAssertion(openBracketToken, lookaheadKeyword, operatorToken, lookahead, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    }
    parseNoSymbolHereAssertionTail(openBracketToken, noKeyword) {
        const symbols = this.parseList(ParsingContext.NoSymbolHere);
        const hereKeyword = this.parseToken(tokens_1.SyntaxKind.HereKeyword);
        const closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        const node = new nodes_1.NoSymbolHereAssertion(openBracketToken, noKeyword, symbols, hereKeyword, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    }
    parseLexicalGoalAssertionTail(openBracketToken, lexicalKeyword) {
        const goalKeyword = this.parseToken(tokens_1.SyntaxKind.GoalKeyword);
        const symbol = this.parseIdentifier();
        const closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        const node = new nodes_1.LexicalGoalAssertion(openBracketToken, lexicalKeyword, goalKeyword, symbol, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    }
    parseInvalidAssertionTail(openBracketToken) {
        this.skipUntil(isInvalidConstraintTailRecoveryToken);
        const closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        const node = new nodes_1.InvalidAssertion(openBracketToken, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    }
    parseAssertion(openBracketToken) {
        const emptyKeyword = this.parseToken(tokens_1.SyntaxKind.EmptyKeyword);
        if (emptyKeyword) {
            return this.parseEmptyAssertionTail(openBracketToken, emptyKeyword);
        }
        const lookaheadKeyword = this.parseToken(tokens_1.SyntaxKind.LookaheadKeyword);
        if (lookaheadKeyword) {
            return this.parseLookaheadAssertionTail(openBracketToken, lookaheadKeyword);
        }
        const noKeyword = this.parseToken(tokens_1.SyntaxKind.NoKeyword);
        if (noKeyword) {
            return this.parseNoSymbolHereAssertionTail(openBracketToken, noKeyword);
        }
        const lexicalKeyword = this.parseToken(tokens_1.SyntaxKind.LexicalKeyword);
        if (lexicalKeyword) {
            return this.parseLexicalGoalAssertionTail(openBracketToken, lexicalKeyword);
        }
        return this.parseInvalidAssertionTail(openBracketToken);
    }
    parseProseAssertion(openBracketToken) {
        const fragments = this.parseProseFragments();
        const closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        const node = new nodes_1.ProseAssertion(openBracketToken, fragments, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    }
    parseProseFragments() {
        let fragments;
        while (this.token) {
            if (this.token === tokens_1.SyntaxKind.ProseFull) {
                if (!fragments)
                    fragments = [];
                fragments.push(this.parseProseFragmentLiteral(this.token));
                break;
            }
            else if (this.token >= tokens_1.SyntaxKind.FirstProseFragmentLiteral && this.token <= tokens_1.SyntaxKind.LastProseFragmentLiteral) {
                if (!fragments)
                    fragments = [];
                fragments.push(this.parseProseFragmentLiteral(this.token));
            }
            else if (this.token === tokens_1.SyntaxKind.TerminalLiteral) {
                if (!fragments)
                    fragments = [];
                fragments.push(this.parseTerminal(/*allowOptional*/ false));
            }
            else if (this.token === tokens_1.SyntaxKind.Identifier) {
                if (!fragments)
                    fragments = [];
                fragments.push(this.parseNonterminal(/*allowArgumentList*/ false, /*allowOptional*/ false));
            }
            else {
                break;
            }
        }
        return fragments;
    }
    parseProseFragmentLiteral(token) {
        const fullStart = this.scanner.getStartPos();
        const text = this.readTokenValue(token);
        const node = new nodes_1.ProseFragmentLiteral(token, text);
        return this.finishNode(node, fullStart);
    }
    parseTerminalLiteral() {
        const fullStart = this.scanner.getStartPos();
        const text = this.readTokenValue(tokens_1.SyntaxKind.TerminalLiteral);
        const node = new nodes_1.TerminalLiteral(text);
        return this.finishNode(node, fullStart);
    }
    parseTerminal(allowOptional) {
        const fullStart = this.scanner.getStartPos();
        const literal = this.parseTerminalLiteral();
        const questionToken = allowOptional ? this.parseToken(tokens_1.SyntaxKind.QuestionToken) : undefined;
        const node = new nodes_1.Terminal(literal, questionToken);
        return this.finishNode(node, fullStart);
    }
    isStartOfArgument() {
        return isArgumentOperatorToken(this.token)
            || this.canBeIdentifier(this.token);
    }
    parseArgument() {
        const fullStart = this.scanner.getStartPos();
        const operatorToken = this.parseAnyToken(isArgumentOperatorToken);
        const name = this.parseIdentifier();
        const node = new nodes_1.Argument(operatorToken, name);
        return this.finishNode(node, fullStart);
    }
    parseArgumentListTail(openToken, parsingContext, closeTokenKind) {
        const elements = this.parseList(parsingContext);
        const closeToken = this.parseToken(closeTokenKind);
        const node = new nodes_1.ArgumentList(openToken, elements, closeToken);
        this.finishNode(node, openToken.pos);
        return node;
    }
    tryParseArgumentList() {
        if (this.scanner.hasPrecedingLineTerminator() && !this.scanner.isLineContinuation())
            return undefined;
        if (this.isStartOfArgumentList()) {
            const openBracketToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketToken);
            if (openBracketToken) {
                return this.parseArgumentListTail(openBracketToken, ParsingContext.Arguments, tokens_1.SyntaxKind.CloseBracketToken);
            }
        }
        return undefined;
    }
    isStartOfArgumentList() {
        if (this.token === tokens_1.SyntaxKind.OpenBracketToken) {
            return this.lookahead(() => this.nextTokenIsArgument());
        }
        return false;
    }
    nextTokenIsArgument() {
        this.nextToken();
        return isArgumentOperatorToken(this.token)
            || this.token === tokens_1.SyntaxKind.Identifier;
    }
    isStartOfConstraint() {
        return isConstraintOperatorToken(this.token);
    }
    parseConstraint() {
        const fullStart = this.scanner.getStartPos();
        const operatorToken = this.parseAnyToken(isConstraintOperatorToken);
        const name = this.parseIdentifier();
        const node = new nodes_1.Argument(operatorToken, name);
        return this.finishNode(node, fullStart);
    }
    parseNonterminal(allowArgumentList, allowOptional) {
        const fullStart = this.scanner.getStartPos();
        const name = this.parseIdentifier();
        const argumentList = allowArgumentList ? this.tryParseArgumentList() : undefined;
        const questionToken = allowOptional ? this.parseToken(tokens_1.SyntaxKind.QuestionToken) : undefined;
        const node = new nodes_1.Nonterminal(name, argumentList, questionToken);
        return this.finishNode(node, fullStart);
    }
    parseOneOfSymbol(oneKeyword) {
        const ofKeyword = this.parseToken(tokens_1.SyntaxKind.OfKeyword);
        const symbols = this.parseList(ParsingContext.OneOfSymbolList);
        const node = new nodes_1.OneOfSymbol(oneKeyword, ofKeyword, symbols);
        this.finishNode(node, oneKeyword.pos);
        return node;
    }
    parsePlaceholderSymbol(placeholderToken) {
        const node = new nodes_1.PlaceholderSymbol(placeholderToken);
        this.finishNode(node, placeholderToken.pos);
        return node;
    }
    parseInvalidSymbol() {
        const fullStart = this.scanner.getStartPos();
        const node = new nodes_1.InvalidSymbol();
        this.skipUntil(isInvalidSymbolRecoveryToken);
        return this.finishNode(node, fullStart);
    }
    parseUnicodeCharacterRangeOrHigher(allowOptional) {
        const fullStart = this.scanner.getStartPos();
        const literal = this.parseUnicodeCharacterLiteral();
        const questionToken = allowOptional ? this.parseToken(tokens_1.SyntaxKind.QuestionToken) : undefined;
        if (!questionToken) {
            const throughKeyword = this.parseToken(tokens_1.SyntaxKind.ThroughKeyword);
            if (throughKeyword) {
                return this.parseUnicodeCharacterRangeTail(literal, throughKeyword);
            }
        }
        const node = new nodes_1.Terminal(literal, questionToken);
        return this.finishNode(node, fullStart);
    }
    parseUnicodeCharacterRangeTail(left, throughKeyword) {
        const right = this.parseUnicodeCharacterLiteral();
        const node = new nodes_1.UnicodeCharacterRange(left, throughKeyword, right);
        this.finishNode(node, left.pos);
        return node;
    }
    parsePrimarySymbol(allowOptional) {
        switch (this.token) {
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                return this.parseUnicodeCharacterRangeOrHigher(allowOptional);
            case tokens_1.SyntaxKind.TerminalLiteral:
                return this.parseTerminal(allowOptional);
            case tokens_1.SyntaxKind.Identifier:
                return this.parseNonterminal(/*allowArgumentList*/ true, allowOptional);
        }
        const placeholderToken = this.parseToken(tokens_1.SyntaxKind.AtToken);
        if (placeholderToken) {
            return this.parsePlaceholderSymbol(placeholderToken);
        }
        return this.parseInvalidSymbol();
    }
    parseUnarySymbol() {
        const oneKeyword = this.parseToken(tokens_1.SyntaxKind.OneKeyword);
        if (oneKeyword) {
            return this.parseOneOfSymbol(oneKeyword);
        }
        return this.parsePrimarySymbol(/*allowOptional*/ true);
    }
    parseButNotSymbolTail(left, butKeyword, notKeyword) {
        const right = this.parseSymbol();
        const node = new nodes_1.ButNotSymbol(left, butKeyword, notKeyword, right);
        this.finishNode(node, left.pos);
        return node;
    }
    parseSymbol() {
        const openBracketToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketToken);
        if (openBracketToken) {
            return this.parseAssertion(openBracketToken);
        }
        const openBracketGreaterThanToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketGreaterThanToken);
        if (openBracketGreaterThanToken) {
            return this.parseProseAssertion(openBracketGreaterThanToken);
        }
        const symbol = this.parseUnarySymbol();
        const butKeyword = this.parseToken(tokens_1.SyntaxKind.ButKeyword);
        const notKeyword = this.parseToken(tokens_1.SyntaxKind.NotKeyword);
        if (butKeyword || notKeyword) {
            return this.parseButNotSymbolTail(symbol, butKeyword, notKeyword);
        }
        return symbol;
    }
    tryParseSymbolSpan() {
        if (this.isStartOfSymbolSpanOnSameLine()) {
            return this.parseSymbolSpanRest();
        }
        return undefined;
    }
    parseSymbolSpanRest() {
        const fullStart = this.scanner.getStartPos();
        const symbol = this.parseSymbol();
        const next = this.tryParseSymbolSpan();
        const node = new nodes_1.SymbolSpan(symbol, next);
        return this.finishNode(node, fullStart);
    }
    parseSymbolSpan() {
        const greaterThanToken = this.parseToken(tokens_1.SyntaxKind.GreaterThanToken);
        if (greaterThanToken) {
            const symbol = this.parseProse(greaterThanToken);
            const node = new nodes_1.SymbolSpan(symbol, /*next*/ undefined);
            this.finishNode(node, greaterThanToken.pos);
            return node;
        }
        else {
            return this.parseSymbolSpanRest();
        }
    }
    isStartOfSymbolSpanOnSameLine() {
        return (!this.scanner.hasPrecedingLineTerminator() || this.scanner.isLineContinuation())
            && this.isStartOfSymbolSpan();
    }
    isStartOfSymbolSpan() {
        switch (this.token) {
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
            case tokens_1.SyntaxKind.TerminalLiteral:
            case tokens_1.SyntaxKind.Identifier:
            case tokens_1.SyntaxKind.OpenBracketToken:
            case tokens_1.SyntaxKind.OpenBracketGreaterThanToken:
            case tokens_1.SyntaxKind.GreaterThanToken:
            case tokens_1.SyntaxKind.AtToken:
                return true;
            default:
                return false;
        }
    }
    isStartOfRightHandSide() {
        return this.isStartOfSymbolSpan();
    }
    parseLinkReference() {
        if (this.token === tokens_1.SyntaxKind.LinkReference) {
            const fullStart = this.scanner.getStartPos();
            const text = this.readTokenValue(tokens_1.SyntaxKind.LinkReference);
            const node = new nodes_1.LinkReference(text);
            return this.finishNode(node, fullStart);
        }
        return undefined;
    }
    nextTokenIsConstraintOperatorToken() {
        this.nextToken();
        return isConstraintOperatorToken(this.token);
    }
    tryParseConstraints() {
        if (this.token === tokens_1.SyntaxKind.OpenBracketToken &&
            this.lookahead(() => this.nextTokenIsConstraintOperatorToken())) {
            const openBracketToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketToken);
            const elements = this.parseList(ParsingContext.Constraints);
            const closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
            const node = new nodes_1.Constraints(openBracketToken, elements, closeBracketToken);
            return this.finishNode(node, openBracketToken.pos);
        }
    }
    parseRightHandSide() {
        const fullStart = this.scanner.getStartPos();
        const constraints = this.tryParseConstraints();
        const head = constraints ? this.tryParseSymbolSpan() : this.parseSymbolSpan();
        const reference = this.parseLinkReference();
        const node = new nodes_1.RightHandSide(constraints, head, reference);
        return this.finishNode(node, fullStart);
    }
    parseRightHandSideList() {
        const fullStart = this.scanner.getStartPos();
        const elements = this.scanner.hasPrecedingIndent() && this.parseList(ParsingContext.RightHandSideListIndented) || [];
        const node = new nodes_1.RightHandSideList(elements);
        return this.finishNode(node, fullStart);
    }
    parseBody() {
        const oneKeyword = this.parseToken(tokens_1.SyntaxKind.OneKeyword);
        if (oneKeyword) {
            return this.parseOneOfList(oneKeyword);
        }
        if (this.scanner.hasPrecedingLineTerminator()) {
            return this.parseRightHandSideList();
        }
        else {
            return this.parseRightHandSide();
        }
    }
    parseProduction() {
        const fullStart = this.scanner.getStartPos();
        const name = this.parseIdentifier();
        const parameters = this.tryParseParameterList();
        const colonToken = this.parseAnyToken(isProductionSeparatorToken);
        const body = this.parseBody();
        const node = new nodes_1.Production(name, parameters, colonToken, body);
        return this.finishNode(node, fullStart);
    }
    parseStringLiteral() {
        if (this.token === tokens_1.SyntaxKind.StringLiteral) {
            const fullStart = this.scanner.getStartPos();
            const text = this.scanner.getTokenValue();
            const node = new nodes_1.StringLiteral(text);
            this.nextToken();
            return this.finishNode(node, fullStart);
        }
        return undefined;
    }
    parseNumberLiteral() {
        if (this.token === tokens_1.SyntaxKind.NumberLiteral) {
            const fullStart = this.scanner.getStartPos();
            const text = this.scanner.getTokenValue();
            const node = new nodes_1.NumberLiteral(text);
            this.nextToken();
            return this.finishNode(node, fullStart);
        }
        return undefined;
    }
    parseMetaElement(atToken) {
        const importKeyword = this.parseToken(tokens_1.SyntaxKind.ImportKeyword);
        if (importKeyword) {
            return this.parseImport(atToken, importKeyword);
        }
        const defineKeyword = this.parseToken(tokens_1.SyntaxKind.DefineKeyword);
        if (defineKeyword) {
            return this.parseDefine(atToken, defineKeyword);
        }
        const lineKeyword = this.parseToken(tokens_1.SyntaxKind.LineKeyword);
        if (lineKeyword) {
            return this.parseLine(atToken, lineKeyword);
        }
        this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics._0_expected, (0, diagnostics_1.formatList)([tokens_1.SyntaxKind.ImportKeyword, tokens_1.SyntaxKind.DefineKeyword, tokens_1.SyntaxKind.LineKeyword]));
        return undefined;
    }
    parseImport(atToken, importKeyword) {
        const path = this.parseStringLiteral();
        const node = new nodes_1.Import(atToken, importKeyword, path);
        this.finishNode(node, atToken.pos);
        if (node.path && node.path.text)
            this.imports.push(node.path.text);
        return node;
    }
    parseDefine(atToken, defineKeyword) {
        const key = this.parseIdentifier();
        const valueToken = this.parseAnyToken(isBooleanLiteralToken) || this.parseToken(tokens_1.SyntaxKind.DefaultKeyword);
        const node = new nodes_1.Define(atToken, defineKeyword, key, valueToken);
        this.finishNode(node, atToken.pos);
        return node;
    }
    parseLine(atToken, lineKeyword) {
        const defaultKeyword = this.parseToken(tokens_1.SyntaxKind.DefaultKeyword);
        const number = !defaultKeyword ? this.parseNumberLiteral() : undefined;
        const path = !defaultKeyword ? this.parseStringLiteral() : undefined;
        const node = new nodes_1.Line(atToken, lineKeyword, defaultKeyword || number, path);
        this.finishNode(node, atToken.pos);
        return node;
    }
    isStartOfSourceElement() {
        if (this.scanner.isIndented())
            return false;
        switch (this.token) {
            case tokens_1.SyntaxKind.AtToken: // Import
            case tokens_1.SyntaxKind.Identifier: // Production
                return true;
            case tokens_1.SyntaxKind.ColonToken:
            case tokens_1.SyntaxKind.ColonColonToken:
            case tokens_1.SyntaxKind.ColonColonColonToken:
            case tokens_1.SyntaxKind.OpenParenToken:
                // Assume we're parsing a production for error recovery purposes
                return true;
            default:
                return false;
        }
    }
    parseSourceElement() {
        let node;
        if (this.token === tokens_1.SyntaxKind.Identifier) {
            node = this.parseProduction();
        }
        else {
            const atToken = this.parseToken(tokens_1.SyntaxKind.AtToken);
            if (atToken) {
                node = this.parseMetaElement(atToken);
            }
        }
        if (node) {
            this.scanner.resetIndent();
            return node;
        }
        this.diagnostics.report(this.scanner.getTokenPos(), diagnostics_1.Diagnostics.Unexpected_token_0_, (0, tokens_1.tokenToString)(this.token));
        return undefined;
    }
    parseSourceElementList(elements) {
        return this.parseList(ParsingContext.SourceElements, elements);
    }
}
exports.Parser = Parser;
function isSourceElementsRecoveryToken(scanner) {
    return scanner.hasPrecedingDedent()
        || scanner.hasPrecedingBlankLine();
}
function isAnyParametersRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseParenToken
        || token === tokens_1.SyntaxKind.CloseBracketToken
        || token === tokens_1.SyntaxKind.ColonToken
        || token === tokens_1.SyntaxKind.ColonColonToken
        || token === tokens_1.SyntaxKind.ColonColonColonToken
        || scanner.hasPrecedingDedent()
        || scanner.hasPrecedingBlankLine()
        || scanner.hasPrecedingLineTerminator() && !scanner.isLineContinuation();
}
function isAnyArgumentsRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseParenToken
        || token === tokens_1.SyntaxKind.CloseBracketToken
        || scanner.hasPrecedingDedent()
        || scanner.hasPrecedingBlankLine()
        || (scanner.hasPrecedingLineTerminator() && !scanner.isLineContinuation());
}
function isAnyConstraintRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseParenToken
        || token === tokens_1.SyntaxKind.CloseBracketToken
        || scanner.hasPrecedingDedent()
        || scanner.hasPrecedingBlankLine()
        || (scanner.hasPrecedingLineTerminator() && !scanner.isLineContinuation());
}
function isRightHandSideListIndentedRecoveryToken(scanner) {
    return scanner.hasPrecedingDedent()
        || scanner.hasPrecedingBlankLine()
        || scanner.hasPrecedingLineTerminator() && !scanner.isLineContinuation();
}
function isSymbolSetRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.TerminalLiteral
        || token === tokens_1.SyntaxKind.CloseBraceToken
        || scanner.hasPrecedingLineTerminator() && !scanner.isLineContinuation();
}
function isOneOfListRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.TerminalLiteral
        || scanner.hasPrecedingLineTerminator();
}
function isOneOfListIndentedRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.TerminalLiteral
        || scanner.hasPrecedingLineTerminator();
}
function isOneOfSymbolListRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.OrKeyword
        || token === tokens_1.SyntaxKind.TerminalLiteral
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.OpenBracketToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || scanner.hasPrecedingLineTerminator();
}
function isNoSymbolHereRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.OrKeyword
        || token === tokens_1.SyntaxKind.HereKeyword
        || token === tokens_1.SyntaxKind.TerminalLiteral
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseBracketToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || scanner.hasPrecedingLineTerminator();
}
function isInvalidSymbolRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.OpenBracketToken
        || token === tokens_1.SyntaxKind.TerminalLiteral
        || token === tokens_1.SyntaxKind.Identifier
        || scanner.hasPrecedingLineTerminator();
}
function isInvalidConstraintTailRecoveryToken(scanner) {
    const token = scanner.getToken();
    return token === tokens_1.SyntaxKind.CloseBracketToken
        || token === tokens_1.SyntaxKind.TerminalLiteral
        || scanner.hasPrecedingLineTerminator();
}
function isProductionSeparatorToken(token) {
    return token === tokens_1.SyntaxKind.ColonToken
        || token === tokens_1.SyntaxKind.ColonColonToken
        || token === tokens_1.SyntaxKind.ColonColonColonToken;
}
function isArgumentOperatorToken(token) {
    return token === tokens_1.SyntaxKind.QuestionToken
        || token === tokens_1.SyntaxKind.PlusToken
        || token === tokens_1.SyntaxKind.TildeToken;
}
function isConstraintOperatorToken(token) {
    return token === tokens_1.SyntaxKind.PlusToken
        || token === tokens_1.SyntaxKind.TildeToken;
}
function isBooleanLiteralToken(token) {
    return token === tokens_1.SyntaxKind.TrueKeyword
        || token === tokens_1.SyntaxKind.FalseKeyword;
}
function isLookaheadOperatorToken(token) {
    return token === tokens_1.SyntaxKind.EqualsToken
        || token === tokens_1.SyntaxKind.EqualsEqualsToken
        || token === tokens_1.SyntaxKind.ExclamationEqualsToken
        || token === tokens_1.SyntaxKind.NotEqualToToken
        || token === tokens_1.SyntaxKind.LessThanMinusToken
        || token === tokens_1.SyntaxKind.ElementOfToken
        || token === tokens_1.SyntaxKind.LessThanExclamationToken
        || token === tokens_1.SyntaxKind.NotAnElementOfToken;
}
function matched(possibleOpenTag, possibleCloseTag) {
    return possibleOpenTag.kind === tokens_1.SyntaxKind.HtmlOpenTagTrivia
        && possibleCloseTag.kind === tokens_1.SyntaxKind.HtmlCloseTagTrivia
        && possibleOpenTag.tagName === possibleCloseTag.tagName;
}
// remove empty html trivia
function trimTrivia(trivia) {
    let result;
    if (trivia) {
        let right;
        for (let i = 0; i < trivia.length - 1; i++) {
            const left = trivia[i];
            right = trivia[i + 1];
            if (matched(left, right)) {
                result || (result = trivia.slice(0, i));
                right = undefined;
            }
            else {
                result === null || result === void 0 ? void 0 : result.push(left);
            }
        }
        if (right)
            result === null || result === void 0 ? void 0 : result.push(right);
    }
    return result || trivia;
}
function splitTrivia(triviaArray, hasFollowingLineTerminator) {
    // Leading trivia is trivia that belongs to the beginning of the node:
    //
    // - An HTML close tag trivia, or any trivia preceding an HTML close tag trivia, is not leading trivia of the node.
    // - An HTML open tag trivia, and any trivia following an HTML open tag trivia, is leading trivia of the node.
    // - If the node has a preceding line break, then
    //   - Any other non-HTML tag trivia on the same line as the node that precedes the node is leading trivia of the node.
    //   - Any other non-HTML tag trivia on a line that precedes the node, but not preceding a blank line, is leading trivia of the node.
    // - Otherwise,
    //   - Any other non-HTML tag trivia on the same line as the node that precedes the node is leading trivia, if there is no whitespace between
    //     that trivia and the node.
    // Trailing trivia is trivia that belongs to the end of the node:
    //
    // - An HTML open tag trivia, or any trivia following an HTML open tag trivia, is not trailing trivia of the node.
    // - An HTML close tag trivia, and any trivia preceding an HTML close tag trivia, is trailing trivia of the node.
    // - If the node has a trailing line break, then
    //   - Any other non-HTML tag trivia on the same line as the node that follows the node is trailing trivia of the node.
    //   - Any other non-HTML tag trivia on a line that follows the node, but not following a blank line, is trailing trivia of the node.
    // - Otherwise,
    //   - Any other non-HTML tag trivia on the same line as the node that follows the node is trailing trivia, if there is no whitespace between
    //     that trivia and the node.
    // Detached trivia is any trivia that occurs prior to the node that is not the leading or trailing trivia of this
    // or any other node.
    if (!triviaArray.length)
        return { trailingEnd: 0, leadingStart: 0 };
    let hasLineTerminator = hasFollowingLineTerminator; // Used by all trivia to determine whether to break on blank lines or whitespace.
    let lastHtmlCloseTagIndex = -1; // Used by leading/detached trivia to exclude trivia at or before this index.
    // Used by trailing trivia to include trivia at or before this index.
    let lastFollowingBlankLineIndex = -1; // Used by leading/detached trivia to exclude trivia at or before this index.
    let lastFollowingWhiteSpaceIndex = -1; // Used by leading/detached trivia to exclude trivia at or before this index.
    let firstHtmlOpenTagIndex = -1; // Used by trailing trivia to exclude trivia at or after this index.
    // Used by leading/detached trivia to include trivia at or after this index.
    let firstPrecedingBlankLineIndex = -1; // Used by trailing trivia to exclude trivia at or after this index.
    let firstPrecedingWhiteSpaceIndex = -1; // Used by trailing trivia to exclude trivia at or after this index.
    for (let i = 0; i < triviaArray.length; i++) {
        const trivia = triviaArray[i];
        if (trivia.hasPrecedingLineTerminator || trivia.hasFollowingLineTerminator) {
            hasLineTerminator = true;
        }
        if (trivia.hasPrecedingBlankLine) {
            // trailing trivia will stop before this trivia, unless
            // it is followed by an HTML close tag trivia.
            if (firstPrecedingBlankLineIndex === -1)
                firstPrecedingBlankLineIndex = i;
        }
        else if (trivia.hasPrecedingWhiteSpace) {
            // trailing trivia will stop before this trivia, unless
            // it is followed by an HTML close tag trivia.
            if (firstPrecedingWhiteSpaceIndex === -1)
                firstPrecedingWhiteSpaceIndex = i;
        }
        if (trivia.kind === tokens_1.SyntaxKind.HtmlCloseTagTrivia) {
            // leading/detached trivia will start after this trivia
            lastHtmlCloseTagIndex = i;
            // trailing trivia will include this trivia and all trivia that
            // precedes it
            firstPrecedingBlankLineIndex = -1;
            firstPrecedingWhiteSpaceIndex = -1;
        }
        else if (trivia.kind === tokens_1.SyntaxKind.HtmlOpenTagTrivia) {
            // trailing trivia will stop before this trivia
            if (firstHtmlOpenTagIndex === -1)
                firstHtmlOpenTagIndex = i;
        }
        if (trivia.hasFollowingBlankLine) {
            // leading trivia will start after this trivia, unless
            // it is preceded by an HTML open tag trivia
            if (firstHtmlOpenTagIndex === -1) {
                lastFollowingBlankLineIndex = i;
            }
        }
        else if (trivia.hasFollowingWhiteSpace) {
            // leading trivia will start after this trivia, unless
            // it is preceded by an HTML open tag trivia
            if (firstHtmlOpenTagIndex === -1) {
                lastFollowingWhiteSpaceIndex = i;
            }
        }
    }
    // Used by leading/detached trivia to exclude trivia at or before this index.
    const lastFollowingBreakIndex = hasLineTerminator ? lastFollowingBlankLineIndex : lastFollowingWhiteSpaceIndex;
    // Used by trailing trivia to exclude trivia at or after this index.
    const firstPrecedingBreakIndex = hasLineTerminator ? firstPrecedingBlankLineIndex : firstPrecedingWhiteSpaceIndex;
    let trailingEnd = 0; // exclusive
    if (lastHtmlCloseTagIndex !== -1)
        trailingEnd = lastHtmlCloseTagIndex + 1;
    if (firstPrecedingBreakIndex !== -1)
        trailingEnd = firstPrecedingBreakIndex;
    let leadingStart = triviaArray.length; // inclusive
    if (firstHtmlOpenTagIndex !== -1)
        leadingStart = firstHtmlOpenTagIndex;
    if (lastFollowingBreakIndex > 1)
        leadingStart = lastFollowingBreakIndex - 1;
    return { trailingEnd, leadingStart };
}
function attachTrivia(node, leadingTrivia, trailingTrivia, hasFollowingLineTerminator) {
    var _a;
    if (leadingTrivia === null || leadingTrivia === void 0 ? void 0 : leadingTrivia.length) {
        const { trailingEnd, leadingStart } = splitTrivia(leadingTrivia, /*hasFollowingLineTerminator*/ false);
        let nodeLeadingTrivia;
        let nodeDetachedTrivia;
        for (let i = leadingTrivia.length - 1; i >= trailingEnd; i--) {
            const trivia = leadingTrivia.pop();
            if (!trivia)
                break;
            if (i >= leadingStart) {
                (nodeLeadingTrivia || (nodeLeadingTrivia = [])).unshift(trivia);
            }
            else if (i >= trailingEnd) {
                (nodeDetachedTrivia || (nodeDetachedTrivia = [])).unshift(trivia);
            }
        }
        if (nodeDetachedTrivia)
            (0, nodeInternal_1.getNodeAccessor)().setDetachedTrivia(node, nodeDetachedTrivia);
        if (nodeLeadingTrivia)
            (0, nodeInternal_1.getNodeAccessor)().setLeadingTrivia(node, nodeLeadingTrivia);
    }
    if (trailingTrivia === null || trailingTrivia === void 0 ? void 0 : trailingTrivia.length) {
        const { trailingEnd } = splitTrivia(trailingTrivia, hasFollowingLineTerminator);
        let nodeTrailingTrivia;
        for (let i = 0; i < trailingEnd; i++) {
            const trivia = trailingTrivia.shift();
            if (!trivia)
                break;
            (nodeTrailingTrivia || (nodeTrailingTrivia = ((_a = node.trailingTrivia) === null || _a === void 0 ? void 0 : _a.slice()) || [])).push(trivia);
        }
        if (nodeTrailingTrivia)
            (0, nodeInternal_1.getNodeAccessor)().setTrailingTrivia(node, nodeTrailingTrivia);
    }
}
function promoteTrivia(parent, firstChild, lastChild) {
    if (firstChild && firstChild === lastChild && parent.pos === firstChild.pos && parent.end === firstChild.end && parent.kind !== tokens_1.SyntaxKind.RightHandSideList) {
        promoteAllTrivia(parent, firstChild);
    }
    else {
        if (firstChild && parent.pos === firstChild.pos)
            promoteLeadingTrivia(parent, firstChild);
        if (lastChild && parent.end === lastChild.end)
            promoteTrailingTrivia(parent, lastChild);
    }
}
function promoteLeadingTrivia(parent, firstChild) {
    var _a, _b, _c, _d, _e;
    if (firstChild.detachedTrivia) {
        (0, nodeInternal_1.getNodeAccessor)().setDetachedTrivia(parent, (0, core_1.concat)((_a = parent.detachedTrivia) === null || _a === void 0 ? void 0 : _a.slice(), firstChild.detachedTrivia.slice()));
        (0, nodeInternal_1.getNodeAccessor)().setDetachedTrivia(firstChild, undefined);
    }
    let firstChildLeadingTrivia = (_b = firstChild.leadingTrivia) === null || _b === void 0 ? void 0 : _b.slice();
    let firstChildTrailingTrivia = (_c = firstChild.trailingTrivia) === null || _c === void 0 ? void 0 : _c.slice();
    let parentLeadingTrivia;
    if (firstChildLeadingTrivia) {
        if (firstChildTrailingTrivia) {
            let leadingTag = firstChildLeadingTrivia.shift();
            let trailingTag = firstChildTrailingTrivia.pop();
            while (leadingTag && (!trailingTag || !matched(leadingTag, trailingTag))) {
                (parentLeadingTrivia || (parentLeadingTrivia = ((_d = parent.leadingTrivia) === null || _d === void 0 ? void 0 : _d.slice()) || [])).push(leadingTag);
                leadingTag = firstChildLeadingTrivia.shift();
            }
            if (leadingTag)
                firstChildLeadingTrivia.unshift(leadingTag);
            if (trailingTag)
                firstChildTrailingTrivia.unshift(trailingTag);
        }
        else {
            parentLeadingTrivia = (0, core_1.concat)((_e = parent.leadingTrivia) === null || _e === void 0 ? void 0 : _e.slice(), firstChildLeadingTrivia);
            firstChildLeadingTrivia = undefined;
        }
    }
    (0, nodeInternal_1.getNodeAccessor)().setLeadingTrivia(firstChild, firstChildLeadingTrivia);
    (0, nodeInternal_1.getNodeAccessor)().setTrailingTrivia(firstChild, firstChildTrailingTrivia);
    if (parentLeadingTrivia)
        (0, nodeInternal_1.getNodeAccessor)().setLeadingTrivia(parent, parentLeadingTrivia);
}
function promoteTrailingTrivia(parent, lastChild) {
    var _a, _b, _c, _d;
    let lastChildTrailingTrivia = (_a = lastChild.trailingTrivia) === null || _a === void 0 ? void 0 : _a.slice();
    let lastChildLeadingTrivia = (_b = lastChild.leadingTrivia) === null || _b === void 0 ? void 0 : _b.slice();
    let parentTrailingTrivia;
    if (lastChildTrailingTrivia) {
        if (lastChildLeadingTrivia) {
            let leadingTag = lastChildLeadingTrivia.shift();
            let trailingTag = lastChildTrailingTrivia.pop();
            while (trailingTag && (!leadingTag || !matched(leadingTag, trailingTag))) {
                (parentTrailingTrivia || (parentTrailingTrivia = ((_c = parent.trailingTrivia) === null || _c === void 0 ? void 0 : _c.slice()) || [])).unshift(trailingTag);
                trailingTag = lastChildTrailingTrivia.pop();
            }
            if (leadingTag)
                lastChildLeadingTrivia.unshift(leadingTag);
            if (trailingTag)
                lastChildTrailingTrivia.unshift(trailingTag);
        }
        else {
            parentTrailingTrivia = (0, core_1.concat)(lastChildTrailingTrivia, (_d = parent.trailingTrivia) === null || _d === void 0 ? void 0 : _d.slice());
            lastChildTrailingTrivia = undefined;
        }
    }
    (0, nodeInternal_1.getNodeAccessor)().setTrailingTrivia(lastChild, lastChildTrailingTrivia);
    (0, nodeInternal_1.getNodeAccessor)().setLeadingTrivia(lastChild, lastChildLeadingTrivia);
    if (parentTrailingTrivia)
        (0, nodeInternal_1.getNodeAccessor)().setTrailingTrivia(parent, parentTrailingTrivia);
}
function promoteAllTrivia(parent, onlyChild) {
    var _a, _b, _c;
    if (onlyChild.detachedTrivia) {
        (0, nodeInternal_1.getNodeAccessor)().setDetachedTrivia(parent, (0, core_1.concat)((_a = parent.detachedTrivia) === null || _a === void 0 ? void 0 : _a.slice(), onlyChild.detachedTrivia.slice()));
        (0, nodeInternal_1.getNodeAccessor)().setDetachedTrivia(onlyChild, undefined);
    }
    if (onlyChild.leadingTrivia) {
        (0, nodeInternal_1.getNodeAccessor)().setLeadingTrivia(parent, (0, core_1.concat)((_b = parent.leadingTrivia) === null || _b === void 0 ? void 0 : _b.slice(), onlyChild.leadingTrivia.slice()));
        (0, nodeInternal_1.getNodeAccessor)().setLeadingTrivia(onlyChild, undefined);
    }
    if (onlyChild.trailingTrivia) {
        (0, nodeInternal_1.getNodeAccessor)().setTrailingTrivia(parent, (0, core_1.concat)(onlyChild.trailingTrivia.slice(), (_c = parent.trailingTrivia) === null || _c === void 0 ? void 0 : _c.slice()));
        (0, nodeInternal_1.getNodeAccessor)().setTrailingTrivia(onlyChild, undefined);
    }
}
function failUnhandled(value) {
    throw new Error("Unhandled case: " + value);
}
//# sourceMappingURL=parser.js.map