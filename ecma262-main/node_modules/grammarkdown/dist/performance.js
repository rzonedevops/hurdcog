"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 *
 * THIRD PARTY LICENSE NOTICE:
 *
 * The following is derived from the implementation of `ts.performance` in TypeScript.
 *
 * TypeScript is licensed under the Apache 2.0 License, a copy of which can be found here:
 *
 *   https://github.com/microsoft/TypeScript/blob/b1323feb7b69acde6916889ade5415865abe9bd2/LICENSE.txt
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.reset = exports.getMeasures = exports.getDuration = exports.getMark = exports.measure = exports.mark = void 0;
function hasRequiredAPI(performance, PerformanceObserver) {
    return typeof performance === "object" &&
        typeof performance.timeOrigin === "number" &&
        typeof performance.clearMarks === "function" &&
        (typeof performance.clearMeasures === "function" || performance.clearMeasures === undefined) &&
        typeof performance.mark === "function" &&
        typeof performance.measure === "function" &&
        typeof performance.now === "function" &&
        typeof PerformanceObserver === "function";
}
function tryGetWebPerformanceHooks() {
    if (typeof performance === "object" &&
        typeof PerformanceObserver === "function" &&
        hasRequiredAPI(performance, PerformanceObserver)) {
        return {
            performance,
            PerformanceObserver
        };
    }
}
function tryGetNodePerformanceHooks() {
    if (typeof module === "object" && typeof require === "function" && typeof process === "object") {
        try {
            const { performance, PerformanceObserver } = require("perf_hooks");
            if (hasRequiredAPI(performance, PerformanceObserver)) {
                // there is a bug in Node's performance.measure prior to 12.16.3/13.13.0
                const match = /^(\d+)\.(\d+)\.(\d+)$/.exec(process.versions.node);
                const major = match ? parseInt(match[1], 10) : 0;
                const minor = match ? parseInt(match[2], 10) : 0;
                const patch = match ? parseInt(match[3], 10) : 0;
                if (major < 12 ||
                    major === 12 && (minor < 16 || minor === 16 && patch < 3) ||
                    major === 13 && (minor < 13)) {
                    return {
                        performance: {
                            get timeOrigin() { return performance.timeOrigin; },
                            now() { return performance.now(); },
                            clearMarks(name) { return performance.clearMarks(name); },
                            mark(name) { return performance.mark(name); },
                            measure(name, start = "nodeStart", end) {
                                if (end === undefined) {
                                    end = "__performance.measure-fix__";
                                    performance.mark(end);
                                }
                                performance.measure(name, start, end);
                                if (end = "__performance.measure-fix__") {
                                    performance.clearMarks("__performance.measure-fix__");
                                }
                            }
                        },
                        PerformanceObserver
                    };
                }
                return {
                    performance,
                    PerformanceObserver
                };
            }
        }
        catch (_a) {
            // ignore errors
        }
    }
}
const nativePerformanceHooks = tryGetWebPerformanceHooks() || tryGetNodePerformanceHooks();
const nativePerformance = nativePerformanceHooks === null || nativePerformanceHooks === void 0 ? void 0 : nativePerformanceHooks.performance;
const marks = new Map();
const measures = new Map();
let observer;
reset();
function mark(markName) {
    nativePerformance === null || nativePerformance === void 0 ? void 0 : nativePerformance.mark(markName);
}
exports.mark = mark;
function measure(measureName, startMark, endMark) {
    if (startMark !== undefined && endMark !== undefined) {
        nativePerformance === null || nativePerformance === void 0 ? void 0 : nativePerformance.measure(measureName, startMark, endMark);
    }
    else if (startMark !== undefined) {
        nativePerformance === null || nativePerformance === void 0 ? void 0 : nativePerformance.measure(measureName, startMark);
    }
    else {
        nativePerformance === null || nativePerformance === void 0 ? void 0 : nativePerformance.measure(measureName);
    }
}
exports.measure = measure;
function getMark(markName) {
    var _a;
    return (_a = marks.get(markName)) !== null && _a !== void 0 ? _a : 0;
}
exports.getMark = getMark;
function getDuration(measureName) {
    var _a;
    return (_a = measures.get(measureName)) !== null && _a !== void 0 ? _a : 0;
}
exports.getDuration = getDuration;
function getMeasures() {
    return measures;
}
exports.getMeasures = getMeasures;
function reset() {
    var _a;
    nativePerformance === null || nativePerformance === void 0 ? void 0 : nativePerformance.clearMarks();
    (_a = nativePerformance === null || nativePerformance === void 0 ? void 0 : nativePerformance.clearMeasures) === null || _a === void 0 ? void 0 : _a.call(nativePerformance);
    observer === null || observer === void 0 ? void 0 : observer.disconnect();
    marks.clear();
    measures.clear();
    if (nativePerformanceHooks) {
        observer !== null && observer !== void 0 ? observer : (observer = new nativePerformanceHooks.PerformanceObserver(observePerformance));
        observer.observe({ entryTypes: ["mark", "measure"] });
    }
}
exports.reset = reset;
function observePerformance(list) {
    for (const mark of list.getEntriesByType("mark")) {
        marks.set(mark.name, mark.startTime);
    }
    for (const measure of list.getEntriesByType("measure")) {
        measures.set(measure.name, (measures.get(measure.name) || 0) + measure.duration);
    }
}
//# sourceMappingURL=performance.js.map