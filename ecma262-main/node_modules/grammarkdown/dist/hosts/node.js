"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeAsyncHost = void 0;
const path = require("path");
const fs = require("fs");
const os = require("os");
const url = require("url");
const core_1 = require("../core");
const host_1 = require("../host");
/** {@docCategory Hosts} */
class NodeAsyncHost extends host_1.CoreAsyncHost {
    constructor(options = {}) {
        const { ignoreCase = ignoreCaseFallback(), readFile = readFileFallback, writeFile = writeFileFallback, ...baseOptions } = options;
        super({
            ...baseOptions,
            ignoreCase,
            resolveFile: resolveFileFallback,
            readFile: readFile ? (file, cancelToken) => readFile(file, cancelToken) : cannotComplete,
            writeFile: writeFile ? (file, content, cancelToken) => writeFile(file, content, cancelToken) : cannotComplete
        });
    }
}
exports.NodeAsyncHost = NodeAsyncHost;
function resolveFileFallback(file, referer) {
    if ((0, core_1.isFileUri)(file) || path.isAbsolute(file)) {
        return file;
    }
    else if (referer) {
        return (0, core_1.isUri)(referer)
            ? url.resolve(referer, file)
            : path.resolve(path.dirname(referer), file);
    }
    else {
        return path.resolve(file);
    }
}
function readFileFallback(file) {
    return new Promise((resolve, reject) => {
        file = (0, core_1.getLocalPath)(file);
        if ((0, core_1.isUri)(file))
            return undefined;
        fs.readFile(file, null, (error, buffer) => resolve(error ? undefined : decodeBuffer(buffer)));
    });
}
function decodeBuffer(buffer) {
    if (buffer[0] === 0xff && buffer[1] === 0xfe) {
        // UTF-16 LE BOM
        return buffer.slice(2).toString("utf16le");
    }
    else if (buffer[0] === 0xfe && buffer[1] === 0xff) {
        // UTF-16 BE BOM
        return buffer.slice(2).swap16().toString("utf16le");
    }
    else if (buffer[0] === 0xef && buffer[1] === 0xbb && buffer[2] === 0xbf) {
        // UTF-8 with BOM
        return buffer.slice(3).toString("utf8");
    }
    else {
        // plain UTF8
        return buffer.toString("utf8");
    }
}
function writeFileFallback(file, content) {
    return new Promise((resolve, reject) => {
        file = (0, core_1.getLocalPath)(file);
        if ((0, core_1.isUri)(file))
            throw new Error("Cannot write to a non-file URI.");
        fs.writeFile(file, content, "utf8", (error) => error ? reject(error) : resolve());
    });
}
function cannotComplete() {
    throw new Error("Operation cannot be completed");
}
function ignoreCaseFallback() {
    return /^(win32|win64|darwin)$/.test(os.platform());
}
//# sourceMappingURL=node.js.map