/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
import { Cancelable } from "@esfx/cancelable";
import { CancelToken } from "@esfx/async-canceltoken";
import { Disposable } from "@esfx/disposable";
export interface DictionaryLike<T> {
    [key: string]: T;
    [key: number]: T;
}
export declare function mapFromObject<T>(object: DictionaryLike<T>): Map<string, T>;
export declare function binarySearch(array: number[], value: number): number;
export declare function binarySearchBy<T, K>(array: readonly T[], key: K, selector: (value: T) => K, comparison?: (x: K, y: K) => number): number;
export declare function compareNumbers(a: number, b: number): number;
export declare function compareStrings(x: string | undefined, y: string | undefined, ignoreCase?: boolean): 0 | 1 | -1;
export declare function compare(x: any, y: any): 0 | 1 | -1;
export declare function forEach<T, U>(array: ReadonlyArray<T> | undefined, cb: (value: T) => U | undefined): U | undefined;
export declare const emptyIterable: IterableIterator<never>;
export declare function identity<T>(value: T): T;
export declare function first<T>(iterable: Iterable<T> | T[] | undefined): T | undefined;
export declare function last<T>(iterable: Iterable<T> | T[] | undefined): T | undefined;
export declare function only<T>(iterable: Iterable<T> | T[] | undefined): T | undefined;
export declare function stableSort<T>(array: ReadonlyArray<T>, comparer: (a: T, b: T) => number): T[];
export declare function concat<T>(a: T[], b: T[] | undefined): T[];
export declare function concat<T>(a: T[] | undefined, b: T[]): T[];
export declare function concat<T>(a: T[] | undefined, b: T[] | undefined): T[] | undefined;
export declare function deduplicateSorted<T>(array: readonly T[], comparer: (a: T, b: T) => number | boolean): T[];
export declare function promiseFinally<T>(promise: PromiseLike<T>, onFinally: () => void): PromiseLike<T>;
export declare function pipe<T, U>(result: T | Promise<T>, next: (value: T) => U | Promise<U>): U | Promise<U>;
export declare function pipe<T, U>(result: T | Promise<T> | undefined, next: (value: T | undefined) => U | Promise<U>): U | Promise<U>;
export declare function pipe<T, U>(result: T | Promise<T> | undefined, next: (value: T | undefined) => U | Promise<U> | undefined): U | Promise<U> | undefined;
export declare function isPromise<T>(value: T | Promise<T> | undefined): value is Promise<T>;
export declare function forEachPossiblyAsync<T, U>(iterable: Iterable<T>, callback: (value: T) => Promise<U> | U | undefined): void | Promise<void>;
export declare function mapSet<K extends object, V>(map: WeakMap<K, V>, key: K, value: V): V;
export declare function mapSet<K, V>(map: Map<K, V>, key: K, value: V): V;
export declare function toCancelToken(cancelable: Cancelable): CancelToken;
export declare function toCancelToken(cancelable: Cancelable | null | undefined): CancelToken | undefined;
export declare class AggregateCancelable {
    private _cancelSource;
    private _subscriptions;
    private _cancelCount;
    get canBeCanceled(): boolean;
    get cancelable(): CancelToken;
    addCancelable(cancelable: Cancelable | undefined): {
        unsubscribe: () => void;
        [Disposable.dispose]: () => void;
    } | undefined;
}
/**
 * Synchronizes multiple asynchronous cancelable calls for the same resource,
 * such that the operation is only canceled when all callers have canceled.
 */
export declare class SharedOperation<T> {
    private _callback;
    private _sharedOperation;
    constructor(callback: (cancelToken?: CancelToken) => PromiseLike<T> | T);
    invoke(cancelable?: Cancelable): Promise<T>;
    private _invokeWorker;
}
export declare function isUri(file: string): boolean;
export declare function isFileUri(file: string): boolean;
export declare function getLocalPath(file: string): string;
